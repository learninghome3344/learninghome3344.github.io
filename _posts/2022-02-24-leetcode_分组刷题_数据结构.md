---
layout:     post   				    # 使用的布局（不需要改）
title:      leetcode-分组刷题-数据结构 				# 标题 
subtitle:    #副标题
date:       2022-02-24 				# 时间
author:     FishRedLeaf 						# 作者
header-img: iu_img/my_iu_9.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - DSA与刷题/leetcode
---

[toc]

# 分组刷题-数据结构

## 1数组
### 哈希
#### 1.两数之和
[https://leetcode-cn.com/problems/two-sum](https://leetcode-cn.com/problems/two-sum) 
###### 原题
给定一个整数数组 `nums`  和一个整数目标值 `target` ，请你在该数组中找出 **和为目标值** *`target`*   的那  **两个**  整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

 **示例 1：** 

```

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

```
 **示例 2：** 

```

输入：nums = [3,2,4], target = 6
输出：[1,2]

```
 **示例 3：** 

```

输入：nums = [3,3], target = 6
输出：[0,1]

```


 **提示：** 
-  `2 <= nums.length <= 10^4` 
-  `-10^9 <= nums[i] <= 10^9` 
-  `-10^9 <= target <= 10^9` 
-  **只会存在一个有效答案** 
 **进阶：** 你可以想出一个时间复杂度小于 `O(n^2)` 的算法吗？


**标签**
`数组` `哈希表` 


##### solution
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        d = {}
        for i, n in enumerate(nums):
            if target - n in d:
                return [d[target - n], i]
            d[n] = i
```
>
#### 36.有效的数独
[https://leetcode-cn.com/problems/valid-sudoku](https://leetcode-cn.com/problems/valid-sudoku) 
###### 原题
请你判断一个 `9 x 9` 的数独是否有效。只需要 **根据以下规则** ，验证已经填入的数字是否有效即可。
- 数字 `1-9` 在每一行只能出现一次。
- 数字 `1-9` 在每一列只能出现一次。
- 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）


 **注意：** 
- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 空白格用 `'.'` 表示。

 **示例 1：** 
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzta28wn9tj206y06ymxb.jpg" style="height:250px; width:250px" />

```

输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true

```
 **示例 2：** 

```

输入：board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```


 **提示：** 
-  `board.length == 9` 
-  `board[i].length == 9` 
-  `board[i][j]` 是一位数字（ `1-9` ）或者 `'.'` 

**标签**
`数组` `哈希表` `矩阵` 


##### solution
```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        n = len(board)
        row = [set() for _ in range(n)]
        col = [set() for _ in range(n)]
        block = [set() for _ in range(n)]

        for i in range(n):
            for j in range(n):
                z = i // 3 * 3 + j // 3
                v = board[i][j]
                if v == ".":
                    continue
                if v in row[i] or v in col[j] or v in block[z]:
                    return False
                row[i].add(v)
                col[j].add(v)
                block[z].add(v)
        return True
```
>
#### 169.求众数
[https://leetcode-cn.com/problems/majority-element](https://leetcode-cn.com/problems/majority-element) 
###### 原题
给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于**   `⌊ n/2 ⌋`  的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

 **示例 1：** 

```

输入：[3,2,3]
输出：3
```
 **示例 2：** 

```

输入：[2,2,1,1,1,2,2]
输出：2

```


 **进阶：** 
- 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

**标签**
`数组` `哈希表` `分治` `计数` `排序` 

##### solution 摩尔投票法

https://cloud.tencent.com/developer/article/1600607

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        res, cnt = None, 0
        for n in nums:
            if cnt == 0:
                res, cnt = n, 1
                continue
            if res == n:
                cnt += 1
            else:
                cnt -= 1
        return res
```
>
#### 217.存在重复元素
[https://leetcode-cn.com/problems/contains-duplicate](https://leetcode-cn.com/problems/contains-duplicate) 
###### 原题
给你一个整数数组 `nums` 。如果任一值在数组中出现 **至少两次** ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 。


 **示例 1：** 

```

输入：nums = [1,2,3,1]
输出：true
```
 **示例 2：** 

```

输入：nums = [1,2,3,4]
输出：false
```
 **示例 3：** 

```

输入：nums = [1,1,1,3,3,4,3,2,4,2]
输出：true
```


 **提示：** 
-  `1 <= nums.length <= 10^5` 
-  `-10^9 <= nums[i] <= 10^9` 

**标签**
`数组` `哈希表` `排序` 


##### solution
```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        d = {}
        for n in nums:
            d[n] = d.get(n, 0) + 1
            if d[n] > 1:
                return True
        return False
```
>
#### 349.两个数组的交集
[https://leetcode-cn.com/problems/intersection-of-two-arrays](https://leetcode-cn.com/problems/intersection-of-two-arrays) 
###### 原题
给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

 

 **示例 1：** 

```

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]

```
 **示例 2：** 

```

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的

```


 **提示：** 
-  `1 <= nums1.length, nums2.length <= 1000` 
-  `0 <= nums1[i], nums2[i] <= 1000` 

**标签**
`数组` `哈希表` `双指针` `二分查找` `排序` 


##### solution
```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        # method1

        # return list(set(nums1) & set(nums2))

        nums1_set = set(nums1)
        res_set = set()
        for n in nums2:
            if n in nums1_set:
                res_set.add(n)
        return list(res_set)
```
>
#### 350.两个数组的交集2
[https://leetcode-cn.com/problems/intersection-of-two-arrays-ii](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii) 
###### 原题
给你两个整数数组 `nums1` 和 `nums2` ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

 

 **示例 1：** 

```

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]

```
 **示例 2:** 

```

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```


 **提示：** 
-  `1 <= nums1.length, nums2.length <= 1000` 
-  `0 <= nums1[i], nums2[i] <= 1000` 


 ** **进阶** ：** 
- 如果给定的数组已经排好序呢？你将如何优化你的算法？
- 如果 `nums1` 的大小比 `nums2` 小，哪种方法更优？
- 如果 `nums2` 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

**标签**
`数组` `哈希表` `双指针` `二分查找` `排序` 


##### solution
```python
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1_dict = Counter(nums1)
        res = []
        for n in nums2:
            if n in nums1_dict:
                res.append(n)
                nums1_dict[n] -= 1
                if nums1_dict[n] == 0:
                    del nums1_dict[n]
        return res
print(Solution().intersection([1,2,2,1], [2,2]))
```
>
### 找规律
#### 48.旋转图像
[https://leetcode-cn.com/problems/rotate-image](https://leetcode-cn.com/problems/rotate-image) 
###### 原题
给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 **<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。 **请不要** 使用另一个矩阵来旋转图像。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" style="height: 188px; width: 500px;" />
```

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" style="height: 201px; width: 500px;" />
```

输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

```


 **提示：** 
-  `n == matrix.length == matrix[i].length` 
-  `1 <= n <= 20` 
-  `-1000 <= matrix[i][j] <= 1000` 



**标签**
`数组` `数学` `矩阵` 


##### solution
```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """  

        1  2  3  4  

        5  6  7  8  

        9  10 11 12  

        13 14 15 16  

        2 8 15 9  

        (0, 1) (1, 3) (3, 2) (2, 0)  

        """  

        n = len(matrix)
        for i in range(n // 2):
            for j in range((n + 1) // 2):
                tmp = matrix[i][j]
                matrix[i][j] = matrix[n - j - 1][i]
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j -1]
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]
                matrix[j][n - i - 1] = tmp

    def rotate1(self, matrix: List[List[int]]) -> None:
        """  

        Do not return anything, modify matrix in-place instead.  

        """  
        
        # 1 将矩阵进行上下翻转  
        
        # 2 将矩阵沿着轴对角线轴对称的元素交换  
        
        n = len(matrix)
        for i in range(n // 2):
            matrix[i], matrix[n - i - 1] = matrix[n - i - 1], matrix[i]
        
        for i in range(n):
            for j in range(i+1, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
```
>
#### 54.螺旋矩阵
[https://leetcode-cn.com/problems/spiral-matrix](https://leetcode-cn.com/problems/spiral-matrix) 
###### 原题
给你一个 `m` 行 `n` 列的矩阵  `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" style="width: 242px; height: 242px;" />
```

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" style="width: 322px; height: 242px;" />
```

输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]

```


 **提示：** 
-  `m == matrix.length` 
-  `n == matrix[i].length` 
-  `1 <= m, n <= 10` 
-  `-100 <= matrix[i][j] <= 100` 

**标签**
`数组` `矩阵` `模拟` 


##### solution
```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
      	# 用四个变量来控制边界，然后因为方向总是：→↓←↑ 左右下上循环往复  
        
        if not matrix:
            return []
        direction = 0
        left_bound, right_bound = 0, len(matrix[0]) - 1
        up_bound, down_bound = 0, len(matrix) - 1
        res = []
        while True:
            if direction == 0:
                for i in range(left_bound, right_bound+1):
                    res.append(matrix[up_bound][i])
                up_bound += 1
            elif direction == 1:
                for i in range(up_bound, down_bound+1):
                    res.append(matrix[i][right_bound])
                right_bound -= 1
            elif direction == 2:
                for i in range(right_bound, left_bound-1, -1):
                    res.append(matrix[down_bound][i])
                down_bound -= 1
            else:
                for i in range(down_bound, up_bound-1, -1):
                    res.append(matrix[i][left_bound])
                left_bound += 1
            if left_bound > right_bound or up_bound > down_bound:
                return res
            direction = (1 + direction) % 4
```
>
#### 59.螺旋矩阵2
[https://leetcode-cn.com/problems/spiral-matrix-ii](https://leetcode-cn.com/problems/spiral-matrix-ii) 
###### 原题
给你一个正整数  `n` ，生成一个包含 `1` 到  `n^2`  所有元素，且元素按顺时针顺序螺旋排列的  `n x n` 正方形矩阵 `matrix` 。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" style="width: 242px; height: 242px;" />
```

输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]

```
 **示例 2：** 

```

输入：n = 1
输出：[[1]]

```


 **提示：** 
-  `1 <= n <= 20` 

**标签**
`数组` `矩阵` `模拟` 


##### solution
```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        matrix = [[0] * n for _ in range(n)]
        direction = 0
        left_bound, right_bound = 0, n-1
        up_bound, down_bound = 0, n-1
        cur, loops = 1, n * n
        while cur <= loops:
            if direction == 0:
                for i in range(left_bound, right_bound+1):
                    matrix[up_bound][i] = cur
                    cur += 1
                up_bound += 1
            elif direction == 1:
                for i in range(up_bound, down_bound+1):
                    matrix[i][right_bound] = cur
                    cur += 1
                right_bound -= 1
            elif direction == 2:
                for i in range(right_bound, left_bound-1, -1):
                    matrix[down_bound][i] = cur
                    cur += 1
                down_bound -= 1
            else:
                for i in range(down_bound, up_bound-1, -1):
                    matrix[i][left_bound] = cur
                    cur += 1
                left_bound += 1
            if left_bound > right_bound or up_bound > down_bound:
                return matrix
            direction = (1 + direction) % 4
        return matrix
```
>
#### 73.矩阵置零
[https://leetcode-cn.com/problems/set-matrix-zeroes](https://leetcode-cn.com/problems/set-matrix-zeroes) 
###### 原题
给定一个 ` *m* x *n* ` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank">原地</a>** 算法 **。** 


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" style="width: 450px; height: 169px;" />
```

输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" style="width: 450px; height: 137px;" />
```

输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]

```


 **提示：** 
-  `m == matrix.length` 
-  `n == matrix[0].length` 
-  `1 <= m, n <= 200` 
-  `-2^31 <= matrix[i][j] <= 2^31 - 1` 


 **进阶：** 
- 一个直观的解决方案是使用 `O( *m* *n* )` 的额外空间，但这并不是一个好的解决方案。
- 一个简单的改进方案是使用 `O( *m* + *n* )` 的额外空间，但这仍然不是最好的解决方案。
- 你能想出一个仅使用常量空间的解决方案吗？

**标签**
`数组` `哈希表` `矩阵` 


##### solution
```python
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """  
        
        Do not return anything, modify matrix in-place instead.  
        
        """  
        
        m, n = len(matrix), len(matrix[0])
        row0, col0 = False, False
        for i in range(n):
            if matrix[0][i] == 0:
                row0 = True
                break
        
        for i in range(m):
            if matrix[i][0] == 0:
                col0 = True
                break
        
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == 0:
                    matrix[i][0] = matrix[0][j] = 0
        
        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][0] == 0 or matrix[0][j] == 0:
                    matrix[i][j] = 0
        
        if row0:
            for i in range(n):
                matrix[0][i] = 0
        
        if col0:
            for i in range(m):
                matrix[i][0] = 0
```
>
#### 74.搜索二维矩阵
[https://leetcode-cn.com/problems/search-a-2d-matrix](https://leetcode-cn.com/problems/search-a-2d-matrix) 
###### 原题
编写一个高效的算法来判断  `m x n`  矩阵中，是否存在一个目标值。该矩阵具有如下特性：
- 每行中的整数从左到右按升序排列。
- 每行的第一个整数大于前一行的最后一个整数。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" style="width: 322px; height: 242px;" />
```

输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true

```
 **示例 2：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzxy89x6elj208y06q3yj.jpg" style="width: 322px; height: 242px;" />
```

输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false

```


 **提示：** 
-  `m == matrix.length` 
-  `n == matrix[i].length` 
-  `1 <= m, n <= 100` 
-  `-10^4 <= matrix[i][j], target <= 10^4` 

**标签**
`数组` `二分查找` `矩阵` 


##### solution
```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        if not matrix or not matrix[0]:
            return False
        m, n = len(matrix), len(matrix[0])
        up, down = 0, m-1
        while up <= down:
            row_mid = up + ((down - up) >> 1)
            if matrix[row_mid][0] <= target <= matrix[row_mid][n -1]:
                left, right = 0, n-1
                while left <= right:
                    mid = left + ((right - left) >> 1)
                    if matrix[row_mid][mid] == target:
                        return True
                    elif matrix[row_mid][mid] < target:
                        left = mid + 1
                    else:
                        right = mid - 1
                return False
            elif matrix[row_mid][0] > target:
                down = row_mid - 1
            else:
                up = row_mid + 1
        return False
```
>
#### 238.除自身以数组的乘积
[https://leetcode-cn.com/problems/product-of-array-except-self](https://leetcode-cn.com/problems/product-of-array-except-self) 
###### 原题
给你一个整数数组 `nums` ，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。

题目数据 **保证** 数组 `nums` 之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请 **不要使用除法，** 且在 `O( *n* )` 时间复杂度内完成此题。

 

 **示例 1:** 

```

输入: nums = [1,2,3,4]
输出: [24,12,8,6]

```
 **示例 2:** 

```

输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]

```


 **提示：** 
-  `2 <= nums.length <= 10^5` 
-  `-30 <= nums[i] <= 30` 
-  **保证** 数组 `nums` 之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内


 **进阶：** 你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 **不被视为** 额外空间。）


**标签**
`数组` `前缀和` 


##### solution
```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        '''  
        
        2,3,4,5,6  
        
        step1: 1,2,6,24,120  
        
        step2: 360,120,30,6,1  
        
        res:   360,240,180,144,120  
        
        '''  
        
        n = len(nums)
        left, right = [1] * n, [1] * n
        for i in range(1, n):
            left[i] = left[i-1] * nums[i-1]
        for i in range(n-2, -1, -1):
            right[i] = right[i+1] * nums[i+1]
        res = []
        for i in range(n):
            res.append(left[i] * right[i])
        return res
```
>
#### 240.搜索二维矩阵2
[https://leetcode-cn.com/problems/search-a-2d-matrix-ii](https://leetcode-cn.com/problems/search-a-2d-matrix-ii) 
###### 原题
编写一个高效的算法来搜索 ` *m* x *n* ` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：
- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。


<b>示例 1：</b>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" />
```

输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true

```
<b>示例 2：</b>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg" />
```

输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false

```


 **提示：** 
-  `m == matrix.length` 
-  `n == matrix[i].length` 
-  `1 <= n, m <= 300` 
-  `-10^9 <= matrix[i][j] <= 10^9` 
- 每行的所有元素从左到右升序排列
- 每列的所有元素从上到下升序排列
-  `-10^9 <= target <= 10^9` 

**标签**
`数组` `二分查找` `分治` `矩阵` 


##### solution
```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        if not matrix:
            return False
        m, n = len(matrix), len(matrix[0])
        i, j = m-1, 0
        while i >= 0 and j <= n-1:
            if matrix[i][j] == target:
                return True
            elif matrix[i][j] < target:
                j += 1
            else:
                i -= 1
        return False
```
>
### 双指针
#### 11.盛最多水的容器
[https://leetcode-cn.com/problems/container-with-most-water](https://leetcode-cn.com/problems/container-with-most-water) 
###### 原题
给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

 **说明：** 你不能倾斜容器。

 

 **示例 1：** 

<img alt="" src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" />

```

输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```
 **示例 2：** 

```

输入：height = [1,1]
输出：1

```


 **提示：** 
-  `n == height.length` 
-  `2 <= n <= 10^5` 
-  `0 <= height[i] <= 10^4` 

**标签**
`贪心` `数组` `双指针` 


##### solution
```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left, right = 0, len(height)-1
        res = 0
        while left < right:
            cur_height = min(height[left], height[right])
            cur_width = right - left
            res = max(res, cur_height * cur_width)
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        return res
```
>
#### 15.三数之和
[https://leetcode-cn.com/problems/3sum](https://leetcode-cn.com/problems/3sum) 
###### 原题
给你一个包含 `n` 个整数的数组  `nums` ，判断  `nums`  中是否存在三个元素 *a，b，c ，* 使得  *a + b + c =* 0 ？请你找出所有和为 `0` 且不重复的三元组。

 **注意：** 答案中不可以包含重复的三元组。

 

 **示例 1：** 

```

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]

```
 **示例 2：** 

```

输入：nums = []
输出：[]

```
 **示例 3：** 

```

输入：nums = [0]
输出：[]

```


 **提示：** 
-  `0 <= nums.length <= 3000` 
-  `-10^5 <= nums[i] <= 10^5` 

**标签**
`数组` `双指针` `排序` 


##### solution
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        if n < 3:
            return []
        res = []
        nums.sort()
        for i in range(n-2):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            left, right = i+1, n-1
            while left < right:
                sum_ = nums[i] + nums[left] + nums[right]
                if sum_ == 0:
                    res.append([nums[i], nums[left], nums[right]])
                    left += 1
                    right -= 1
                    while left < right and nums[left] == nums[left-1]:
                        left += 1
                    while left < right and nums[right] == nums[right+1]:
                        right -= 1
                elif sum_ < 0:
                    left += 1
                else:
                    right -= 1
        return res
```
>
#### 16.最接近的三数之和
[https://leetcode-cn.com/problems/3sum-closest](https://leetcode-cn.com/problems/3sum-closest) 
###### 原题
给你一个长度为 `n` 的整数数组 `nums` 和 一个目标值 `target` 。请你从 `nums` 中选出三个整数，使它们的和与 `target` 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。

 

 **示例 1：** 

```

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。

```
 **示例 2：** 

```

输入：nums = [0,0,0], target = 1
输出：0

```


 **提示：** 
-  `3 <= nums.length <= 1000` 
-  `-1000 <= nums[i] <= 1000` 
-  `-10^4 <= target <= 10^4` 

**标签**
`数组` `双指针` `排序` 


##### solution
```python
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        n = len(nums)
        nums.sort()
        res, diff = None, float('inf')
        for i in range(n-2):
            left, right = i+1, n-1
            while left < right:
                sum_ = nums[i] + nums[left] + nums[right]
                if abs(sum_ - target) < diff:
                    res, diff = sum_, abs(sum_ - target)
                if sum_ == target:
                    return sum_
                elif sum_ < target:
                    left += 1
                else:
                    right -= 1
        return res
```
>
#### 26.删除排序数组中的重复项
[https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array) 
###### 原题
给你一个 **升序排列** 的数组 `nums` ，请你 **<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank"> 原地</a>** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 `k` 个元素，那么 `nums` 的前 `k` 个元素应该保存最终结果。

将最终结果插入 `nums` 的前 `k` 个位置后返回 `k` 。

不要使用额外的空间，你必须在 **<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank">原地 </a>修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

 **判题标准:** 

系统会用下面的代码来测试你的题解:

```

int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```
如果所有断言都通过，那么您的题解将被 **通过** 。

 

 **示例 1：** 

```

输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

```
 **示例 2：** 

```

输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。

```


 **提示：** 
-  `0 <= nums.length <= 3 * 10^4` 
-  `-10^4 <= nums[i] <= 10^4` 
-  `nums` 已按 **升序** 排列

**标签**
`数组` `双指针` 


##### solution
```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        i, j = 0, 1
        while j < len(nums):
            if nums[j] != nums[i]:
                nums[i+1] = nums[j]
                i += 1
            j += 1
        return i+1
```
>
#### 88.合并两个有序数组
[https://leetcode-cn.com/problems/merge-sorted-array](https://leetcode-cn.com/problems/merge-sorted-array) 
###### 原题
给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2` ，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

 **注意：** 最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况， `nums1` 的初始长度为 `m + n` ，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。 `nums2` 的长度为 `n` 。

 

 **示例 1：** 

```

输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。

```
 **示例 2：** 

```

输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。

```
 **示例 3：** 

```

输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。

```


 **提示：** 
-  `nums1.length == m + n` 
-  `nums2.length == n` 
-  `0 <= m, n <= 200` 
-  `1 <= m + n <= 200` 
-  `-10^9 <= nums1[i], nums2[j] <= 10^9` 


 **进阶：** 你可以设计实现一个时间复杂度为 `O(m + n)` 的算法解决此问题吗？


**标签**
`数组` `双指针` `排序` 


##### solution
```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """  
        
        Do not return anything, modify nums1 in-place instead.  
        
        """  
        
        i, j, k = m-1, n-1, m+n-1
        nums1[:] = nums1[:m] + nums2[:n]
        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
        while i >= 0:
            nums1[k] = nums1[i]
            k -= 1
            i -= 1
        while j >= 0:
            nums1[k] = nums2[j]
            k -= 1
            j -= 1
```
>
#### 283.移动零
[https://leetcode-cn.com/problems/move-zeroes](https://leetcode-cn.com/problems/move-zeroes) 
###### 原题
给定一个数组 `nums` ，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

 **请注意** ，必须在不复制数组的情况下原地对数组进行操作。

 

 **示例 1:** 

```

输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]

```
 **示例 2:** 

```

输入: nums = [0]
输出: [0]
```


 **提示** :
<meta charset="UTF-8" />
-  `1 <= nums.length <= 10^4` 
-  `-2^31 <= nums[i] <= 2^31 - 1` 


<b>进阶：</b>你能尽量减少完成的操作次数吗？


**标签**
`数组` `双指针` 


##### solution
```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """  
        Do not return anything, modify nums in-place instead.  
        """  
        i, j = 0, 0
        while j < len(nums):
            if nums[j] != 0:
                nums[i] = nums[j]
                i += 1
            j += 1
        nums[i:] = [0] * (len(nums) - i)
```
>
#### 392.判断子序列
[https://leetcode-cn.com/problems/is-subsequence](https://leetcode-cn.com/problems/is-subsequence) 
###### 原题
给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如， `"ace"` 是 `"abcde"` 的一个子序列，而 `"aec"` 不是）。

 **进阶：** 

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

 **致谢：** 

特别感谢 **** <a href="https://leetcode.com/pbrother/">@pbrother </a>添加此问题并且创建所有测试用例。

 

 **示例 1：** 

```

输入：s = "abc", t = "ahbgdc"
输出：true

```
 **示例 2：** 

```

输入：s = "axc", t = "ahbgdc"
输出：false

```


 **提示：** 
-  `0 <= s.length <= 100` 
-  `0 <= t.length <= 10^4` 
- 两个字符串都只由小写字符组成。

**标签**
`双指针` `字符串` `动态规划` 


##### solution
```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        i, j = 0, 0
        while i < len(s) and j < len(t):
            if s[i] == t[j]:
                i += 1
            j += 1
        return i == len(s)
```
>
### 其他
#### 31.下一个排列
[https://leetcode-cn.com/problems/next-permutation](https://leetcode-cn.com/problems/next-permutation) 
###### 原题
整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。
- 例如， `arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列： `[1,2,3]` 、 `[1,3,2]` 、 `[3,1,2]` 、 `[2,3,1]` 。
整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。
- 例如， `arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
- 类似地， `arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。
给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须 **<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank"> 原地 </a>** 修改，只允许使用额外常数空间。

 

 **示例 1：** 

```

输入：nums = [1,2,3]
输出：[1,3,2]

```
 **示例 2：** 

```

输入：nums = [3,2,1]
输出：[1,2,3]

```
 **示例 3：** 

```

输入：nums = [1,1,5]
输出：[1,5,1]

```


 **提示：** 
-  `1 <= nums.length <= 100` 
-  `0 <= nums[i] <= 100` 

**标签**
`数组` `双指针` 

##### solution

-   从右往左，寻找第一个降序的点，例如`[8,9,4,5,2,1]`, `5,2,1`是降序，找到4的索引partition
-   如果索引为-1，表示整个序列都是降序的，因此直接反转就行
-   否则在partition右边，从右往左找第一个比partition大的数，并交换，得到`[8,9,5,4,2,1]`
-   partition右边从降序改为升序，得到`[8,9,5,1,2,4]`

```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """  
        
        Do not return anything, modify nums in-place instead.  
        
        """  
        
        n = len(nums)

        partition = -1
        for i in range(n-1, -1, -1):
            if nums[i] > nums[i-1]:
                partition = i - 1
                break
        if partition == -1:
            nums[:] = nums[::-1]
            return
        
        for i in range(n-1, partition, -1):
            if nums[i] > nums[partition]:
                nums[i], nums[partition] = nums[partition], nums[i]
                break
        
        nums[partition+1:] = nums[partition+1:][::-1]
```
>
#### 41.缺失的第一个正数
[https://leetcode-cn.com/problems/first-missing-positive](https://leetcode-cn.com/problems/first-missing-positive) 
###### 原题
给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。
请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

 

 **示例 1：** 

```

输入：nums = [1,2,0]
输出：3

```
 **示例 2：** 

```

输入：nums = [3,4,-1,1]
输出：2

```
 **示例 3：** 

```

输入：nums = [7,8,9,11,12]
输出：1

```


 **提示：** 
-  `1 <= nums.length <= 5 * 10^5` 
-  `-2^31 <= nums[i] <= 2^31 - 1` 

**标签**
`数组` `哈希表` 

##### solution1 数和下标关联法

-   假设下标`i`位置的数是`x`，为了把数`x`放到下标`x-1`的位置，交换下标`i`和下标`x-1`的值，如果下标i位置的数仍然满足条件`1 <= nums[i] <= n and nums[i] != nums[nums[i] - 1]`，则继续交换

```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:

        def swap(nums, i, j):
            nums[i], nums[j] = nums[j], nums[i]

        n = len(nums)
        for i in range(n):
            while 1 <= nums[i] <= n and nums[i] != nums[nums[i] - 1]:
                swap(nums, i, nums[i] - 1)
        for i in range(n):
            if i+1 != nums[i]:
                return i+1
        return n+1
```

##### solution2 添加负号法

-   检查是否有第一个正整数1。
    -   如果没有，1 即为答案。
    -   如果有1
        -   如果 nums = [1]，答案即为 2
        -   如果数组长度大于1
            -   将负数、0和大于`n`的数都替换为1
            -   遍历数组。当读到数字 a 时，替换第 a 个元素的符号。注意重复元素：只能改变一次符号。由于没有下标`n`，使用下标 0 位置保存是否存在数字 n。  
            -   从下标为1的位置遍历数组，返回第一个正数元素的下标。 
            -   如果下标`1 ~ (n-1)`都为负数，那么检查`nums[0]`是否为正数，如果是则返回`n`，如果不是返回`n+1`

```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        if 1 not in nums:
            return 1
        if n == 1:
            return 2
        for i in range(n):
            if nums[i] <= 0 or nums[i] > n:
                nums[i] = 1
        for i in range(n):
            a = abs(nums[i])
            if a == n:
                nums[0] = -abs(nums[0])
            else:
                nums[a] = -abs(nums[a])
        for i in range(1, n):
            if nums[i] > 0:
                return i
        if nums[0] > 0:
            return n
        return n+1
print(Solution().firstMissingPositive2([1,3,-1,5,2]))
```
>
#### 56.合并区间
[https://leetcode-cn.com/problems/merge-intervals](https://leetcode-cn.com/problems/merge-intervals) 
###### 原题
以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

 

 **示例 1：** 

```

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

```
 **示例 2：** 

```

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```


 **提示：** 
-  `1 <= intervals.length <= 10^4` 
-  `intervals[i].length == 2` 
-  `0 <= start<sub>i</sub> <= end<sub>i</sub> <= 10^4` 

**标签**
`数组` `排序` 


##### solution
```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key = lambda x: x[0])
        res = []
        for interval in intervals:
            if res and res[-1][1] >= interval[0]:
                res[-1] = [res[-1][0], max(res[-1][1], interval[1])]
            else:
                res.append(interval)
        return res
```
>
#### 118.杨辉三角
[https://leetcode-cn.com/problems/pascals-triangle](https://leetcode-cn.com/problems/pascals-triangle) 
###### 原题
给定一个非负整数  *`numRows` ，* 生成「杨辉三角」的前  *`numRows`  * 行。

<small>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</small>

<img alt="" src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" />

 

 **示例 1:** 

```

输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]

```
 **示例 2:** 

```

输入: numRows = 1
输出: [[1]]

```


 **提示:** 
-  `1 <= numRows <= 30` 

**标签**
`数组` `动态规划` 


##### solution
```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        if numRows >= 1:
            res.append([1])
        if numRows >= 2:
            res.append([1, 1])
        for i in range(3, numRows+1):
            tmp = [1]
            for i in range(1, len(res[-1])):
                tmp.append(res[-1][i] + res[-1][i-1])
            tmp.append(1)
            res.append(tmp)
        return res
```
>
#### 189.旋转数组
[https://leetcode-cn.com/problems/rotate-array](https://leetcode-cn.com/problems/rotate-array) 
###### 原题
给你一个数组，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

 

 **示例 1:** 

```

输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]

```
 **示例 2:** 

```

输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```


 **提示：** 
-  `1 <= nums.length <= 10^5` 
-  `-2^31 <= nums[i] <= 2^31 - 1` 
-  `0 <= k <= 10^5` 


 **进阶：** 
- 尽可能想出更多的解决方案，至少有 **三种** 不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 `O(1)` 的 **原地** 算法解决这个问题吗？

**标签**
`数组` `数学` `双指针` 


##### solution
```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """  
        
        Do not return anything, modify nums in-place instead.  
        
        """  
        
        # method1  
        
        # n = len(nums)  
        
        # k %= n  
        
        # nums[:] = nums[n-k:] + nums[:n-k]  
        
  
        n = len(nums)
        k %= n
        nums[n-k:] = nums[n-k:][::-1]
        nums[:n-k] = nums[:n-k][::-1]
        nums[:] = nums[::-1]
```
>
#### 268.缺失数字
[https://leetcode-cn.com/problems/missing-number](https://leetcode-cn.com/problems/missing-number) 
###### 原题
给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。


 **示例 1：** 

```

输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```
 **示例 2：** 

```

输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```
 **示例 3：** 

```

输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
```
 **示例 4：** 

```

输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
```


 **提示：** 
-  `n == nums.length` 
-  `1 <= n <= 10^4` 
-  `0 <= nums[i] <= n` 
-  `nums` 中的所有数字都 **独一无二** 


 **进阶：** 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?


**标签**
`位运算` `数组` `哈希表` `数学` `排序` 


##### solution
```python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        res = n
        for i in range(n):
            res ^= i
        for i in nums:
            res ^= i
        return res
```
>
#### 287.寻找重复数
[https://leetcode-cn.com/problems/find-the-duplicate-number](https://leetcode-cn.com/problems/find-the-duplicate-number) 
###### 原题
给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n` ），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

 

 **示例 1：** 

```

输入：nums = [1,3,4,2,2]
输出：2

```
 **示例 2：** 

```

输入：nums = [3,1,3,4,2]
输出：3

```


 **提示：** 
-  `1 <= n <= 10^5` 
-  `nums.length == n + 1` 
-  `1 <= nums[i] <= n` 
-  `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次** 


<b>进阶：</b>
- 如何证明 `nums` 中至少存在一个重复的数字?
- 你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？

**标签**
`位运算` `数组` `双指针` `二分查找` 

##### solution 二分查找 

时间复杂度`O(nlogn)`空间复杂度`O(1)`

-   https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/

-   本质是使用二分在`[1,n]`中找到一个数
-   如果在`[1,mid]`之间有超过mid个数小于等于mid，则这个重复的数一定在`[1,mid] `

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        n = len(nums) - 1
        left, right = 1, n
        while left < right:
            mid = left + ((right - left) >> 1)
            cnt = 0
            for a in nums:
                cnt += a <= mid
            if cnt > mid:
                right = mid
            else:
                left = mid + 1
        return left
```



##### solution 链表快慢指针找环的入口

-   https://leetcode-cn.com/problems/find-the-duplicate-number/solution/287xun-zhao-zhong-fu-shu-by-kirsche/
-   索引和数之间建立映射，n -> nums[n]，形成链表
-   如果有重复数，那么多个索引会指向同一个数，形成链表中的环，环的入口就是重复的数

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow, fast = nums[0], nums[nums[0]]
        while slow != fast:
            slow = nums[slow]
            fast = nums[nums[fast]]
        
        cur = 0
        while slow != cur:
            slow = nums[slow]
            cur = nums[cur]
        return cur
```
>
## 2字符串
#### 8.字符串转换整数-atoi
[https://leetcode-cn.com/problems/string-to-integer-atoi](https://leetcode-cn.com/problems/string-to-integer-atoi) 
##### 原题
请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 `atoi` 函数）。

函数 `myAtoi(string s)` 的算法如下：
- 读入字符串并丢弃无用的前导空格
- 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
- 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
- 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 `0` 。必要时更改符号（从步骤 2 开始）。
- 如果整数数超过 32 位有符号整数范围 `[−2^31,  2^31 − 1]` ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 `−2^31` 的整数应该被固定为 `−2^31` ，大于 `2^31 − 1` 的整数应该被固定为 `2^31 − 1` 。
- 返回整数作为最终结果。
 **注意：** 
- 本题中的空白字符只包括空格字符 `' '` 。
- 除前导空格或数字后的其余字符串外， **请勿忽略** 任何其他字符。


 **示例 1：** 

```

输入：s = "42"
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
解析得到整数 42 。
由于 "42" 在范围 [-2^31, 2^31 - 1] 内，最终结果为 42 。
```
 **示例 2：** 

```

输入：s = "   -42"
输出：-42
解释：
第 1 步："   -42"（读入前导空格，但忽视掉）
            ^
第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   -42"（读入 "42"）
               ^
解析得到整数 -42 。
由于 "-42" 在范围 [-2^31, 2^31 - 1] 内，最终结果为 -42 。

```
 **示例 3：** 

```

输入：s = "4193 with words"
输出：4193
解释：
第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）
             ^
解析得到整数 4193 。
由于 "4193" 在范围 [-2^31, 2^31 - 1] 内，最终结果为 4193 。

```


 **提示：** 
-  `0 <= s.length <= 200` 
-  `s` 由英文字母（大写和小写）、数字（ `0-9` ）、 `' '` 、 `'+'` 、 `'-'` 和 `'.'` 组成

**标签**
`字符串` 


##### solution
```python
class Solution:
    def myAtoi(self, s: str) -> int:
        s = s.lstrip()
        if not s:
            return 0
        symbol = True
        if s[0] in ["+", "-"]:
            if s[0] == "-":
                symbol = False
            s = s[1:]
        
        i = 0
        res = 0
        while i < len(s) and s[i].isdigit():
            res = 10 * res + int(s[i])
            i += 1
        
        res = res if symbol else -res
        if res > 2**31-1:
            res = 2**31-1
        if res < -2**31:
            res = -2**31
        
        return res
```
>
#### 13.罗马数字转整数
[https://leetcode-cn.com/problems/roman-to-integer](https://leetcode-cn.com/problems/roman-to-integer) 
##### 原题
罗马数字包含以下七种字符: `I` ， `V` ， `X` ， `L` ， `C` ， `D` 和 `M` 。

```

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```
例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。 `12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII` , 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII` ，而是 `IV` 。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX` 。这个特殊的规则只适用于以下六种情况：
-  `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
-  `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
-  `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。

 

 **示例 1:** 

```

输入: s = "III"
输出: 3
```
 **示例 2:** 

```

输入: s = "IV"
输出: 4
```
 **示例 3:** 

```

输入: s = "IX"
输出: 9
```
 **示例 4:** 

```

输入: s = "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.

```
 **示例 5:** 

```

输入: s = "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```


 **提示：** 
-  `1 <= s.length <= 15` 
-  `s` 仅含字符 `('I', 'V', 'X', 'L', 'C', 'D', 'M')` 
- 题目数据保证 `s` 是一个有效的罗马数字，且表示整数在范围 `[1, 3999]` 内
- 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
- IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
- 关于罗马数字的详尽书写规则，可以参考 <a href="https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97#knowledge_article">罗马数字 - Mathematics </a>。

**标签**
`哈希表` `数学` `字符串` 


##### solution
```python
class Solution:
    def romanToInt(self, s: str) -> int:
        d = {'I':1,
            'V':5,
            'X':10,
            'L':50,
            'C':100,
            'D':500,
            'M':1000}
        res = 0
        for i, c in enumerate(s):
            if i > 0 and d[c] > d[s[i-1]]:
                res += d[c] - 2 * d[s[i-1]]
            else:
                res += d[c]
        return res
```
>
#### 14.最长公共前缀
[https://leetcode-cn.com/problems/longest-common-prefix](https://leetcode-cn.com/problems/longest-common-prefix) 
##### 原题
编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""` 。

 

 **示例 1：** 

```

输入：strs = ["flower","flow","flight"]
输出："fl"

```
 **示例 2：** 

```

输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```


 **提示：** 
-  `1 <= strs.length <= 200` 
-  `0 <= strs[i].length <= 200` 
-  `strs[i]` 仅由小写英文字母组成

**标签**
`字符串` 


##### solution
```python
# cur solution

class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        res = ""
        for i, c in enumerate(strs[0]):
            for s in strs:
                if i >= len(s):
                    return res
                if s[i] != c:
                    return res
            res += c
        return res

# 这是两年前刷题时候写的 哈哈哈

class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ''
        i, j, id = 0, 0, 0
        while j < len(strs) and i < len(strs[j]):
            if j == 0:
                char = strs[j][i]
            else:
                if char != strs[j][i]:
                    break
            if j == len(strs)-1:
                i += 1
                j = 0
                id += 1
            else:
                j += 1
        return strs[0][:id]
```
>
#### 28.实现str-str
[https://leetcode-cn.com/problems/implement-strstr](https://leetcode-cn.com/problems/implement-strstr) 
##### 原题
实现 <a href="https://baike.baidu.com/item/strstr/811469" target="_blank">strStr()</a> 函数。

给你两个字符串  `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  `-1` **** 。

 

 **说明：** 

当  `needle`  是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当  `needle`  是空字符串时我们应当返回 0 。这与 C 语言的 <a href="https://baike.baidu.com/item/strstr/811469" target="_blank">strstr()</a> 以及 Java 的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)" target="_blank">indexOf()</a> 定义相符。

 

 **示例 1：** 

```

输入：haystack = "hello", needle = "ll"
输出：2

```
 **示例 2：** 

```

输入：haystack = "aaaaa", needle = "bba"
输出：-1

```
 **示例 3：** 

```

输入：haystack = "", needle = ""
输出：0

```


 **提示：** 
-  `0 <= haystack.length, needle.length <= 5 * 10^4` 
-  `haystack` 和 `needle` 仅由小写英文字符组成

**标签**
`双指针` `字符串` `字符串匹配` 


##### solution
```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if not needle:
            return 0

        m, n = len(haystack), len(needle)
        if m < n:
            return -1

        for i in range(m-n+1):
            if haystack[i: i+n] == needle:
                return i
        return -1
```
>
#### 38.报数
[https://leetcode-cn.com/problems/count-and-say](https://leetcode-cn.com/problems/count-and-say) 
##### 原题
给定一个正整数 `n` ，输出外观数列的第 `n` 项。

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

你可以将其视作是由递归公式定义的数字字符串序列：
-  `countAndSay(1) = "1"` 
-  `countAndSay(n)` 是对 `countAndSay(n-1)` 的描述，然后转换成另一个数字字符串。
前五项如下：

```

1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"

```
要 **描述** 一个数字字符串，首先要将字符串分割为 **最小** 数量的组，每个组都由连续的最多 **相同字符** 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。

例如，数字字符串 `"3322251"` 的描述如下图：
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h09kfgowupj20g504sjro.jpg" style="width: 581px; height: 172px;" />


 **示例 1：** 

```

输入：n = 1
输出："1"
解释：这是一个基本样例。

```
 **示例 2：** 

```

输入：n = 4
输出："1211"
解释：
countAndSay(1) = "1"
countAndSay(2) = 读 "1" = 一 个 1 = "11"
countAndSay(3) = 读 "11" = 二 个 1 = "21"
countAndSay(4) = 读 "21" = 一 个 2 + 一 个 1 = "12" + "11" = "1211"

```


 **提示：** 
-  `1 <= n <= 30` 

**标签**
`字符串` 


##### solution
```python
class Solution:
    def countAndSay(self, n: int) -> str:
        cur_string = "1"
        for _ in range(1, n):
            next_string = ""
            c, cnt = cur_string[0], 1
            for i in range(1, len(cur_string)):
                if cur_string[i] == c:
                    cnt += 1
                else:
                    next_string += str(cnt) + c
                    c, cnt = cur_string[i], 1
            next_string += str(cnt) + c
            cur_string = next_string
        return cur_string
```
>
#### 43.字符串相乘
[https://leetcode-cn.com/problems/multiply-strings](https://leetcode-cn.com/problems/multiply-strings) 
##### 原题
给定两个以字符串形式表示的非负整数 `num1` 和 `num2` ，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

 **注意：** 不能使用任何内置的 BigInteger 库或直接将输入转换为整数。

 

 **示例 1:** 

```

输入: num1 = "2", num2 = "3"
输出: "6"
```
 **示例 2:** 

```

输入: num1 = "123", num2 = "456"
输出: "56088"
```


 **提示：** 
-  `1 <= num1.length, num2.length <= 200` 
-  `num1` 和 `num2` 只能由数字组成。
-  `num1` 和 `num2` 都不包含任何前导零，除了数字0本身。

**标签**
`数学` `字符串` `模拟` 

##### solution

以`289 * 785`为例

![image](https://tva1.sinaimg.cn/large/e6c9d24egy1h09n4i6ywlj20c5063jrr.jpg)

```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        num1, num2 = num1[::-1], num2[::-1]
        l1, l2 = len(num1), len(num2)
        res = [0] * (l1 + l2)
        for i in range(l1):
            for j in range(l2):
                res[i+j] += int(num1[i]) * int(num2[j])
        
        ans = ""
        for i in range(l1 + l2):
            if i < len(res) - 1:
                res[i+1] += res[i] // 10
            ans += str(res[i])[-1]
        while len(ans) > 1 and ans[-1] == "0":
            ans = ans[:-1]
        return ans[::-1]
```
>
#### 49.字母异位词分组
[https://leetcode-cn.com/problems/group-anagrams](https://leetcode-cn.com/problems/group-anagrams) 
##### 原题
给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

 **字母异位词** 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

 

 **示例 1:** 

```

输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```
 **示例 2:** 

```

输入: strs = [""]
输出: [[""]]

```
 **示例 3:** 

```

输入: strs = ["a"]
输出: [["a"]]
```


 **提示：** 
-  `1 <= strs.length <= 10^4` 
-  `0 <= strs[i].length <= 100` 
-  `strs[i]` 仅包含小写字母

**标签**
`哈希表` `字符串` `排序` 

##### solution1 使用26个字母的组合作为哈希值

-   可哈希的数据类型，即不可变的数据结构(数字类型（int，float，bool）字符串str、元组tuple、自定义类的对象)。
-   不可哈希的数据类型，即可变的数据结构 (字典dict，列表list，集合set)
-   详见https://blog.csdn.net/qq_27825451/article/details/102822506

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        from collections import defaultdict
        res = defaultdict(list)
        for s in strs:
            d = [0] * 26
            for c in s:
                d[ord(c) - ord('a')] += 1
            # 也可以使用 res[tuple(count)].append(s)
            
            res[",".join([str(a) for a in d])].append(s)
        return list(res.values())
```

##### Solution2 使用字母排列的最小序作为每个字符串的哈希值

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        from collections import defaultdict
        res = defaultdict(list)
        for s in strs:
            d = ''.join(sorted(s))
            res[d].append(s)
        return list(res.values())
```

>
#### 76.最小覆盖子串
[https://leetcode-cn.com/problems/minimum-window-substring](https://leetcode-cn.com/problems/minimum-window-substring) 
##### 原题
给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

 

 **注意：** 
- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。


 **示例 1：** 

```

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"

```
 **示例 2：** 

```

输入：s = "a", t = "a"
输出："a"

```
 **示例 3:** 

```

输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```


 **提示：** 
-  `1 <= s.length, t.length <= 10^5` 
-  `s` 和 `t` 由英文字母组成

 **进阶：** 你能设计一个在 `o(n)` 时间内解决此问题的算法吗？

**标签**
`哈希表` `字符串` `滑动窗口` 


##### solution
```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        from collections import Counter
        t_dict = Counter(t)

        left, right = 0, 0
        d = {}
        need_keys = len(t_dict)
        ans = (None, None, float("inf"))
        while right < len(s):
            c = s[right]
            d[c] = d.get(c, 0) + 1
            if c in t_dict and d[c] == t_dict[c]:
                need_keys -= 1
            while left <= right and need_keys == 0:
                if ans[-1] > right - left + 1:
                    ans = (left, right, right - left + 1)
                d[s[left]] -= 1
                if s[left] in t_dict and d[s[left]] < t_dict[s[left]]:
                    need_keys += 1
                left += 1            
            right += 1
        return s[ans[0]: ans[1]+1] if ans[2] != float("inf") else ""
```
>
#### 125.验证回文串
[https://leetcode-cn.com/problems/valid-palindrome](https://leetcode-cn.com/problems/valid-palindrome) 
##### 原题
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

 **说明：** 本题中，我们将空字符串定义为有效的回文串。

 

 **示例 1:** 

```

输入: "A man, a plan, a canal: Panama"
输出: true
解释："amanaplanacanalpanama" 是回文串

```
 **示例 2:** 

```

输入: "race a car"
输出: false
解释："raceacar" 不是回文串

```


 **提示：** 
-  `1 <= s.length <= 2 * 10^5` 
- 字符串 `s` 由 ASCII 字符组成

**标签**
`双指针` `字符串` 


##### solution
```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        res = []
        for c in s:
            if c.isalnum():
                res.append(c.lower())
        return res == res[::-1]
```
>
#### 151.翻转字符串里的单词
[https://leetcode-cn.com/problems/reverse-words-in-a-string](https://leetcode-cn.com/problems/reverse-words-in-a-string) 
##### 原题
给你一个字符串 `s` ，逐个翻转字符串中的所有 **单词** 。

 **单词** 是由非空格字符组成的字符串。 `s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

请你返回一个翻转 `s` 中单词顺序并用单个空格相连的字符串。

 **说明：** 
- 输入字符串 `s` 可以在前面、后面或者单词间包含多余的空格。
- 翻转后单词间应当仅用一个空格分隔。
- 翻转后的字符串中不应包含额外的空格。


 **示例 1：** 

```

输入：s = "the sky is blue"
输出："blue is sky the"

```
 **示例 2：** 

```

输入：s = "  hello world  "
输出："world hello"
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。

```
 **示例 3：** 

```

输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，将翻转后单词间的空格减少到只含一个。

```
 **示例 4：** 

```

输入：s = "  Bob    Loves  Alice   "
输出："Alice Loves Bob"

```
 **示例 5：** 

```

输入：s = "Alice does not even like bob"
输出："bob like even not does Alice"

```


 **提示：** 
-  `1 <= s.length <= 10^4` 
-  `s` 包含英文大小写字母、数字和空格 `' '` 
-  `s` 中 **至少存在一个** 单词


 **进阶：** 
- 请尝试使用  ` *O* (1)` 额外空间复杂度的原地解法。

**标签**
`双指针` `字符串` 

##### solution1 使用库函数

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        s = s.strip()
        res = []
        for c in s.split(" "):
            if not c:
                continue
            res.append(c)
        return " ".join(res[::-1])
```



##### solution2 纯手动

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        res =[]
        cur = []
        for c in s.strip():
            if c == " ":
                if cur:
                    res.append("".join(cur))
                cur = []
            else:
                cur.append(c)
        if cur:
            res.append("".join(cur))
        return " ".join(res[::-1])
```
>
#### 242.有效的字母异位词
[https://leetcode-cn.com/problems/valid-anagram](https://leetcode-cn.com/problems/valid-anagram) 
##### 原题
给定两个字符串 ` *s* ` 和 ` *t* ` ，编写一个函数来判断 ` *t* ` 是否是 ` *s* ` 的字母异位词。

 **注意：** 若  ` *s* ` 和 ` *t* ` * * 中每个字符出现的次数都相同，则称  ` *s* ` 和 ` *t* ` * * 互为字母异位词。

 

 **示例 1:** 

```

输入: s = "anagram", t = "nagaram"
输出: true

```
 **示例 2:** 

```

输入: s = "rat", t = "car"
输出: false
```


 **提示:** 
-  `1 <= s.length, t.length <= 5 * 10^4` 
-  `s` 和 `t`  仅包含小写字母


 **进阶: ** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？


**标签**
`哈希表` `字符串` `排序` 

##### solution

-   如果s和t长度不等，必然不是字母异位词
-   如果长度相等，只需要判断s的每个字符都在t中，且频率相等。如果存在一个t中的字符不在s中，在其他字符都相同且频率相等的情况下，必然也存在一个s中的字符不在t中。因此只需要单向判断就可以了。

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        from collections import Counter
        s_dict = Counter(s)
        t_dict = Counter(t)
        for c, cnt in s_dict.items():
            if c not in t_dict or cnt != t_dict[c]:
                return False
        return True
```
>
#### 344.反转字符串
[https://leetcode-cn.com/problems/reverse-string](https://leetcode-cn.com/problems/reverse-string) 
##### 原题
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须 **<a href="https://baike.baidu.com/item/原地算法" target="_blank">原地</a>修改输入数组** 、使用 O(1) 的额外空间解决这一问题。

 

 **示例 1：** 

```

输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]

```
 **示例 2：** 

```

输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```


 **提示：** 
-  `1 <= s.length <= 10^5` 
-  `s[i]` 都是 <a href="https://baike.baidu.com/item/ASCII" target="_blank">ASCII</a> 码表中的可打印字符

**标签**
`递归` `双指针` `字符串` 


##### solution
```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        l = len(s)
        for i in range(l // 2):
            s[i], s[l-1-i] = s[l-1-i], s[i]
```
>
#### 387.字符串中的第一个唯一字符
[https://leetcode-cn.com/problems/first-unique-character-in-a-string](https://leetcode-cn.com/problems/first-unique-character-in-a-string) 
##### 原题
给定一个字符串 `s` ，找到 *它的第一个不重复的字符，并返回它的索引* 。如果不存在，则返回 `-1` 。

 

 **示例 1：** 

```

输入: s = "leetcode"
输出: 0

```
 **示例 2:** 

```

输入: s = "loveleetcode"
输出: 2

```
 **示例 3:** 

```

输入: s = "aabb"
输出: -1

```


 **提示:** 
-  `1 <= s.length <= 10^5` 
-  `s` 只包含小写字母

**标签**
`队列` `哈希表` `字符串` `计数` 


##### solution
```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        from collections import Counter
        d = Counter(s)
        for i, c in enumerate(s):
            if d[c] == 1:
                return i
        return -1
```
>
#### 415.字符串相加
[https://leetcode-cn.com/problems/add-strings](https://leetcode-cn.com/problems/add-strings) 
##### 原题
给定两个字符串形式的非负整数 `num1` 和 `num2` ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 `BigInteger` ）， 也不能直接将输入的字符串转换为整数形式。

 

 **示例 1：** 

```

输入：num1 = "11", num2 = "123"
输出："134"

```
 **示例 2：** 

```

输入：num1 = "456", num2 = "77"
输出："533"

```
 **示例 3：** 

```

输入：num1 = "0", num2 = "0"
输出："0"

```




 **提示：** 
-  `1 <= num1.length, num2.length <= 10^4` 
-  `num1` 和 `num2` 都只包含数字 `0-9` 
-  `num1` 和 `num2` 都不包含任何前导零

**标签**
`数学` `字符串` `模拟` 


##### solution1 将num1补0到和num2位数相同
```python
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        res = ''
        num1, num2 = num1[::-1], num2[::-1]
        l = max(len(num1), len(num2))
        if len(num1) < l:
            num1 += '0' * (l-len(num1))
        else:
            num2 += '0' * (l-len(num2))
        c = 0
        for i in range(l):
            n = int(num1[i]) + int(num2[i]) + c
            res += str(n)[-1]
            c = n // 10
        if c != 0:
            res += str(c)
        return res[::-1]
```
##### solution2 不补0，先计算num1+num2[:len(num1)]+carry，再计算carry+num2[len(num1):]

```python
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        num1, num2 = num1[::-1], num2[::-1]
        if len(num1) > len(num2):
            num1, num2 = num2, num1
        l1, l2 = len(num1), len(num2)
        res = ""
        carry = 0
        for i in range(l1):
            cur = int(num1[i]) + int(num2[i]) + carry
            res += str(cur % 10)
            carry = cur // 10
        if l2 == l1:
            res += str(carry)
        else:
            for i in range(l1, l2):
                cur = int(num2[i]) + carry
                res += str(cur % 10)
                carry = cur // 10
            res += str(carry)
        while len(res) > 1 and res[-1] == "0":
            res = res[:-1]
        return res[::-1]
```

##### solution3 不补0，优雅写法

```python
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        num1, num2 = num1[::-1], num2[::-1]
        if len(num1) > len(num2):
            num1, num2 = num2, num1
        l1, l2 = len(num1), len(num2)
        res = ""
        carry = 0
        i, j = 0, 0
        while i < l1 or j < l2 or carry:
            x = int(num1[i]) if i < l1 else 0
            y = int(num2[j]) if j < l2 else 0
            cur = x + y + carry
            res += str(cur % 10)
            carry = cur // 10
            i += 1
            j += 1
        return res[::-1]
```

>   

#### 438.找到字符串中所有字母异位词
[https://leetcode-cn.com/problems/find-all-anagrams-in-a-string](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string) 
##### 原题
给定两个字符串 `s` 和 `p` ，找到 `s` **** 中所有 `p` **** 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

 **异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

 

 **示例 1:** 

```

输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。

```
 **示例 2:** 

```

输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。

```


 **提示:** 
-  `1 <= s.length, p.length <= 3 * 10^4` 
-  `s` 和 `p` 仅包含小写字母

**标签**
`哈希表` `字符串` `滑动窗口` 

##### solution1 使用26个字母的计数列表，贼快

```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        p_dict = [0] * 26
        for c in p:
            p_dict[ord(c) - ord('a')] += 1

        res = []
        ls, lp = len(s), len(p)
        d = [0] * 26
        for c in s[:lp]:
            d[ord(c) - ord('a')] += 1
        if d == p_dict:
            res.append(0)
        
        for i in range(1, ls - lp + 1):
            d[ord(s[i-1]) - ord('a')] -= 1
            d[ord(s[i+lp-1]) - ord('a')] += 1
            if d == p_dict:
                res.append(i)
        return res
```



##### solution2 使用字典，有点慢

```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        from collections import Counter
        p_dict = Counter(p)

        res = []
        ls, lp = len(s), len(p)
        d = Counter(s[:lp])
        if d == p_dict:
            res.append(0)
        for i in range(1, ls - lp + 1):
            d[s[i-1]] -= 1
            if d[s[i-1]] == 0:
                del d[s[i-1]]
            d[s[i+lp-1]] = d.get(s[i+lp-1], 0) + 1
            if d == p_dict:
                res.append(i)
        return res
```



##### solution3 计算i~i+lp-1区间改为计算i-lp+1~i区间

-   计算i~i+lp-1区间，在开头需要先计算出一个计数列表/字典出来，而计算i-lp+1~i区间不需要

```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        lp = len(p)
        dict_p = {}
        for c in p:
            dict_p[c] = dict_p.get(c, 0) + 1
        dict_window = {}
        res = []
        for i, c in enumerate(s):
            dict_window[c] = dict_window.get(c, 0) + 1
            if i >= lp:
                dict_window[s[i-lp]] -= 1
                if dict_window[s[i-lp]] == 0:
                    del dict_window[s[i-lp]]
            if dict_window == dict_p:
                res.append(i-lp+1)
        return res
```
>
#### 557.反转字符串中的单词-iii
[https://leetcode-cn.com/problems/reverse-words-in-a-string-iii](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii) 
##### 原题
给定一个字符串<meta charset="UTF-8" /> `s` ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

 

 **示例 1：** 

```

输入：s = "Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"

```
 **示例 2:** 

```

输入： s = "God Ding"
输出："doG gniD"

```


 ** ** ** **提示：** ** ** ** 
-  `1 <= s.length <= 5 * 10^4` 
- <meta charset="UTF-8" /> `s` 包含可打印的 **ASCII** 字符。
- <meta charset="UTF-8" /> `s` 不包含任何开头或结尾空格。
- <meta charset="UTF-8" /> `s` 里 **至少** 有一个词。
- <meta charset="UTF-8" /> `s` 中的所有单词都用一个空格隔开。

**标签**
`双指针` `字符串` 

##### solution1库函数

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        return " ".join([c[::-1] for c in s.split(" ")])
```

##### solution2 手动

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        res = []
        cur = ""
        for c in s:
            if c != " ":
                cur += c
            else:
                if cur:
                    res.append(cur[::-1])
                    cur = ""
        if cur:
            res.append(cur[::-1])
        return " ".join(res)
```
>
#### 567.字符串的排列
[https://leetcode-cn.com/problems/permutation-in-string](https://leetcode-cn.com/problems/permutation-in-string) 
##### 原题
给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` **** 的排列。如果是，返回 `true` ；否则，返回 `false` 。

换句话说， `s1` 的排列之一是 `s2` 的 **子串** 。

 

 **示例 1：** 

```

输入：s1 = "ab" s2 = "eidbaooo"
输出：true
解释：s2 包含 s1 的排列之一 ("ba").

```
 **示例 2：** 

```

输入：s1= "ab" s2 = "eidboaoo"
输出：false

```


 **提示：** 
-  `1 <= s1.length, s2.length <= 10^4` 
-  `s1` 和 `s2` 仅包含小写字母

**标签**
`哈希表` `双指针` `字符串` `滑动窗口` 

##### solution

-   和438同样的做法

```python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        s1_dict = [0] * 26
        for c in s1:
            s1_dict[ord(c) - ord('a')] += 1
        
        l1, l2 = len(s1), len(s2)
        window = [0] * 26
        for c in s2[:l1]:
            window[ord(c) - ord('a')] += 1
        if window == s1_dict:
            return True
        
        for i in range(1, l2-l1+1):
            window[ord(s2[i-1]) - ord('a')] -= 1
            window[ord(s2[i+l1-1]) - ord('a')] += 1
            if window == s1_dict:
                return True
        return False
```
>
#### 657.机器人能否返回原点
[https://leetcode-cn.com/problems/robot-return-to-origin](https://leetcode-cn.com/problems/robot-return-to-origin) 
##### 原题
在二维平面上，有一个机器人从原点 `(0, 0)` 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 ** `(0, 0)` 处结束** 。

移动顺序由字符串 `moves` 表示。字符 `move[i]` 表示其第 `i` 次移动。机器人的有效动作有 `R` （右）， `L` （左）， `U` （上）和 `D` （下）。

如果机器人在完成所有动作后返回原点，则返回 `true` 。否则，返回 `false` 。

 **注意：** 机器人“面朝”的方向无关紧要。 `“R”` 将始终使机器人向右移动一次， `“L”` 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。

 

 **示例 1:** 

```

输入: moves = "UD"
输出: true
解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。
```
 **示例 2:** 

```

输入: moves = "LL"
输出: false
解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。
```


 **提示:** 
-  `1 <= moves.length <= 2 * 10^4` 
-  `moves` 只包含字符 `'U'` , `'D'` , `'L'` 和 `'R'` 

**标签**
`字符串` `模拟` 


##### solution
```python
class Solution:
    def judgeCircle(self, moves: str) -> bool:
        return moves.count("L") == moves.count("R") and moves.count("U") == moves.count("D")
```
>
## 3链表
#### 2.两数相加
[https://leetcode-cn.com/problems/add-two-numbers](https://leetcode-cn.com/problems/add-two-numbers) 
##### 原题
给你两个  **非空** 的链表，表示两个非负的整数。它们每位数字都是按照  **逆序**  的方式存储的，并且每个节点只能存储  **一位**  数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

 **示例 1：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0auw4t2cxj20df09i74g.jpg" style="width: 483px; height: 342px;" />

```

输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.

```
 **示例 2：** 

```

输入：l1 = [0], l2 = [0]
输出：[0]

```
 **示例 3：** 

```

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]

```


 **提示：** 
- 每个链表中的节点数在范围 `[1, 100]` 内
-  `0 <= Node.val <= 9` 
- 题目数据保证列表表示的数字不含前导零

**标签**
`递归` `链表` `数学` 

##### solution1 迭代

```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(-1)
        res = dummy
        carry = None
        while l1 or l2 or carry:
            val1 = l1.val if l1 else 0
            val2 = l2.val if l2 else 0
            cval = carry.val if carry else 0
            cur_val = val1 + val2 + cval
            carry = None if cur_val < 10 else ListNode(1)
            res.next = ListNode(cur_val % 10)
            res = res.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        return dummy.next
```




##### solution2 递归
```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1:
            return l2
        if not l2:
            return l1
        cur_val = l1.val + l2.val
        if cur_val < 10:
            l3 = ListNode(cur_val)
            l3.next = self.addTwoNumbers(l1.next, l2.next)
        else:
            l3 = ListNode(cur_val - 10)
            carry = ListNode(1)
            l3.next = self.addTwoNumbers(self.addTwoNumbers(l1.next, carry), l2.next)
        return l3
```
>
#### 19.删除链表的倒数第n个节点
[https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list) 
##### 原题
给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" style="width: 542px; height: 222px;" />
```

输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]

```
 **示例 2：** 

```

输入：head = [1], n = 1
输出：[]

```
 **示例 3：** 

```

输入：head = [1,2], n = 1
输出：[1]

```


 **提示：** 
- 链表中结点的数目为 `sz` 
-  `1 <= sz <= 30` 
-  `0 <= Node.val <= 100` 
-  `1 <= n <= sz` 


 **进阶：** 你能尝试使用一趟扫描实现吗？


**标签**
`链表` `双指针` 

##### solution

- 删除倒数第n个节点，需要找到倒数第n+1个节点p，然后通过 `p.next = p.next.next`就可以删掉倒数第n个节点 `p.next`了。
- 寻找倒数第n+1个节点p的方法——快慢指针，以 `1->2->3->4->5`，n=2为例
    - 第一步，定义一个dummy节点指向head，即 `0->1->2->3->4->5`
    - 第二步，找到正数第n个节点，从0出发，向右跑n步，定义为fast节点，即2
    - 第三步，slow节点从0出发，fast节点从第n个节点(即2)出发，一起向右跑。fast节点右边还有length-n(5-2=3)个节点，那么当fast节点跑到最后一个节点5时，slow节点从0往右跑了length-n步，正数length-n个节点就是倒数第n+1个节点
    - 注意dummy节点不计入正数和倒数的索引中

```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        dummy = ListNode(0, head)
        fast = dummy
        for _ in range(n):
            fast = fast.next
        slow = dummy
        while fast.next:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return dummy.next
```
>
#### 21.合并两个有序链表
[https://leetcode-cn.com/problems/merge-two-sorted-lists](https://leetcode-cn.com/problems/merge-two-sorted-lists) 
##### 原题
将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" style="width: 662px; height: 302px;" />
```

输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

```
 **示例 2：** 

```

输入：l1 = [], l2 = []
输出：[]

```
 **示例 3：** 

```

输入：l1 = [], l2 = [0]
输出：[0]

```


 **提示：** 
- 两个链表的节点数目范围是 `[0, 50]` 
-  `-100 <= Node.val <= 100` 
-  `l1` 和 `l2` 均按 **非递减顺序** 排列

**标签**
`递归` `链表` 

##### solution1 迭代

```python
class Solution:
    def mergeTwoLists2(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(-1)
        res = dummy
        while l1 and l2:
            if l1.val < l2.val:
                res.next = l1
                l1 = l1.next
            else:
                res.next = l2
                l2 = l2.next
            res = res.next
        if l1:
            res.next = l1
        if l2:
            res.next = l2
        return dummy.next
```




##### solution2 递归
```python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1:
            return l2
        if not l2:
            return l1
        if l1.val < l2.val:
            l3 = ListNode(l1.val)
            l3.next = self.mergeTwoLists(l1.next, l2)
        else:
            l3 = ListNode(l2.val)
            l3.next = self.mergeTwoLists(l1, l2.next)
        return l3
```
>
#### 25.k-个一组翻转链表
[https://leetcode-cn.com/problems/reverse-nodes-in-k-group](https://leetcode-cn.com/problems/reverse-nodes-in-k-group) 
##### 原题
给你一个链表，每  *k * 个节点一组进行翻转，请你返回翻转后的链表。

 *k * 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是  *k * 的整数倍，那么请将最后剩余的节点保持原有顺序。

 **进阶：** 
- 你可以设计一个只使用常数额外空间的算法来解决此问题吗？
-  **你不能只是单纯的改变节点内部的值** ，而是需要实际进行节点交换。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" style="width: 542px; height: 222px;" />
```

输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" style="width: 542px; height: 222px;" />
```

输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]

```
 **示例 3：** 

```

输入：head = [1,2,3,4,5], k = 1
输出：[1,2,3,4,5]

```
 **示例 4：** 

```

输入：head = [1], k = 1
输出：[1]

```
 **提示：** 
- 列表中节点的数量在范围 `sz` 内
-  `1 <= sz <= 5000` 
-  `0 <= Node.val <= 1000` 
-  `1 <= k <= sz` 

**标签**
`递归` `链表` 

##### solution

- 设置dummy节点
- 关键在于反转前先确认好 上一段的end和本段的start链接，本段的end和下一段的start链接

![avatar](https://tva1.sinaimg.cn/large/e6c9d24egy1h0bmz0bcxvj20u01e8wh9.jpg)

```python
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        if not head or not k:
            return head
        length = 0
        p = head
        while p:
            p = p.next
            length += 1
        loops = length // k
        dummy = ListNode(-1)
        dummy.next = head
        pre, p = None, head
        last_end, cur_end = dummy, head
        for _ in range(loops):
            pre = None
            for _ in range(k):
                tmp = p.next
                p.next = pre
                pre = p
                p = tmp
            # after reverse cur part, pre is cur_start, p is next_end
            # last_end.next = cur_start
            last_end.next = pre
            # cur_end.next = next_end
            cur_end.next = p
            last_end, cur_end = cur_end, p
        return dummy.next
```
>
#### 61.旋转链表
[https://leetcode-cn.com/problems/rotate-list](https://leetcode-cn.com/problems/rotate-list) 
##### 原题
给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动  `k` * * 个位置。

 

 **示例 1：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0bn244c8oj20js08et95.jpg" style="width: 600px; height: 254px;" />

```

输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]

```
 **示例 2：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0bn26wk8aj20d40f20t9.jpg" style="width: 472px; height: 542px;" />

```

输入：head = [0,1,2], k = 4
输出：[2,0,1]

```


 **提示：** 
- 链表中节点的数目在范围 `[0, 500]` 内
-  `-100 <= Node.val <= 100` 
-  `0 <= k <= 2 * 10^9` 

**标签**
`链表` `双指针` 


##### solution
```python
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if not head or k == 0:
            return head
        
        cnt = 1
        p = head
        while p.next:
            p = p.next
            cnt += 1
        p.next = head

        move = cnt - k % cnt
        for _ in range(move):
            p = p.next
        new_head = p.next
        p.next = None
        return new_head
```
>
#### 82.删除排序链表中的重复元素-ii
[https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii) 
##### 原题
给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

 

 **示例 1：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0bn84utswj20lq06674g.jpg" style="height: 142px; width: 500px;" />

```

输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]

```
 **示例 2：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0bn87495qj20f2066jrf.jpg" style="height: 164px; width: 400px;" />

```

输入：head = [1,1,1,2,3]
输出：[2,3]

```


 **提示：** 
- 链表中节点数目在范围 `[0, 300]` 内
-  `-100 <= Node.val <= 100` 
- 题目数据保证链表已经按升序 **排列** 

**标签**
`链表` `双指针` 


##### solution
```python
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        dummy = ListNode(-1)
        dummy.next = head
        pre, cur = dummy, head
        while (cur and cur.next):
            if(cur.val == cur.next.val):
                while(cur and cur.next and cur.val == cur.next.val):
                    cur = cur.next
                pre.next = cur.next
            else:
                pre.next = cur
                pre = pre.next
            cur = cur.next
        return dummy.next
```
>
#### 83.删除排序链表中的重复元素
[https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list) 
##### 原题
给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

 

 **示例 1：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d64ompx3j208e06qaa0.jpg" style="height: 160px; width: 200px;" />

```

输入：head = [1,1,2]
输出：[1,2]

```
 **示例 2：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d64iofexj20f2066q30.jpg" style="height: 123px; width: 300px;" />

```

输入：head = [1,1,2,3,3]
输出：[1,2,3]

```


 **提示：** 
- 链表中节点数目在范围 `[0, 300]` 内
-  `-100 <= Node.val <= 100` 
- 题目数据保证链表已经按升序 **排列** 

**标签**
`链表` 


##### solution
```python
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head:
            return None
        node = head
        while node:
            while node.next and node.val == node.next.val:
                node.next = node.next.next
            node = node.next
        return head
```
>
#### 92.反转链表-ii
[https://leetcode-cn.com/problems/reverse-linked-list-ii](https://leetcode-cn.com/problems/reverse-linked-list-ii) 
##### 原题
给你单链表的头指针 `head` 和两个整数  `left` 和 `right` ，其中  `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

 **示例 1：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d64fpz0ej20f2066dg0.jpg" style="width: 542px; height: 222px;" />

```

输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]

```
 **示例 2：** 

```

输入：head = [5], left = 1, right = 1
输出：[5]

```


 **提示：** 
- 链表中节点数目为 `n` 
-  `1 <= n <= 500` 
-  `-500 <= Node.val <= 500` 
-  `1 <= left <= right <= n` 


 **进阶：** 你可以使用一趟扫描完成反转吗？


**标签**
`链表` 


##### solution
```python
class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        if not head or not head.next or m == n:
            return head
        dummy = ListNode(-1)
        dummy.next = head
        pre, p = dummy, head
        for _ in range(m-1):
            pre = p
            p = p.next
        start, end = pre, p
        pre = None
        for _ in range(n-m+1):
            tmp = p.next
            p.next = pre
            pre = p
            p = tmp
        start.next = pre
        end.next = p
        return dummy.next
```
>
#### 138.复制带随机指针的链表
[https://leetcode-cn.com/problems/copy-list-with-random-pointer](https://leetcode-cn.com/problems/copy-list-with-random-pointer) 
##### 原题
给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **<a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin" target="_blank">深拷贝</a>** 。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。 **复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：
-  `val` ：一个表示 `Node.val` 的整数。
-  `random_index` ：随机指针指向的节点索引（范围从 `0` 到 `n-1` ）；如果不指向任何节点，则为 `null` 。
你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

 

 **示例 1：** 

<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d639fsazj21gs0aq400.jpg" style="height: 142px; width: 700px;" />

```

输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]

```
 **示例 2：** 

<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d63gnz4uj21ae07kt95.jpg" style="height: 114px; width: 700px;" />

```

输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]

```
 **示例 3：** 

 **<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d63leklrj21gi096my0.jpg" style="height: 122px; width: 700px;" />** 

```

输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]

```


 **提示：** 
-  `0 <= n <= 1000` <meta charset="UTF-8" />
-  `-10^4 <= Node.val <= 10^4` 
-  `Node.random` 为 `null` 或指向链表中的节点。

**标签**
`哈希表` `链表` 


##### solution
```python
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random

class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head:
            return None

        p = head
        while p:
            tmp = Node(p.val, p.next, None)
            p.next = tmp
            p = tmp.next
        p = head
        while p:
            if p.random:
                p.next.random = p.random.next
            p = p.next.next
        head2 = head.next
        p1, p2 = head, head2
        while p2 and p2.next:
            p1.next = p2.next
            p1 = p1.next
            p2.next = p1.next
            p2 = p2.next
        return head2
```
>
#### 141.环形链表
[https://leetcode-cn.com/problems/linked-list-cycle](https://leetcode-cn.com/problems/linked-list-cycle) 
##### 原题
给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 **注意： `pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

 *如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

 

 **示例 1：** 

<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d654mp4cj20er04r3yi.jpg" />

```

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

```
 **示例 2：** 

<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d657cz5sj205l02xt8j.jpg" />

```

输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。

```
 **示例 3：** 

<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d659sq0ej201t01tdfl.jpg" />

```

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。

```


 **提示：** 
- 链表中节点的数目范围是 `[0, 10^4]` 
-  `-10^5 <= Node.val <= 10^5` 
-  `pos` 为 `-1` 或者链表中的一个 **有效索引** 。


 **进阶：** 你能用 `O(1)` （即，常量）内存解决此问题吗？


**标签**
`哈希表` `链表` `双指针` 


##### solution
```python
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if not head:
            return None
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False
```
>
#### 142.环形链表2
[https://leetcode-cn.com/problems/linked-list-cycle-ii](https://leetcode-cn.com/problems/linked-list-cycle-ii) 
##### 原题
给定一个链表的头节点 `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null` 。* 

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（ **索引从 0 开始** ）。如果 `pos` 是 `-1` ，则在该链表中没有环。 **注意： `pos` 不作为参数进行传递** ，仅仅是为了标识链表的实际情况。

 **不允许修改** 链表。


 **示例 1：** 

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d65eica4j20er04r3yi.jpg" />

```

输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。

```
 **示例 2：** 

<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d65i8pa8j205l02xt8j.jpg" />

```

输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。

```
 **示例 3：** 

<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d65jkur2j201t01tdfl.jpg" />

```

输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。

```


 **提示：** 
- 链表中节点的数目范围在范围 `[0, 10^4]` 内
-  `-10^5 <= Node.val <= 10^5` 
-  `pos` 的值为 `-1` 或者链表中的一个有效索引


 **进阶：** 你是否可以使用 `O(1)` 空间解决此题？


**标签**
`哈希表` `链表` `双指针` 


##### solution
```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head:
            return None
        def getMeetingNode(head):
            slow, fast = head, head
            while fast and fast.next:
                slow = slow.next
                fast = fast.next.next
                if slow == fast:
                    return slow
            return None
        meetingNode = getMeetingNode(head)
        if not meetingNode:
            return None
        p1, p2 = meetingNode, head
        while p1 != p2:
            p1 = p1.next
            p2 = p2.next
        return p1
```
>
#### 143.重排链表
[https://leetcode-cn.com/problems/reorder-list](https://leetcode-cn.com/problems/reorder-list) 
##### 原题
给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

```

L0 → L1 → … → Ln - 1 → Ln

```
请将其重新排列后变为：

```

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 

 **示例 1：** 

<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d65nvv8cj20bq0663yl.jpg" style="width: 240px; " />

```

输入：head = [1,2,3,4]
输出：[1,4,2,3]
```
 **示例 2：** 

<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d65sgntdj20f206674g.jpg" style="width: 320px; " />

```

输入：head = [1,2,3,4,5]
输出：[1,5,2,4,3]
```


 **提示：** 
- 链表的长度范围为 `[1, 5 * 10^4]` 
-  `1 <= node.val <= 1000` 

**标签**
`栈` `递归` `链表` `双指针` 


##### solution
```python
class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        p = head
        cnt = 0
        while p:
            p = p.next
            cnt += 1
        
        pre, p = None, head
        for i in range((cnt+1) // 2):
            pre = p;
            p = p.next
        pre.next = None
        right_head = p

        pre, p = None, right_head
        while p:
            tmp = p.next
            p.next = pre
            pre = p
            p = tmp
        right_reverse_head = pre

        left, right = head, right_reverse_head
        while right:
            tmp1, tmp2 = left.next, right.next
            left.next = right
            right.next = tmp1
            left = tmp1
            right = 
```
>
#### 160.相交链表
[https://leetcode-cn.com/problems/intersection-of-two-linked-lists](https://leetcode-cn.com/problems/intersection-of-two-linked-lists) 
##### 原题
给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交 **：** 



<a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" target="_blank"><img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d65zfrldj20km06pglu.jpg" style="height: 130px; width: 400px;" /></a>



题目数据 **保证** 整个链式结构中不存在环。

 **注意** ，函数返回结果后，链表必须 **保持其原始结构** 。

 **自定义评测：** 

 **评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：
-  `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0` 
-  `listA` - 第一个链表
-  `listB` - 第二个链表
-  `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
-  `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数
评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。

 

 **示例 1：** 



<a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" target="_blank"><img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d668h4ilj20km06p0sx.jpg" style="height: 130px; width: 400px;" /></a>

```

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

```
 **示例 2：** 



<a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" target="_blank"><img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d66b6ja1j20ha06pglp.jpg" style="height: 136px; width: 350px;" /></a>

```

输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

```
 **示例 3：** 



<a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" target="_blank"><img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d66hazp7j20am06pmx6.jpg" style="height: 126px; width: 200px;" /></a>

```

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。

```


 **提示：** 
-  `listA` 中节点数目为 `m` 
-  `listB` 中节点数目为 `n` 
-  `1 <= m, n <= 3 * 10^4` 
-  `1 <= Node.val <= 10^5` 
-  `0 <= skipA <= m` 
-  `0 <= skipB <= n` 
- 如果 `listA` 和 `listB` 没有交点， `intersectVal` 为 `0` 
- 如果 `listA` 和 `listB` 有交点， `intersectVal == listA[skipA] == listB[skipB]` 


 **进阶：** 你能否设计一个时间复杂度 `O(m + n)` 、仅用 `O(1)` 内存的解决方案？


**标签**
`哈希表` `链表` `双指针` 


##### solution
```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if not headA or not headB:
            return None
        p1, p2 = headA, headB
        while p1 != p2:
            p1 = p1.next if p1 else headB
            p2 = p2.next if p2 else headA
        return p1
```
>
#### 206.反转链表
[https://leetcode-cn.com/problems/reverse-linked-list](https://leetcode-cn.com/problems/reverse-linked-list) 
##### 原题
给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

 **示例 1：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d66llacfj20f2066q33.jpg" style="width: 542px; height: 222px;" />

```

输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]

```
 **示例 2：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d66mx9rgj2052066dfq.jpg" style="width: 182px; height: 222px;" />

```

输入：head = [1,2]
输出：[2,1]

```
 **示例 3：** 

```

输入：head = []
输出：[]

```


 **提示：** 
- 链表中节点的数目范围是 `[0, 5000]` 
-  `-5000 <= Node.val <= 5000` 


 **进阶：** 链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

**标签**
`递归` `链表` 


##### solution
```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        pre, p = None, head
        while p:
            tmp = p.next
            p.next = pre
            pre = p
            p = tmp
        return pre
```
>
#### 234.回文链表
[https://leetcode-cn.com/problems/palindrome-linked-list](https://leetcode-cn.com/problems/palindrome-linked-list) 
##### 原题
给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

 

 **示例 1：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d66r522sj20bq01qt8l.jpg" style="width: 422px; height: 62px;" />

```

输入：head = [1,2,2,1]
输出：true

```
 **示例 2：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d66twqj6j205201qwea.jpg" style="width: 182px; height: 62px;" />

```

输入：head = [1,2]
输出：false

```


 **提示：** 
- 链表中节点数目在范围 `[1, 10^5]` 内
-  `0 <= Node.val <= 9` 


 **进阶：** 你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？


**标签**
`栈` `递归` `链表` `双指针` 


##### solution
```python
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        if not head:
            return False
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        # slow表示中点
        
        # 1->2->3->4,slow对应3；1->2->3->4->5,slow对应3
        
        # 反转右边部分
        
        pre, cur = None, slow
        while cur:
            next = cur.next
            cur.next = pre
            pre = cur
            cur = next
        # 现在pre是右边链表经过反转的头节点
        
        while head and pre:
            if head.val != pre.val:
                return False
            head = head.next
            pre = pre.next
        return True

```
>
#### 328.奇偶链表
[https://leetcode-cn.com/problems/odd-even-linked-list](https://leetcode-cn.com/problems/odd-even-linked-list) 
##### 原题
给定单链表的头节点 `head` ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。

 **第一个** 节点的索引被认为是 **奇数** ， **第二个** 节点的索引为 **偶数** ，以此类推。

请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。

你必须在 `O(1)` 的额外空间复杂度和 `O(n)` 的时间复杂度下解决这个问题。

 

 **示例 1:** 

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d66x78h5j20f2066wen.jpg" style="height: 123px; width: 300px;" />

```

输入: head = [1,2,3,4,5]
输出: [1,3,5,2,4]
```
 **示例 2:** 

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0d66z2530j20lq066aae.jpg" style="height: 142px; width: 500px;" />

```

输入: head = [2,1,3,5,6,4,7]
输出: [2,3,6,7,1,5,4]
```


 **提示:** 
-  `n ==` 链表中的节点数
-  `0 <= n <= 10^4` 
-  `-10^6 <= Node.val <= 10^6` 

**标签**
`链表` 


##### solution
```python
class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        odd, even, even_head = head, head.next, head.next
        # 1->2->3->4->5时，even为空停止，此时形成了1->3->5->NULL和2->4->NULL
        
        # 1->2->3->4时，even不为空，even.next为空停止，此时形成了1->3->NULL和2->4->NULL
        
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        odd.next = even_head
        return head
```
>
## 4栈和队列
### 队列
#### 239.滑动窗口最大值
[https://leetcode-cn.com/problems/sliding-window-maximum](https://leetcode-cn.com/problems/sliding-window-maximum) 
###### 原题
给你一个整数数组 `nums` ，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

 

 **示例 1：** 

```

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

```
 **示例 2：** 

```

输入：nums = [1], k = 1
输出：[1]

```


<b>提示：</b>
-  `1 <= nums.length <= 10^5` 
-  `-10^4 <= nums[i] <= 10^4` 
-  `1 <= k <= nums.length` 

**标签**
`队列` `数组` `滑动窗口` `单调队列` `堆（优先队列）` 

##### solution

-   使用双端单调队列`q`存放最大值，`q`中的元素是严格单调递减的
-   考虑当前窗口的两个元素`i`和`j`，如果`i < j`，并且`nums[i] <= nums[j]`，那么不需要再保留`nums[i]`
-   注意需要保证`q`的首元素在当前窗口内

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        from collections import deque
        q = deque()
        for i in range(k):
            while q and nums[i] >= nums[q[-1]]:
                q.pop()
            q.append(i)
        res = [nums[q[0]]]
        
        n = len(nums)
        for i in range(k, n):
            while q and nums[i] >= nums[q[-1]]:
                q.pop()
            q.append(i)
            while q and q[0] <= i-k:
                q.popleft()
            res.append(nums[q[0]])
        return res
```
>
#### 622.design-circular-queue
[https://leetcode-cn.com/problems/design-circular-queue](https://leetcode-cn.com/problems/design-circular-queue) 

###### 原题
设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。

你的实现应该支持如下操作：
-  `MyCircularQueue(k)` : 构造器，设置队列长度为 k 。
-  `Front` : 从队首获取元素。如果队列为空，返回 -1 。
-  `Rear` : 获取队尾元素。如果队列为空，返回 -1 。
-  `enQueue(value)` : 向循环队列插入一个元素。如果成功插入则返回真。
-  `deQueue()` : 从循环队列中删除一个元素。如果成功删除则返回真。
-  `isEmpty()` : 检查循环队列是否为空。
-  `isFull()` : 检查循环队列是否已满。


 **示例：** 

```
MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4
```


 **提示：** 
- 所有的值都在 0 至 1000 的范围内；
- 操作数将在 1 至 1000 的范围内；
- 请不要使用内置的队列库。

**标签**
`设计` `队列` `数组` `链表` 


##### solution
```python
class MyCircularQueue:

    def __init__(self, k: int):
        self.count = 0
        self.capacity = k
        self.start_idx = 0
        self.queue = [0] * k

    def enQueue(self, value: int) -> bool:
        if self.count == self.capacity:
            return False
        self.queue[(self.start_idx + self.count) % self.capacity] = value
        self.count += 1
        return True

    def deQueue(self) -> bool:
        if self.count == 0:
            return False
        self.start_idx = (self.start_idx + 1) % self.capacity
        self.count -= 1
        return True

    def Front(self) -> int:
        if self.count == 0:
            return -1
        return self.queue[self.start_idx % self.capacity]

    def Rear(self) -> int:
        if self.count == 0:
            return -1
        return self.queue[(self.start_idx + self.count - 1) % self.capacity]

    def isEmpty(self) -> bool:
        return self.count == 0

    def isFull(self) -> bool:
        return self.count == self.capacity
```
>
#### 641.design-circular-deque
[https://leetcode-cn.com/problems/design-circular-deque](https://leetcode-cn.com/problems/design-circular-deque) 
###### 原题
设计实现双端队列。

实现 `MyCircularDeque` 类:
-  `MyCircularDeque(int k)` ：构造函数,双端队列最大为 `k` 。
-  `boolean insertFront()` ：将一个元素添加到双端队列头部。 如果操作成功返回 `true` ，否则返回 `false` 。
-  `boolean insertLast()` ：将一个元素添加到双端队列尾部。如果操作成功返回 `true` ，否则返回 `false` 。
-  `boolean deleteFront()` ：从双端队列头部删除一个元素。 如果操作成功返回 `true` ，否则返回 `false` 。
-  `boolean deleteLast()` ：从双端队列尾部删除一个元素。如果操作成功返回 `true` ，否则返回 `false` 。
-  `int getFront()` )：从双端队列头部获得一个元素。如果双端队列为空，返回 `-1` 。
-  `int getRear()` ：获得双端队列的最后一个元素。 如果双端队列为空，返回 `-1` 。
-  `boolean isEmpty()` ：若双端队列为空，则返回 `true` ，否则返回 `false` 。
-  `boolean isFull()` ：若双端队列满了，则返回 `true` ，否则返回 `false` 。


 **示例 1：** 

```

输入
["MyCircularDeque", "insertLast", "insertLast", "insertFront", "insertFront", "getRear", "isFull", "deleteLast", "insertFront", "getFront"]
[[3], [1], [2], [3], [4], [], [], [], [4], []]
输出
[null, true, true, true, false, 2, true, true, true, 4]

解释
MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3
circularDeque.insertLast(1);			        // 返回 true
circularDeque.insertLast(2);			        // 返回 true
circularDeque.insertFront(3);			        // 返回 true
circularDeque.insertFront(4);			        // 已经满了，返回 false
circularDeque.getRear();  				// 返回 2
circularDeque.isFull();				        // 返回 true
circularDeque.deleteLast();			        // 返回 true
circularDeque.insertFront(4);			        // 返回 true
circularDeque.getFront();				// 返回 4
 
```


 **提示：** 
-  `1 <= k <= 1000` 
-  `0 <= value <= 1000` 
-  `insertFront` , `insertLast` , `deleteFront` , `deleteLast` , `getFront` , `getRear` , `isEmpty` , `isFull` 调用次数不大于 `2000` 次

**标签**
`设计` `队列` `数组` `链表` 


##### solution
```python
class MyCircularDeque:

    def __init__(self, k: int):
        self.capacity = k + 1
        self.front = 0
        self.rear = 0 # rear始终指向None
        self.queue = [0] * (k + 1)

    def insertFront(self, value: int) -> bool:
        if self.isFull():
            return False
        self.front = (self.front - 1) % self.capacity
        self.queue[self.front] = value
        return True

    def insertLast(self, value: int) -> bool:
        if self.isFull():
            return False
        self.queue[self.rear] = value
        self.rear = (self.rear + 1) % self.capacity
        return True

    def deleteFront(self) -> bool:
        if self.isEmpty():
            return False
        self.front = (self.front + 1) % self.capacity
        return True

    def deleteLast(self) -> bool:
        if self.isEmpty():
            return False
        self.rear = (self.rear - 1) % self.capacity
        return True

    def getFront(self) -> int:
        if self.isEmpty():
            return -1
        return self.queue[self.front]

    def getRear(self) -> int:
        if self.isEmpty():
            return -1
        return self.queue[(self.rear - 1) % self.capacity]

    def isEmpty(self) -> bool:
        return self.front == self.rear

    def isFull(self) -> bool:
        return (self.rear + 1) % self.capacity == self.front
```
>
### 栈
#### 20.有效的括号
[https://leetcode-cn.com/problems/valid-parentheses](https://leetcode-cn.com/problems/valid-parentheses) 
###### 原题
给定一个只包括 `'('` ， `')'` ， `'{'` ， `'}'` ， `'['` ， `']'`  的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：
- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。


 **示例 1：** 

```

输入：s = "()"
输出：true

```
 **示例 2：** 

```

输入：s = "()[]{}"
输出：true

```
 **示例 3：** 

```

输入：s = "(]"
输出：false

```
 **示例 4：** 

```

输入：s = "([)]"
输出：false

```
 **示例 5：** 

```

输入：s = "{[]}"
输出：true
```


 **提示：** 
-  `1 <= s.length <= 10^4` 
-  `s` 仅由括号 `'()[]{}'` 组成

**标签**
`栈` `字符串` 


##### solution
```python
class Solution:
    def isValid(self, s: str) -> bool:
        d = {"(": ")", "[": "]", "{": "}"}
        stack = []
        for c in s:
            if c in "([{":
                stack.append(c)
            else:
                if stack and c == d[stack[-1]]:
                    stack.pop()
                else:
                    return False
        return not stack
```
>
#### 71.简化路径
[https://leetcode-cn.com/problems/simplify-path](https://leetcode-cn.com/problems/simplify-path) 
###### 原题
给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为更加简洁的规范路径。

```
在 Unix 风格的文件系统中，一个点（ `.` ）表示当前目录本身；此外，两个点 （ `..` ） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即， `'//'` ）都被视为单个斜杠 `'/'` 。 对于此问题，任何其他格式的点（例如， `'...'` ）均被视为文件/目录名称。
```


请注意，返回的 **规范路径** 必须遵循下述格式：
- 始终以斜杠 `'/'` 开头。
- 两个目录名之间必须只有一个斜杠 `'/'` 。
- 最后一个目录名（如果存在） **不能** 以 `'/'` 结尾。
- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'` 或 `'..'` ）。
返回简化后得到的 **规范路径** 。

 

 **示例 1：** 

```

输入：path = "/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。 
```
 **示例 2：** 

```

输入：path = "/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。

```
 **示例 3：** 

```

输入：path = "/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。

```
 **示例 4：** 

```

输入：path = "/a/./b/../../c/"
输出："/c"

```


 **提示：** 
-  `1 <= path.length <= 3000` 
-  `path` 由英文字母，数字， `'.'` ， `'/'` 或 `'_'` 组成。
-  `path` 是一个有效的 Unix 风格绝对路径。

**标签**
`栈` `字符串` 


##### solution
```python
class Solution:
    def simplifyPath(self, path: str) -> str:
        stack = []
        for s in path.split("/"):
            if not s or s == ".":
                continue
            if s == "..":
                if stack:
                    stack.pop()
            else:
                stack.append(s)
        return "/" + "/".join(stack)
```
>
#### 150.逆波兰表达式求值
[https://leetcode-cn.com/problems/evaluate-reverse-polish-notation](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation) 
###### 原题
根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" target="_blank"> 逆波兰表示法</a>，求表达式的值。

有效的算符包括 `+` 、 `-` 、 `*` 、 `/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

<b>注意 </b>两个整数之间的除法只保留整数部分。

可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

 

 **示例 1：** 

```

输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

```
 **示例 2：** 

```

输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

```
 **示例 3：** 

```

输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```


 **提示：** 
-  `1 <= tokens.length <= 10^4` 
-  `tokens[i]` 是一个算符（ `"+"` 、 `"-"` 、 `"*"` 或 `"/"` ），或是在范围 `[-200, 200]` 内的一个整数


 **逆波兰表达式：** 

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。
- 平常使用的算式则是一种中缀表达式，如 `( 1 + 2 ) * ( 3 + 4 )` 。
- 该算式的逆波兰表达式写法为 `( ( 1 2 + ) ( 3 4 + ) * )` 。
逆波兰表达式主要有以下两个优点：
- 去掉括号后表达式无歧义，上式即便写成 `1 2 + 3 4 + *` 也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

**标签**
`栈` `数组` `数学` 


##### solution
```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for c in tokens:
            if c not in "+-*/":
                stack.append(int(c))
            else:
                right = stack.pop()
                left = stack.pop()
                if c == "*":
                    stack.append(left * right)
                elif c == "+":
                    stack.append(left + right)
                elif c == "-":
                    stack.append(left - right)
                else:
                    stack.append(int(left / right))
        return stack[0]
```
>
#### 155.最小栈
[https://leetcode-cn.com/problems/min-stack](https://leetcode-cn.com/problems/min-stack) 
###### 原题
设计一个支持 `push` ， `pop` ， `top` 操作，并能在常数时间内检索到最小元素的栈。
-  `push(x)` &mdash;&mdash; 将元素 x 推入栈中。
-  `pop()` &mdash;&mdash; 删除栈顶的元素。
-  `top()` &mdash;&mdash; 获取栈顶元素。
-  `getMin()` &mdash;&mdash; 检索栈中的最小元素。


 **示例:** 

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.

```


 **提示：** 
-  `pop` 、 `top` 和 `getMin` 操作总是在 **非空栈** 上调用。

**标签**
`栈` `设计` 


##### solution
```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack:
            self.min_stack.append(val)
        else:
            self.min_stack.append(min(self.min_stack[-1], val))

    def pop(self) -> None:
        self.stack.pop()
        self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```
>
## 5二叉树

### 前序遍历

#### 105.从前序与中序遍历序列构造二叉树

[https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal) 

###### 原题

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的 **先序遍历** ， `inorder` 是同一棵树的 **中序遍历** ，请构造二叉树并返回其根节点。

 

 **示例 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" style="height: 302px; width: 277px;" />

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]

```

 **示例 2:** 

```
输入: preorder = [-1], inorder = [-1]
输出: [-1]

```


 **提示:** 

-  `1 <= preorder.length <= 3000` 
-  `inorder.length == preorder.length` 
-  `-3000 <= preorder[i], inorder[i] <= 3000` 
-  `preorder` 和 `inorder` 均 **无重复** 元素
-  `inorder` 均出现在 `preorder` 
-  `preorder` **保证** 为二叉树的前序遍历序列
-  `inorder` **保证** 为二叉树的中序遍历序列

**标签**
`树` `数组` `哈希表` `分治` `二叉树` 


##### solution

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not preorder:
            return None
        root = TreeNode(preorder[0])
        idx = inorder.index(preorder[0])
        left_tree = inorder[:idx]
        right_tree = inorder[idx+1:]
        root.left = self.buildTree(preorder[1: 1 + len(left_tree)], left_tree)
        root.right = self.buildTree(preorder[1 + len(left_tree):], right_tree)
        return root
```

>

#### 112.路径总和

[https://leetcode-cn.com/problems/path-sum](https://leetcode-cn.com/problems/path-sum) 

###### 原题

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

 **叶子节点** 是指没有子节点的节点。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" style="width: 500px; height: 356px;" />

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。

```

 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" />

```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

 **示例 3：** 

```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。

```


 **提示：** 

- 树中节点的数目在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000` 
- `-1000 <= targetSum <= 1000` 

**标签**
`树` `深度优先搜索` `广度优先搜索` `二叉树` 

##### solution1 dfs标准写法，等价于递归

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        def dfs(sum_, node):
            if not node.left and not node.right and sum_ + node.val == targetSum:
                return True
            
            if node.left and dfs(sum_ + node.val, node.left):
                return True
            if node.right and dfs(sum_ + node.val, node.right):
                return True
            return False
            
        
        if not root:
            return False
        return dfs(0, root)
```

##### solution2 递归

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        if not root.left and not root.right and root.val == targetSum:
            return True
        return self.hasPathSum(root.left, targetSum-root.val) or self.hasPathSum(root.right, targetSum-root.val)
```

##### solution3 迭代——使用stack

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False

        stack = [(root, 0)]
        while stack:
            node, val = stack.pop()
            if not node.left and not node.right and val + node.val == targetSum:
                return True
            if node.left:
                stack.append((node.left, val + node.val))
            if node.right:
                stack.append((node.right, val + node.val))
        return False
```

>

#### 113.路径总和-ii

[https://leetcode-cn.com/problems/path-sum-ii](https://leetcode-cn.com/problems/path-sum-ii) 

###### 原题

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

 **叶子节点** 是指没有子节点的节点。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" style="width: 500px; height: 356px;" />

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]

```

 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" style="width: 212px; height: 181px;" />

```
输入：root = [1,2,3], targetSum = 5
输出：[]

```

 **示例 3：** 

```
输入：root = [1,2], targetSum = 0
输出：[]

```


 **提示：** 

- 树中节点总数在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000` 
- `-1000 <= targetSum <= 1000` 

**标签**
`树` `深度优先搜索` `回溯` `二叉树` 


##### solution

```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        def dfs(path, sum_, node):
            if not node.left and not node.right and sum_ + node.val == targetSum:
                res.append([node.val for node in path + [node]])
                return
            
            if node.left:
                dfs(path + [node], sum_ + node.val, node.left)
            if node.right:
                dfs(path + [node], sum_ + node.val, node.right)
            
        if not root:
            return []
        res = []
        dfs([], 0, root)
        return res
```

>

#### 129.求根到叶子节点数字之和

[https://leetcode-cn.com/problems/sum-root-to-leaf-numbers](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers) 

###### 原题

给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。
    计算从根节点到叶节点生成的 **所有数字之和** 。

 **叶节点** 是指没有子节点的节点。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" style="width: 212px; height: 182px;" />

```
输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
```

 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" style="width: 292px; height: 302px;" />

```
输入：root = [4,9,0,5,1]
输出：1026
解释：
从根到叶子节点路径 4->9->5 代表数字 495
从根到叶子节点路径 4->9->1 代表数字 491
从根到叶子节点路径 4->0 代表数字 40
因此，数字总和 = 495 + 491 + 40 = 1026

```


 **提示：** 

- 树中节点的数目在范围 `[1, 1000]` 内
- `0 <= Node.val <= 9` 
- 树的深度不超过 `10` 

**标签**
`树` `深度优先搜索` `二叉树` 

##### solution1 dfs标准写法，等价于递归

```python
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        def dfs(path, node):
            nonlocal res
            if not node.left and not node.right:
                res += int("".join([str(node.val) for node in path + [node]]))
                return
            
            if node.left:
                dfs(path + [node], node.left)
            if node.right:
                dfs(path + [node], node.right)
            
        if not root:
            return 0
        res = 0
        dfs([], root)
        return res
```

##### solution2 递归

-   与112.路径总和不同的是，本体的sumNumbers函数只有一个TreeNode变量，但是递归过程中还需要一个变量记录从根节点到当前节点的值组成的整数

```python
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        def helper(node, path_val):
            nonlocal res
            if not node.left and not node.right:
                res += 10 * path_val + node.val
                return
            if node.left:
                helper(node.left, 10 * path_val + node.val)
            if node.right:
                helper(node.right, 10 * path_val + node.val)

        if not root:
            return 0
        res = 0
        helper(root, 0)
        return res
```

##### solution3 迭代

```python
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        stack = [(root, 0)]
        res = 0
        while stack:
            node, val = stack.pop()
            if not node.left and not node.right:
                res += 10 * val + node.val
            if node.left:
                stack.append((node.left, 10 * val + node.val))
            if node.right:
                stack.append((node.right, 10 * val + node.val))
        return res
```

>

#### 144.二叉树的前序遍历

[https://leetcode-cn.com/problems/binary-tree-preorder-traversal](https://leetcode-cn.com/problems/binary-tree-preorder-traversal) 

###### 原题

给你二叉树的根节点 `root` ，返回它节点值的  **前序** * * 遍历。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" style="width: 202px; height: 324px;" />

```
输入：root = [1,null,2,3]
输出：[1,2,3]

```

 **示例 2：** 

```
输入：root = []
输出：[]

```

 **示例 3：** 

```
输入：root = [1]
输出：[1]

```

 **示例 4：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" style="width: 202px; height: 202px;" />

```
输入：root = [1,2]
输出：[1,2]

```

 **示例 5：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" style="width: 202px; height: 202px;" />

```
输入：root = [1,null,2]
输出：[1,2]

```


 **提示：** 

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100` 


 **进阶：** 递归算法很简单，你可以通过迭代算法完成吗？


**标签**
`栈` `树` `深度优先搜索` `二叉树` 

##### solution1 递归

```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def helper(root):
            nonlocal res
            res.append(root.val)
            if root.left:
                helper(root.left)
            if root.right:
                helper(root.right)
        
        if not root:
            return []
        res = []
        helper(root)
        return res
```

##### solution2 迭代

```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        
        res = []
        stack = [root]
        while stack:
            node = stack.pop()
            res.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return res
```

>

#### 257.二叉树的所有路径

[https://leetcode-cn.com/problems/binary-tree-paths](https://leetcode-cn.com/problems/binary-tree-paths) 

###### 原题

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

 **叶子节点** 是指没有子节点的节点。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" style="width: 207px; height: 293px;" />

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]

```

 **示例 2：** 

```
输入：root = [1]
输出：["1"]

```


 **提示：** 

- 树中节点的数目在范围 `[1, 100]` 内
- `-100 <= Node.val <= 100` 

**标签**
`树` `深度优先搜索` `字符串` `回溯` `二叉树` 

##### solution1 dfs标准写法，等价于递归

```python
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        def dfs(path, node):
            if not node.left and not node.right:
                res.append("->".join([str(i) for i in path + [node.val]]))
                return
            if node.left:
                dfs(path + [node.val], node.left)
            if node.right:
                dfs(path + [node.val], node.right)
        
        res = []
        dfs([], root)
        return res
```

##### Solution2 迭代

```python
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        stack = [(root, "")]
        res = []
        while stack:
            node, s = stack.pop()
            if not node.left and not node.right:
                res.append(s + str(node.val))
            if node.left:
                stack.append((node.left, s + str(node.val) + "->" ))
            if node.right:
                stack.append((node.right, s + str(node.val) + "->"))
        return res
```

>

#### 437.路径总和-iii

[https://leetcode-cn.com/problems/path-sum-iii](https://leetcode-cn.com/problems/path-sum-iii) 

###### 原题

给定一个二叉树的根节点 `root`  ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

 **路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

 

 **示例 1：** 

<img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" style="width: 452px; " />

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。

```

 **示例 2：** 

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3

```


 **提示:** 

- 二叉树的节点个数的范围是 `[0,1000]` 

- <meta charset="UTF-8" /> `-10^9 <= Node.val <= 10^9`  

-  `-1000 <= targetSum <= 1000`  

**标签**
`树` `深度优先搜索` `二叉树` 

##### solution1 递归

-   从root为根节点的子树中，找一条向下的和为targetSum的路径，等价于两个问题解集的并集
    -   找一条root为初始节点的且向下的和为targetSum的路径
    -   分别从root.left和root.right为根节点的子树中，找一条向下的和为targetSum的路径

```python
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        # dfs函数计算以node节点为初始节点，向下出发，找到和为sum_的路径
        
        def dfs(node, sum_):
            if not node:
                return 0
            res = 0
            if node.val == sum_:
                res += 1
            res += dfs(node.left, sum_ - node.val)
            res += dfs(node.right, sum_ - node.val)
            return res

        if not root:
            return 0
        
        res = dfs(root, targetSum)
        res += self.pathSum(root.left, targetSum)
        res += self.pathSum(root.right, targetSum)
        return res
```



##### solution2 前缀和

-   A，B两个node，前缀和分别为sum-target和sum，则路径A->B为目标路径

```python
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        def dfs(node, pre_sum):
            nonlocal res
            if not node:
                return
            
            pre_sum += node.val
            res += pathSum2cnt.get(pre_sum - targetSum, 0)
            pathSum2cnt[pre_sum] = pathSum2cnt.get(pre_sum, 0) + 1
            dfs(node.left, pre_sum)
            dfs(node.right, pre_sum)
            pathSum2cnt[pre_sum] -= 1
        
        if not root:
            return 0
        res = 0
        pathSum2cnt = {0: 1}
        dfs(root, 0)
        return res
```

>

#### 617.合并二叉树

[https://leetcode-cn.com/problems/merge-two-binary-trees](https://leetcode-cn.com/problems/merge-two-binary-trees) 

###### 原题

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则， **不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

 **注意:** 合并过程必须从两个树的根节点开始。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" style="height: 163px; width: 600px;" />

```
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]

```

 **示例 2：** 

```
输入：root1 = [1], root2 = [1,2]
输出：[2,2]

```


 **提示：** 

- 两棵树中的节点数目在范围 `[0, 2000]` 内
- `-10^4 <= Node.val <= 10^4` 

**标签**
`树` `深度优先搜索` `广度优先搜索` `二叉树` 


##### solution

```python
class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        if not root2:
            return root1
        if not root1:
            return root2
        root1.val += root2.val
        root1.left = self.mergeTrees(root1.left, root2.left)
        root1.right = self.mergeTrees(root1.right, root2.right)
        return root1
```

>

### 中序遍历

#### 94.二叉树的中序遍历

[https://leetcode-cn.com/problems/binary-tree-inorder-traversal](https://leetcode-cn.com/problems/binary-tree-inorder-traversal) 

###### 原题

给定一个二叉树的根节点 `root` ，返回它的 **中序**  遍历。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" style="width: 202px; height: 324px;" />

```
输入：root = [1,null,2,3]
输出：[1,3,2]

```

 **示例 2：** 

```
输入：root = []
输出：[]

```

 **示例 3：** 

```
输入：root = [1]
输出：[1]

```

 **示例 4：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" style="width: 202px; height: 202px;" />

```
输入：root = [1,2]
输出：[2,1]

```

 **示例 5：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" style="width: 202px; height: 202px;" />

```
输入：root = [1,null,2]
输出：[1,2]

```


 **提示：** 

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100` 


 **进阶:**  递归算法很简单，你可以通过迭代算法完成吗？


**标签**
`栈` `树` `深度优先搜索` `二叉树` 

##### solution1 递归

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def helper(root):
            if not root:
                return []
            res = []
            res += helper(root.left)
            res.append(root.val)
            res += helper(root.right)
            return res
        
        res = helper(root)
        return res
```

##### solution2 迭代

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        stack = []
        p = root
        res = []
        while p or stack:
            if p:
                stack.append(p)
                p = p.left
            else:
                p = stack.pop()
                res.append(p.val)
                p = p.right
        return res
```

>

#### 530.二叉搜索树的最小绝对差

[https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst) 

###### 原题

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" style="width: 292px; height: 301px;" />

```
输入：root = [4,2,6,1,3]
输出：1

```

 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" style="width: 282px; height: 301px;" />

```
输入：root = [1,0,48,null,null,12,49]
输出：1

```


 **提示：** 

- 树中节点的数目范围是 `[2, 10^4]` 
- `0 <= Node.val <= 10^5` 


 **注意：** 本题与 783 <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同


**标签**
`树` `深度优先搜索` `广度优先搜索` `二叉搜索树` `二叉树` 


##### solution

```python
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        res = float('inf')
        stack = []
        pre, cur = None, root
        while cur or stack:
            if cur:
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                if pre and res > abs(pre.val - cur.val):
                    res = abs(pre.val - cur.val)
                pre = cur
                cur = cur.right
        return res
```

>

## 

### 后序遍历
#### 104.二叉树的最大深度
[https://leetcode-cn.com/problems/maximum-depth-of-binary-tree](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree) 
###### 原题
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

 **说明:** 叶子节点是指没有子节点的节点。

 **示例：** <br>
给定二叉树 `[3,9,20,null,null,15,7]` ，

```
    3
   / \
  9  20
    /  \
   15   7
```
返回它的最大深度 3 。


**标签**
`树` `深度优先搜索` `广度优先搜索` `二叉树` 


##### solution
```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```
>
#### 110.平衡二叉树
[https://leetcode-cn.com/problems/balanced-binary-tree](https://leetcode-cn.com/problems/balanced-binary-tree) 
###### 原题
给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

<blockquote>
一个二叉树 *每个节点 * 的左右两个子树的高度差的绝对值不超过 1 。
</blockquote>



 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" style="width: 342px; height: 221px;" />
```

输入：root = [3,9,20,null,null,15,7]
输出：true

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" style="width: 452px; height: 301px;" />
```

输入：root = [1,2,2,3,3,null,null,4,4]
输出：false

```
 **示例 3：** 

```

输入：root = []
输出：true

```


 **提示：** 
- 树中的节点数在范围 `[0, 5000]` 内
-  `-10^4 <= Node.val <= 10^4` 

**标签**
`树` `深度优先搜索` `二叉树` 

##### solution1 有许多重复计算

```python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        
        def maxDepth(root):
            if not root:
                return 0
            return 1 + max(maxDepth(root.left), maxDepth(root.right))
        
        if not root:
            return True
        left = maxDepth(root.left)
        right = maxDepth(root.right)
        return abs(left - right) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)
```


##### Solution2 只遍历一次树
```python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        
        def maxDepth(root):
            if not root:
                return 0
            left = maxDepth(root.left)
            right = maxDepth(root.right)
            if abs(left - right) > 1:
                self.flag = False
            return 1 + max(left, right)
        
        self.flag = True
        maxDepth(root)
        return self.flag if root else True
```
>
#### 124.二叉树中的最大路径和
[https://leetcode-cn.com/problems/binary-tree-maximum-path-sum](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum) 
###### 原题
 **路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

 **路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" style="width: 322px; height: 182px;" />
```

输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" />
```

输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42

```


 **提示：** 
- 树中节点数目范围是 `[1, 3 * 10^4]` 
-  `-1000 <= Node.val <= 1000` 

**标签**
`树` `深度优先搜索` `动态规划` `二叉树` 

##### solution

-   给定一个非空节点，最终路径经过这个节点有4种情况：
    -   只有该节点本身（左右子树的路径都是负数）；
    -   该节点+左子树路径；
    -   该节点+右子树路径；
    -   该节点+左子树路径+右子树路径。
-   其中1，2，3都可以作为子树路径和向上延伸，而4则不行。

```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        def max_gain(root):
            if not root:
                return 0
            left = max_gain(root.left)
            right = max_gain(root.right)
            max_can_pass = root.val + max(max(left, right), 0)
            self.res = max(self.res, max(max_can_pass, root.val + left + right))
            return max_can_pass

        self.res = float('-inf')
        max_gain(root)
        return self.res
```
>
#### 145.二叉树的后序遍历
[https://leetcode-cn.com/problems/binary-tree-postorder-traversal](https://leetcode-cn.com/problems/binary-tree-postorder-traversal) 
###### 原题
给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg" style="width: 127px; height: 200px;" />
```

输入：root = [1,null,2,3]
输出：[3,2,1]

```
 **示例 2：** 

```

输入：root = []
输出：[]

```
 **示例 3：** 

```

输入：root = [1]
输出：[1]

```


 **提示：** 
- 树中节点的数目在范围 `[0, 100]` 内
-  `-100 <= Node.val <= 100` 


 **进阶：** 递归算法很简单，你可以通过迭代算法完成吗？


**标签**
`栈` `树` `深度优先搜索` `二叉树` 

##### solution1 递归

```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def postorder(root):
            if not root:
                return
            postorder(root.left)
            postorder(root.right)
            res.append(root.val)
        
        res = []
        postorder(root)
        return res
```

##### solution2 迭代

```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        stack = [root]
        res = []
        while stack:
            node = stack.pop()
            res.append(node.val)
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        return res[::-1]
```
>
#### 865.具有所有最深节点的最小子树
[https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes](https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes) 
###### 原题
给定一个根为 `root` 的二叉树，每个节点的深度是 **该节点到根的最短距离** 。

返回包含原始树中所有 **最深节点** 的 *最小子树* 。

如果一个节点在 **整个树** 的任意节点之间具有最大的深度，则该节点是 **最深的** 。

一个节点的 **子树** 是该节点加上它的所有后代的集合。

 

 **示例 1：** 

<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png" style="width: 300px;" />

```

输入：root = [3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释：
我们返回值为 2 的节点，在图中用黄色标记。
在图中用蓝色标记的是树的最深的节点。
注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。

```
 **示例 2：** 

```

输入：root = [1]
输出：[1]
解释：根节点是树中最深的节点。
```
 **示例 3：** 

```

输入：root = [0,1,3,null,2]
输出：[2]
解释：树中最深的节点为 2 ，有效子树为节点 2、1 和 0 的子树，但节点 2 的子树最小。
```


 **提示：** 
- 树中节点的数量在 `[1, 500]` 范围内。
-  `0 <= Node.val <= 500` 
- 每个节点的值都是 **独一无二** 的。


 **注意：** 本题与力扣 1123 重复：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/" target="_blank">https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves</a>

**标签**
`树` `深度优先搜索` `广度优先搜索` `哈希表` `二叉树` 


##### solution
```python
class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:

        def max_depth(root):
            if not root:
                return 0
            return 1 + max(max_depth(root.left), max_depth(root.right))
        
        if not root:
            return root
        left = max_depth(root.left)
        right = max_depth(root.right)
        if left == right:
            return root
        elif left > right:
            return self.subtreeWithAllDeepest(root.left)
        return self.subtreeWithAllDeepest(root.right)
```
>
### 层序遍历

#### 102.二叉树的层次遍历

[https://leetcode-cn.com/problems/binary-tree-level-order-traversal](https://leetcode-cn.com/problems/binary-tree-level-order-traversal) 

###### 原题

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="width: 277px; height: 302px;" />

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]

```

 **示例 2：** 

```
输入：root = [1]
输出：[[1]]

```

 **示例 3：** 

```
输入：root = []
输出：[]

```


 **提示：** 

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000` 

**标签**
`树` `广度优先搜索` `二叉树` 

##### solution1 使用deque

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = collections.deque([root])
        res = []
        while queue:
            cur_size = len(queue)
            cur = []
            for _ in range(cur_size):
                node = queue.popleft()
                cur.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(cur)
        return res
```



##### solution2 使用list

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        res = []
        while queue:
            next_queue = []
            cur = []
            for node in queue:
                cur.append(node.val)
                if node.left:
                    next_queue.append(node.left)
                if node.right:
                    next_queue.append(node.right)
            res.append(cur)
            queue = next_queue
        return res
```

>

#### 103.二叉树的锯齿形层次遍历

[https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal) 

###### 原题

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="width: 277px; height: 302px;" />

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]

```

 **示例 2：** 

```
输入：root = [1]
输出：[[1]]

```

 **示例 3：** 

```
输入：root = []
输出：[]

```


 **提示：** 

- 树中节点数目在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100` 

**标签**
`树` `广度优先搜索` `二叉树` 


##### solution

```python
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        res = []
        queue = collections.deque([root])
        is_reverse = False
        while queue:
            cur_size = len(queue)
            cur = []
            for _ in range(cur_size):
                node = queue.popleft()
                cur.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            cur = cur if not is_reverse else cur[::-1]
            is_reverse = not is_reverse
            res.append(cur)
        return res
```

>

#### 107.二叉树的层次遍历-ii

[https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii) 

###### 原题

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="width: 277px; height: 302px;" />

```
输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]

```

 **示例 2：** 

```
输入：root = [1]
输出：[[1]]

```

 **示例 3：** 

```
输入：root = []
输出：[]

```


 **提示：** 

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000` 

**标签**
`树` `广度优先搜索` `二叉树` 


##### solution

```python
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = collections.deque([root])
        res = []
        while queue:
            cur_size = len(queue)
            cur = []
            for _ in range(cur_size):
                node = queue.popleft()
                cur.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(cur)
        return res[::-1]
```

>

#### 116.填充每个节点的下一个右侧节点指针

[https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node) 

###### 原题

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL` 。

初始状态下，所有 next 指针都被设置为 `NULL` 。

 

 **示例 1：** 

<img alt="" src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" style="height: 171px; width: 500px;" />

```
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。

```

<meta charset="UTF-8" />

 **示例 2:** 

```
输入：root = []
输出：[]

```


 **提示：** 

- 树中节点的数量在<meta charset="UTF-8" /> `[0, 2^12 - 1]` 范围内
- `-1000 <= node.val <= 1000` 


 **进阶：** 

- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

**标签**
`树` `深度优先搜索` `广度优先搜索` `链表` `二叉树` 


##### solution

```python
class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if not root:
            return root
        queue = collections.deque([root])
        while queue:
            cur_size = len(queue)
            for i in range(cur_size):
                cur_node = queue.popleft()
                if i != cur_size - 1:
                    next_node = queue[0]
                    cur_node.next = next_node
                if cur_node.left:
                    queue.append(cur_node.left)
                if cur_node.right:
                    queue.append(cur_node.right)
        return root
```

>

#### 199.二叉树的右视图

[https://leetcode-cn.com/problems/binary-tree-right-side-view](https://leetcode-cn.com/problems/binary-tree-right-side-view) 

###### 原题

给定一个二叉树的 **根节点** `root` ，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

 

 **示例 1:** 

<img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" style="width: 270px; " />

```
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]

```

 **示例 2:** 

```
输入: [1,null,3]
输出: [1,3]

```

 **示例 3:** 

```
输入: []
输出: []

```


 **提示:** 

- 二叉树的节点个数的范围是 `[0,100]` 

- <meta charset="UTF-8" /> `-100 <= Node.val <= 100`  

**标签**
`树` `深度优先搜索` `广度优先搜索` `二叉树` 


##### solution

```python
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        res = []
        queue = collections.deque([root])
        while queue:
            res.append(queue[-1].val)
            cur_size = len(queue)
            for _ in range(cur_size):
                cur_node = queue.popleft()
                if cur_node.left:
                    queue.append(cur_node.left)
                if cur_node.right:
                    queue.append(cur_node.right)
        return res
```

>

#### 637.二叉树的层平均值

##### 原题

给定一个非空二叉树的根节点`root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10^-5` 以内的答案可以被接受。

 **示例 1：** 

<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0gihkf4j8j207p08e3yh.jpg" />

```
输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
因此返回 [3, 14.5, 11] 。

```

 **示例 2:** 

<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0gihj0fh6j208408eaa1.jpg" />

```
输入：root = [3,9,20,15,7]
输出：[3.00000,14.50000,11.00000]

```


 **提示：** 

- 树中节点数量在 `[1, 10^4]` 范围内
- `-2^31 <= Node.val <= 2^31 - 1` 

**标签**
`树` `深度优先搜索` `广度优先搜索` `二叉树` 

##### solution

```python
class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        res = []
        queue = collections.deque([root])
        while queue:
            cur_size = len(queue)
            cur_sum = 0
            for _ in range(cur_size):
                cur_node = queue.popleft()
                cur_sum += cur_node.val
                if cur_node.left:
                    queue.append(cur_node.left)
                if cur_node.right:
                    queue.append(cur_node.right)
            res.append(cur_sum / cur_size)
        return res
```



### 二叉搜索树

#### 98.验证二叉搜索树

[https://leetcode-cn.com/problems/validate-binary-search-tree](https://leetcode-cn.com/problems/validate-binary-search-tree) 

##### 原题

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

 **有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" style="width: 302px; height: 182px;" />

```
输入：root = [2,1,3]
输出：true

```

 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" style="width: 422px; height: 292px;" />

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。

```


 **提示：** 

- 树中节点数目范围在 `[1, 10^4]` 内
- `-2^31 <= Node.val <= 2^31 - 1` 

**标签**
`树` `深度优先搜索` `二叉搜索树` `二叉树` 


##### solution

```python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        stack = []
        p = root
        pre = float('-inf')
        while stack or p:
            if p:
                stack.append(p)
                p = p.left
            else:
                p = stack.pop()
                if p.val <= pre:
                    return False
                pre = p.val
                p = p.right
        return True
```

>

#### 108.将有序数组转换为二叉搜索树

[https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree) 

##### 原题

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

 **高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" style="width: 302px; height: 222px;" />

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg" style="width: 302px; height: 222px;" />

```

 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" style="width: 342px; height: 142px;" />

```
输入：nums = [1,3]
输出：[3,1]
解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。

```


 **提示：** 

-  `1 <= nums.length <= 10^4` 
-  `-10^4 <= nums[i] <= 10^4` 
-  `nums` 按 **严格递增** 顺序排列

**标签**
`树` `二叉搜索树` `数组` `分治` `二叉树` 


##### solution

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        n = len(nums)
        if n == 1:
            return TreeNode(nums[0])
        mid = n // 2
        root = TreeNode(nums[mid])
        root.left = self.sortedArrayToBST(nums[:mid])
        root.right = self.sortedArrayToBST(nums[mid+1:])
        return root
```

>

#### [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

##### 原题

实现一个二叉搜索树迭代器类 `BSTIterator` ，表示一个按中序遍历二叉搜索树（BST）的迭代器：

-  `BSTIterator(TreeNode root)` 初始化 `BSTIterator` 类的一个对象。BST 的根节点 `root` 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。
-  `boolean hasNext()` 如果向指针右侧遍历存在数字，则返回 `true` ；否则返回 `false` 。
-  `int next()` 将指针向右移动，然后返回指针处的数字。
    注意，指针初始化为一个不存在于 BST 中的数字，所以对 `next()` 的首次调用将返回 BST 中的最小元素。
    你可以假设  `next()`  调用总是有效的，也就是说，当调用 `next()`  时，BST 的中序遍历中至少存在一个下一个数字。

 

 **示例：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0lewr4myyj205904yglg.jpg" style="width: 189px; height: 178px;" />

```
输入
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
输出
[null, 3, 7, true, 9, true, 15, true, 20, false]

解释
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // 返回 3
bSTIterator.next();    // 返回 7
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 9
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 15
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 20
bSTIterator.hasNext(); // 返回 False

```


 **提示：** 

- 树中节点的数目在范围 `[1, 10^5]` 内
- `0 <= Node.val <= 10^6` 
- 最多调用 `10^5` 次 `hasNext` 和 `next` 操作


 **进阶：** 

- 你可以设计一个满足下述条件的解决方案吗？ `next()` 和 `hasNext()` 操作均摊时间复杂度为 `O(1)` ，并使用 `O(h)` 内存。其中 `h` 是树的高度。

**标签**
`栈` `树` `设计` `二叉搜索树` `二叉树` `迭代器` 

```python
class BSTIterator:

    def __init__(self, root: TreeNode):
        self.cur = root
        self.stack = []

    def next(self) -> int:
        cur = self.cur
        while cur:
            self.stack.append(cur)
            cur = cur.left
        cur = self.stack.pop()
        val = cur.val
        self.cur = cur.right
        return val

    def hasNext(self) -> bool:
        return self.cur is not None or len(self.stack) > 0
```



#### 230.二叉搜索树中第k小的元素

[https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst) 

##### 原题

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第  `k` ** ** 个最小元素（从 1 开始计数）。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" style="width: 212px; height: 301px;" />

```
输入：root = [3,1,4,null,2], k = 1
输出：1

```

 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" style="width: 382px; height: 302px;" />

```
输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3

```




 **提示：** 

- 树中的节点数为 `n` 。
- `1 <= k <= n <= 10^4` 
- `0 <= Node.val <= 10^4` 


 **进阶：** 如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 `k` 小的值，你将如何优化算法？


**标签**
`树` `深度优先搜索` `二叉搜索树` `二叉树` 


##### solution

```python
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        cnt = 0
        p = root
        stack = []
        while p or stack:
            if p:
                stack.append(p)
                p = p.left
            else:
                p = stack.pop()
                cnt += 1
                if cnt == k:
                    return p.val
                p = p.right
```

>

#### 235.二叉搜索树的最近公共祖先

[https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree) 

##### 原题

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

<a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" target="_blank">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（ **一个节点也可以是它自己的祖先** ）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" style="height: 190px; width: 200px;">

 

 **示例 1:** 

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。

```

 **示例 2:** 

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```


 **说明:** 

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

**标签**
`树` `深度优先搜索` `二叉搜索树` `二叉树` 


##### solution

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if p.val < root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif p.val > root.val and q.val > root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        return root
```

>

#### [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 <a href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796" target="_blank">众数</a>（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

假定 BST 满足如下定义：

- 结点左子树中所含节点的值 **小于等于** 当前节点的值
- 结点右子树中所含节点的值 **大于等于** 当前节点的值
- 左子树和右子树都是二叉搜索树

 **示例 1：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0ldx453d7j203y066jr8.jpg" style="width: 142px; height: 222px;" />

```
输入：root = [1,null,2,2]
输出：[2]

```

 **示例 2：** 

```
输入：root = [0]
输出：[0]

```


 **提示：** 

- 树中节点的数目在范围 `[1, 10^4]` 内
- `-10^5 <= Node.val <= 10^5` 


 **进阶：** 你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

**标签**
`树` `深度优先搜索` `二叉搜索树` `二叉树` 

```python
class Solution:
    def findMode(self, root: TreeNode) -> List[int]:
        p, stack = root, []
        pre, pre_cnt = None, 0
        res, res_cnt = [], 0
        while p or stack:
            if p:
                stack.append(p)
                p = p.left
            else:
                p = stack.pop()
                if pre is None:
                    pre, pre_cnt = p.val, 1
                elif pre == p.val:
                    pre_cnt += 1
                else:
                    if pre_cnt > res_cnt:
                        res, res_cnt = [pre], pre_cnt
                    elif pre_cnt == res_cnt:
                        res.append(pre)
                    pre, pre_cnt = p.val, 1
                p = p.right
        if pre_cnt > res_cnt:
            res, res_cnt = [pre], pre_cnt
        elif pre_cnt == res_cnt:
            res.append(pre)
        return res
```





#### [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

#### [653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

#### [938. 二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)

#### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)


给定一棵二叉搜索树，请找出其中第 `k` 大的节点的值。

**示例 1:**

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

**示例 2:**

```
输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4
```

**限制：**

*   1 ≤ k ≤ 二叉搜索树元素个数

通过改变中序遍历的顺序：根左右 ——> 根右左

```python
class Solution:
    def kthLargest(self, root: TreeNode, k: int) -> int:
        p, stack = root, []
        cnt = 0
        while p or stack:
            if p:
                stack.append(p)
                p = p.right
            else:
                p = stack.pop()
                cnt += 1
                if cnt == k:
                    return p.val
                p = p.left
```

#### [剑指 Offer II 053. 二叉搜索树中的中序后继](https://leetcode-cn.com/problems/P5rCT8/)



>
### 其他

#### 236.二叉树的最近公共祖先

[https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree) 
###### 原题
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

<a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" target="_blank">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（ **一个节点也可以是它自己的祖先** ）。”

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" style="width: 200px; height: 190px;" />
```

输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" style="width: 200px; height: 190px;" />
```

输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。

```
 **示例 3：** 

```

输入：root = [1,2], p = 1, q = 2
输出：1

```


 **提示：** 
- 树中节点数目在范围 `[2, 10^5]` 内。
-  `-10^9 <= Node.val <= 10^9` 
- 所有 `Node.val` `互不相同` 。
-  `p != q` 
-  `p` 和 `q` 均存在于给定的二叉树中。

**标签**
`树` `深度优先搜索` `二叉树` 

##### solution

-   如果left和right都是非空，则返回当前节点（当前节点就是最近祖先）
-   left和right有一个为空，返回非空的那个。
-   不存在全部非空,因为必有公共祖先

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root.val == p.val or root.val == q.val:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if left and right:
            return root
        return left if left else right
```
>
#### 101.对称二叉树
[https://leetcode-cn.com/problems/symmetric-tree](https://leetcode-cn.com/problems/symmetric-tree) 
###### 原题
给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" style="width: 354px; height: 291px;" />
```

输入：root = [1,2,2,3,4,4,3]
输出：true

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" style="width: 308px; height: 258px;" />
```

输入：root = [1,2,2,null,3,null,3]
输出：false

```


 **提示：** 
- 树中节点数目在范围 `[1, 1000]` 内
-  `-100 <= Node.val <= 100` 


 **进阶：** 你可以运用递归和迭代两种方法解决这个问题吗？


**标签**
`树` `深度优先搜索` `广度优先搜索` `二叉树` 


##### solution
```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        def helper(left, right):
            if not left and not right:
                return True
            if not left or not right:
                return False
            if left.val != right.val:
                return False
            return helper(left.left, right.right) and helper(left.right, right.left)
            
        if not root:
            return True
        return helper(root.left, root.right)
```
>
#### 297.二叉树的序列化与反序列化
[https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree) 
###### 原题
序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

 **提示:** 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href="/faq/#binary-tree">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

 

 **示例 1：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0ldxef4opj20ca090aa4.jpg" style="width: 442px; height: 324px;" />

```

输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]

```
 **示例 2：** 

```

输入：root = []
输出：[]

```
 **示例 3：** 

```

输入：root = [1]
输出：[1]

```
 **示例 4：** 

```

输入：root = [1,2]
输出：[1,2]

```


 **提示：** 
- 树中结点数在范围 `[0, 10^4]` 内
-  `-1000 <= Node.val <= 1000` 

**标签**
`树` `深度优先搜索` `广度优先搜索` `设计` `字符串` `二叉树` 


##### solution
```python

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        queue = collections.deque([root])
        res = []
        while queue:
            node = queue.popleft()
            if not node:
                res.append("None")
                continue
            res.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        return ",".join(res)

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        data = data.split(",")
        if data[0] == "None":
            return None
        root = TreeNode(int(data[0]))
        queue = collections.deque([root])
        i = 1
        while queue and i < len(data):
            node = queue.popleft()
            if data[i] == "None":
                node.left = None
            else:
                node.left = TreeNode(int(data[i]))
                queue.append(node.left)
            i += 1
            if data[i] == "None":
                node.right = None
            else:
                node.right = TreeNode(int(data[i]))
                queue.append(node.right)
            i += 1
        return root
```
>
## 6图
### 广度优先搜索
#### 126.单词接龙-ii
[https://leetcode-cn.com/problems/word-ladder-ii](https://leetcode-cn.com/problems/word-ladder-ii) 
###### 原题
按字典 `wordList` 完成从单词 `beginWord` 到单词 `endWord` 转化，一个表示此过程的 **转换序列** 是形式上像 `beginWord -> s<sub>1</sub> -> s<sub>2</sub> -> ... -> s<sub>k</sub>` 这样的单词序列，并满足：
- 每对相邻的单词之间仅有单个字母不同。
- 转换过程中的每个单词 `s<sub>i</sub>` （ `1 <= i <= k` ）必须是字典 `wordList` 中的单词。注意， `beginWord` 不必是字典 `wordList` 中的单词。
-  `s<sub>k</sub> == endWord` 
给你两个单词 `beginWord` 和 `endWord` ，以及一个字典 `wordList` 。请你找出并返回所有从 `beginWord` 到 `endWord` 的 **最短转换序列** ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 `[beginWord, s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>]` 的形式返回。

 

 **示例 1：** 

```

输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
输出：[["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]
解释：存在 2 种最短的转换序列：
"hit" -> "hot" -> "dot" -> "dog" -> "cog"
"hit" -> "hot" -> "lot" -> "log" -> "cog"

```
 **示例 2：** 

```

输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
输出：[]
解释：endWord "cog" 不在字典 wordList 中，所以不存在符合要求的转换序列。

```


 **提示：** 
-  `1 <= beginWord.length <= 5` 
-  `endWord.length == beginWord.length` 
-  `1 <= wordList.length <= 5000` 
-  `wordList[i].length == beginWord.length` 
-  `beginWord` 、 `endWord` 和 `wordList[i]` 由小写英文字母组成
-  `beginWord != endWord` 
-  `wordList` 中的所有单词 **互不相同** 

**标签**
`广度优先搜索` `哈希表` `字符串` `回溯` 

##### solution 在bfs过程中记录路径

-   BFS找最短转换序列，停止条件为当前queue为空或者endWord在当前queue中，这表示到这一层就是最短的转换序列或者没有可行的转换路径
-   在遍历过程中构建字典用于后续回溯，格式为back_path[next_word].append(cur_word)
-   回溯，停止条件为back_path[beginWord] = []

```python
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
        if endWord not in wordList:
            return []
        
        n = len(beginWord)
        d = collections.defaultdict(list)
        for word in [beginWord] + wordList:
            for i in range(n):
                intermediate = word[:i] + "*" + word[i+1:]
                d[intermediate].append(word)
        
        queue = set([beginWord])
        visited = set()
        back_path = {word:[] for word in [beginWord] + wordList}
        while queue and endWord not in queue:
            next_queue = set()
            for word in queue:
                visited.add(word)
            for word in queue:
                for i in range(n):
                    intermediate = word[:i] + "*" + word[i+1:]
                    for nextWord in d[intermediate]:
                        if nextWord not in visited:
                            next_queue.add(nextWord)
                            back_path[nextWord].append(word)
            queue = next_queue
        if endWord not in queue:
            return []
        
        def dfs(path, word):
            if not back_path[word]:
                res.append([word] + path)
            else:
                for pre in back_path[word]:
                    dfs([word] + path, pre)
        
        res = []
        dfs([], endWord)
        return res
```
>
#### 127.单词接龙
[https://leetcode-cn.com/problems/word-ladder](https://leetcode-cn.com/problems/word-ladder) 
###### 原题
字典 `wordList` 中从单词 `beginWord` 和 `endWord` 的 **转换序列** 是一个按下述规格形成的序列<meta charset="UTF-8" /> `beginWord -> s<sub>1</sub> -> s<sub>2</sub> -> ... -> s<sub>k</sub>` ：
- 每一对相邻的单词只差一个字母。
- <meta charset="UTF-8" /> 对于 `1 <= i <= k` 时，每个<meta charset="UTF-8" /> `s<sub>i</sub>` 都在<meta charset="UTF-8" /> `wordList` 中。注意， `beginWord` 不需要在<meta charset="UTF-8" /> `wordList` 中。<meta charset="UTF-8" />
-  `s<sub>k</sub> == endWord` 
给你两个单词 `beginWord` 和 `endWord` 和一个字典 `wordList` ，返回 *从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目*** 。如果不存在这样的转换序列，返回 `0` 。


 **示例 1：** 

```

输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
输出：5
解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。

```
 **示例 2：** 

```

输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
输出：0
解释：endWord "cog" 不在字典中，所以无法进行转换。
```


 **提示：** 
-  `1 <= beginWord.length <= 10` 
-  `endWord.length == beginWord.length` 
-  `1 <= wordList.length <= 5000` 
-  `wordList[i].length == beginWord.length` 
-  `beginWord` 、 `endWord` 和 `wordList[i]` 由小写英文字母组成
-  `beginWord != endWord` 
-  `wordList` 中的所有字符串 **互不相同** 

**标签**
`广度优先搜索` `哈希表` `字符串` 


##### solution BFS
```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord not in wordList:
            return 0
        
        n = len(beginWord)
        d = collections.defaultdict(list)
        for word in [beginWord] + wordList:
            for i in range(n):
                midWord = word[:i] + "*" + word[i+1:]
                d[midWord].append(word)
        
        queue = collections.deque([(beginWord, 1)])
        visited = set()
        while queue:
            cur_len = len(queue)
            for _ in range(cur_len):
                word, level = queue.popleft()
                for i in range(n):
                    intermediate = word[:i] + "*" + word[i+1:]
                    if intermediate not in d:
                        continue
                    for nextWord in d[intermediate]:
                        if nextWord == endWord:
                            return level + 1
                        if nextWord not in visited:
                            visited.add(nextWord)
                            queue.append((nextWord, level + 1))
                    del d[intermediate]
        return 0
```
##### solution 双向BFS

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord not in wordList:
            return 0
        
        n = len(beginWord)
        d = collections.defaultdict(list)
        for word in [beginWord] + wordList:
            for i in range(n):
                midWord = word[:i] + "*" + word[i+1:]
                d[midWord].append(word)
        
        queue = collections.deque([beginWord])
        queue2 = collections.deque([endWord])
        visited = set([beginWord])
        visited2 = set([endWord])

        def update(queue, d, visited, visited2):
            cur_len = len(queue)
            for _ in range(cur_len):
                word = queue.popleft()
                for i in range(n):
                    intermediate = word[:i] + "*" + word[i+1:]
                    if intermediate not in d:
                        continue
                    for nextWord in d[intermediate]:
                        if nextWord in visited2:
                            return queue, d, visited, True
                        if nextWord not in visited:
                            visited.add(nextWord)
                            queue.append(nextWord)
                    del d[intermediate]
            return queue, d, visited, False

        level = 1
        while queue and queue2:
            level += 1
            if len(queue) <= len(queue2):
                queue, d, visited, is_find = update(queue, d, visited, visited2)
            else:
                queue2, d, visited2, is_find = update(queue2, d, visited2, visited)
            if is_find:
                return level
        return 0
```

>   

### 深度优先搜索

#### 79.单词搜索

[https://leetcode-cn.com/problems/word-search](https://leetcode-cn.com/problems/word-search) 

###### 原题

给定一个  `m x n` 二维字符网格  `board` 和一个字符串单词  `word` 。如果  `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" style="width: 322px; height: 242px;" />

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

```

 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" style="width: 322px; height: 242px;" />

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true

```

 **示例 3：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" style="width: 322px; height: 242px;" />

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false

```


 **提示：** 

-  `m == board.length` 
-  `n = board[i].length` 
-  `1 <= m, n <= 6` 
-  `1 <= word.length <= 15` 
-  `board` 和 `word` 仅由大小写英文字母组成


 **进阶：** 你可以使用搜索剪枝的技术来优化解决方案，使其在 `board` 更大的情况下可以更快解决问题？


**标签**
`数组` `回溯` `矩阵` 


##### solution

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        def dfs(i, j, idx):
            if idx == len(word) - 1:
                return True
            for di, dj in [(-1,0), (1,0), (0,1), (0,-1)]:
                x, y = i + di, j + dj
                if 0 <= x < m and 0 <= y < n and visited[x][y] == 0 and board[x][y] == word[idx+1]:
                    visited[x][y] = 1
                    if dfs(x, y, idx+1):
                        return True
                    visited[x][y] = 0
            return False

        m, n = len(board), len(board[0])
        visited = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if board[i][j] == word[0]:
                    visited[i][j] = 1
                    if dfs(i, j, 0):
                        return True
                    visited[i][j] = 0
        return False
```

>

#### 130.被围绕的区域

[https://leetcode-cn.com/problems/surrounded-regions](https://leetcode-cn.com/problems/surrounded-regions) 

###### 原题

给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` ，找到所有被 `'X'` 围绕的区域，并将这些区域里所有的  `'O'` 用 `'X'` 填充。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" style="width: 550px; height: 237px;" />

```
输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。

```

 **示例 2：** 

```
输入：board = [["X"]]
输出：[["X"]]

```


 **提示：** 

-  `m == board.length` 
-  `n == board[i].length` 
-  `1 <= m, n <= 200` 
-  `board[i][j]` 为 `'X'` 或 `'O'` 

**标签**
`深度优先搜索` `广度优先搜索` `并查集` `数组` `矩阵` 


##### solution

```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        def dfs(i, j):
            board[i][j] = "Y"
            for di, dj in [(0,1), (0,-1), (1,0), (-1,0)]:
                x, y = i + di, j +dj
                if 0 <= x < m and 0 <= y < n and not visited[x][y] and board[x][y] == "O":
                    dfs(x, y)

        m, n = len(board), len(board[0])
        visited = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in [0, n-1]:
                if visited[i][j] == 0 and board[i][j] == "O":
                    visited[i][j] = 1
                    dfs(i, j)
        for i in [0, m-1]:
            for j in range(1, n-1):
                if visited[i][j] == 0 and board[i][j] == "O":
                    visited[i][j] = 1
                    dfs(i, j)
        for i in range(m):
            for j in range(n):
                if board[i][j] == "O":
                    board[i][j] = "X"
                if board[i][j] == "Y":
                    board[i][j] = "O"
```

>

#### 200.岛屿的个数

[https://leetcode-cn.com/problems/number-of-islands](https://leetcode-cn.com/problems/number-of-islands) 

###### 原题

给你一个由  `'1'` （陆地）和 `'0'` （水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

 **示例 1：** 

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1

```

 **示例 2：** 

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3

```


 **提示：** 

-  `m == grid.length` 
-  `n == grid[i].length` 
-  `1 <= m, n <= 300` 
-  `grid[i][j]` 的值为 `'0'` 或 `'1'` 

**标签**
`深度优先搜索` `广度优先搜索` `并查集` `数组` `矩阵` 


##### solution

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def dfs(i, j):
            for di, dj in [(1,0), (-1,0), (0,1), (0,-1)]:
                x, y = i + di, j + dj
                if 0 <= x < m and 0 <= y < n and not visited[x][y] and grid[x][y] == "1":
                    visited[x][y] = True
                    dfs(x, y)
        
        m, n = len(grid), len(grid[0])
        visited = [[False] * n for _ in range(m)]
        res = 0
        for i in range(m):
            for j in range(n):
                if not visited[i][j] and grid[i][j] == "1":
                    visited[i][j] = True
                    dfs(i, j)
                    res += 1
        return res
```

>

#### 212.单词搜索-ii

[https://leetcode-cn.com/problems/word-search-ii](https://leetcode-cn.com/problems/word-search-ii) 

###### 原题

给定一个 `m x n` 二维字符网格 `board` **** 和一个单词（字符串）列表 `words` ， *返回所有二维网格上的单词* 。

单词必须按照字母顺序，通过 **相邻的单元格** 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" />

```
输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
输出：["eat","oath"]

```

 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" />

```
输入：board = [["a","b"],["c","d"]], words = ["abcb"]
输出：[]

```


 **提示：** 

-  `m == board.length` 
-  `n == board[i].length` 
-  `1 <= m, n <= 12` 
-  `board[i][j]` 是一个小写英文字母
-  `1 <= words.length <= 3 * 10^4` 
-  `1 <= words[i].length <= 10` 
-  `words[i]` 由小写英文字母组成
-  `words` 中的所有字符串互不相同

**标签**
`字典树` `数组` `字符串` `回溯` `矩阵` 


##### solution

```python
class Trie:
    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False
    
    def insert(self, word):
        node = self
        for c in word:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                node.children[idx] = Trie()
            node = node.children[idx]
        node.isEnd = True


class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        def dfs(i, j, path, node):
            if node.isEnd:
                res.add("".join(path[:]))
            for di, dj in [(0,1), (0,-1), (-1,0), (1,0)]:
                x, y = i + di, j + dj
                if 0 <= x < m and 0 <= y < n and not visited[x][y]:
                    idx = ord(board[x][y]) - ord('a')
                    if node.children[idx]:
                        visited[x][y] = True
                        dfs(x, y, path + [board[x][y]], node.children[idx])
                        visited[x][y] = False

        m, n = len(board), len(board[0])
        trie = Trie()
        first_char = set()
        for word in words:
            trie.insert(word)
            first_char.add(word[0])
        res = set()
        visited = [[False] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                idx = ord(board[i][j]) - ord('a')
                if board[i][j] in first_char and trie.children[idx]:
                        visited[i][j] = True
                        dfs(i, j, [board[i][j]], trie.children[idx])
                        visited[i][j] = False
        return list(res)
```

>

#### 329.矩阵中的最长递增路径

[https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix) 

###### 原题

给定一个  `m x n` 整数矩阵  `matrix` ，找出其中 **最长递增路径** 的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你 **不能** 在 **对角线** 方向上移动或移动到 **边界外** （即不允许环绕）。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg" style="width: 242px; height: 242px;" />

```
输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]
输出：4 
解释：最长递增路径为 [1, 2, 6, 9]。
```

 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg" style="width: 253px; height: 253px;" />

```
输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]
输出：4 
解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。

```

 **示例 3：** 

```
输入：matrix = [[1]]
输出：1

```


 **提示：** 

-  `m == matrix.length` 
-  `n == matrix[i].length` 
-  `1 <= m, n <= 200` 
-  `0 <= matrix[i][j] <= 2^31 - 1` 

**标签**
`深度优先搜索` `广度优先搜索` `图` `拓扑排序` `记忆化搜索` `动态规划` 

##### solution 记忆化dfs

-   因为一个位置`(i, j)`的最长递增路径的长度是固定的，所以可以保存到`mem`中，当另一个`(x,y)`指向`(i, j)`的时候，可以直接使用`mem[i][j]`的结果

```python
class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        def dfs(i, j):
            if mem[i][j] > 0:
                return mem[i][j]
            mem[i][j] += 1
            for di, dj in [(0,1), (0,-1), (-1,0), (1,0)]:
                x, y = i + di, j + dj
                if 0 <= x < m and 0 <= y < n and not visited[x][y] and matrix[x][y] > matrix[i][j]:
                    visited[i][j] = True
                    mem[i][j] = max(mem[i][j], 1 + dfs(x, y))
                    visited[i][j] = False
            return mem[i][j]
        
        m, n = len(matrix), len(matrix[0])
        mem = [[0] * n for _ in range(m)]
        visited = [[False] * n for _ in range(m)]
        res = 1
        for i in range(m):
            for j in range(n):
                visited[i][j] = True
                res = max(res, dfs(i, j))
                visited[i][j] = False
        return res
```

>

### 拓扑排序

#### 207.课程表
[https://leetcode-cn.com/problems/course-schedule](https://leetcode-cn.com/problems/course-schedule) 
###### 原题
你这个学期必须选修 `numCourses` 门课程，记为  `0`  到  `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组  `prerequisites` 给出，其中  `prerequisites[i] = [a_i, b_i]` ，表示如果要学习课程  `a_i` 则 **必须** 先学习课程  `b_i` 。
- 例如，先修课程对  `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。
请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

 

 **示例 1：** 

```

输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```
 **示例 2：** 

```

输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```


 **提示：** 
-  `1 <= numCourses <= 10^5` 
-  `0 <= prerequisites.length <= 5000` 
-  `prerequisites[i].length == 2` 
-  `0 <= a_i, b_i < numCourses` 
-  `prerequisites[i]` 中的所有课程对 **互不相同** 

**标签**
`深度优先搜索` `广度优先搜索` `图` `拓扑排序` 

https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/

##### solution1 BFS

-   统计课程安排图中每个节点的入度，生成 入度表 in_degrees。
-   借助一个队列 queue，将所有入度为 0 的节点入队。
-   当 queue 非空时，依次将队首节点出队，在课程安排图中删除此节点node：
    -   并不是真正从邻接表中删除此节点 node，而是将此节点对应所有邻接节点 next_node 的入度 −1，即 indegrees[next_node] -= 1。
    -   当入度 −1后邻接节点 next_node 的入度为 0，说明 next_node 所有的前驱节点已经被 “删除”，此时将 next_node 入队。
-   在每次 node 出队时，执行 node_cnt += 1；
    -   若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 0。
    -   因此，拓扑排序出队次数等于课程个数，返回 numCourses == node_cnt 判断课程是否可以成功安排。

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        if not prerequisites:
            return True
        
        in_degrees = [0] * numCourses
        adj = {i: [] for i in range(numCourses)}
        for ai, bi in prerequisites:
            adj[bi].append(ai)
            in_degrees[ai] += 1
        
        queue = collections.deque([])
        for i in range(numCourses):
            if in_degrees[i] == 0:
                queue.append(i)
        
        node_cnt = 0
        while queue:
            node = queue.popleft()
            for next_node in adj[node]:
                in_degrees[next_node] -= 1
                if in_degrees[next_node] == 0:
                    queue.append(next_node)
            node_cnt += 1
        return node_cnt == numCourses
```
##### solution2 DFS

-   借助一个标志列表 flags，用于判断每个节点 i （课程）的状态：
    -   未被 DFS 访问：i == 0；
    -   已被其他节点启动的 DFS 访问：i == -1；
    -   已被当前节点启动的 DFS 访问：i == 1。
-   对 numCourses 个节点依次执行 DFS，判断每个节点起步 DFS 是否存在环，若存在环直接返回 False。DFS 流程；
    -   终止条件：
        -   当 flag[i] == -1，说明当前访问节点已被其他节点启动的 DFS 访问，无需再重复搜索，直接返回 True。
        -   当 flag[i] == 1，说明在本轮 DFS 搜索中节点 i 被第 2 次访问，即 课程安排图有环 ，直接返回 False。
        -   将当前访问节点 i 对应 flag[i] 置 1，即标记其被本轮 DFS 访问过；
    -   递归访问当前节点 i 的所有邻接节点 j，当发现环直接返回 False；
    -   当前节点所有邻接节点已被遍历，并没有发现环，则将当前节点 flag 置为 −1 并返回 True。
    -   若整个图 DFS 结束并未发现环，返回 True。

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        if not prerequisites:
            return True

        def dfs(i, flags):
            if flags[i] == -1:
                return True
            if flags[i] == 1:
                return False
            flags[i] = 1
            for j in adj[i]:
                if not dfs(j, flags):
                    return False
            flags[i] = -1
            return True
        
        adj = {i: [] for i in range(numCourses)}
        for ai, bi in prerequisites:
            adj[bi].append(ai)
        flags = [0] * numCourses
        for i in range(numCourses):
            if not dfs(i, flags):
                return False
        return True
```

>   

### 并查集
#### 547.朋友圈
[https://leetcode-cn.com/problems/number-of-provinces](https://leetcode-cn.com/problems/number-of-provinces) 
###### 原题


有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。

 **省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。

返回矩阵中 **省份** 的数量。

 

 **示例 1：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0rzckv8ycj206603y3yc.jpg" style="width: 222px; height: 142px;" />

```

输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2

```
 **示例 2：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0rzclrb2vj206603ymwz.jpg" style="width: 222px; height: 142px;" />

```

输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
输出：3

```


 **提示：** 
-  `1 <= n <= 200` 
-  `n == isConnected.length` 
-  `n == isConnected[i].length` 
-  `isConnected[i][j]` 为 `1` 或 `0` 
-  `isConnected[i][i] == 1` 
-  `isConnected[i][j] == isConnected[j][i]` 

**标签**
`深度优先搜索` `广度优先搜索` `并查集` `图` 

##### solution1 DFS

```python
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        def dfs(i):
            if sum(visited) == n:
                return
            for j in range(n):
                if visited[j] == 0 and isConnected[i][j] == 1:
                    visited[j] = 1
                    dfs(j)

        n = len(isConnected)
        visited = [0] * n
        res = 0
        for i in range(n):
            if visited[i] == 0:
                visited[i] = 1
                dfs(i)
                res += 1
        return res
```



##### solution2 BFS

```python
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        n = len(isConnected)
        visited = [False] * n
        res = 0
        for i in range(n):
            if visited[i]:
                continue
            queue = collections.deque([i])
            while queue:
                node = queue.popleft()
                for next_node in range(n):
                    if isConnected[node][next_node] == 1 and not visited[next_node]:
                        visited[next_node] = 1
                        queue.append(next_node)
            res += 1
        return res
```



##### solution3 并查集

-   nodes = [0,1,2,3,4,5,6,7,8,9]，分为3个group，3-4-8-9，2-1-6-5-0和7
-   初始化parent = [0,1,2,3,4,5,6,7,8,9]，同一个group的node可以通过递归调用find，最后归为一个group索引
-   例如，以下述代码为例，遍历邻接矩阵右上角
    -   易知，邻接矩阵只有(0,5), (1,2), (1,6), (3,4), (4,8), (5,6), (8,9)
    -   (0,5)：union(0, 5) -> parent: [5, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    -   (1,2)：union(1, 2) -> parent: [5, 2, 2, 3, 4, 5, 6, 7, 8, 9]
    -   (1,6)：union(1, 6) -> parent: [5, 2, 6, 3, 4, 5, 6, 7, 8, 9]
    -   (3,4)：union(3, 4) -> parent: [5, 2, 6, 4, 4, 5, 6, 7, 8, 9]
    -   (4,8)：union(4, 8) -> parent: [5, 2, 6, 4, 8, 5, 6, 7, 8, 9] 
    -   (5,6)：union(5, 6) -> parent: [5, 2, 6, 4, 8, 6, 6, 7, 8, 9]
    -   (8,9)：union(8, 9) -> parent: [5, 2, 6, 4, 8, 6, 6, 7, 9, 9]

```python
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        def find(i):
            if parent[i] != i:
                parent[i] = find(parent[i])
            return parent[i]
        
        def union(i, j):
            parent[find(i)] = find(j)

        n = len(isConnected)
        parent = list(range(n))
        for i in range(n):
            for j in range(i+1, n):
                if isConnected[i][j] == 1:
                    union(i, j)
        return sum([parent[i] == i for i in range(n)])
```
>
#### 684.冗余连接
[https://leetcode-cn.com/problems/redundant-connection](https://leetcode-cn.com/problems/redundant-connection) 
###### 原题
树可以看成是一个连通且 **无环 ** 的  **无向 ** 图。

给定往一棵  `n` 个节点 (节点值  `1～n` ) 的树中添加一条边后的图。添加的边的两个顶点包含在 `1` 到 `n`  中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges`  ， `edges[i] = [a_i, b_i]`  表示图中在 `ai` 和 `bi` 之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组  `edges`  中最后出现的边。

 

 **示例 1：** 

<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0rzcrw42xj20660660sm.jpg" style="width: 152px; " />

```

输入: edges = [[1,2], [1,3], [2,3]]
输出: [2,3]

```
 **示例 2：** 

<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0rzct8u85j20am066jrc.jpg" style="width: 250px; " />

```

输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]

```


 **提示:** 
-  `n == edges.length` 
-  `3 <= n <= 1000` 
-  `edges[i].length == 2` 
-  `1 <= ai < bi <= edges.length` 
-  `ai != bi` 
-  `edges` 中无重复元素
- 给定的图是连通的 

**标签**
`深度优先搜索` `广度优先搜索` `并查集` `图` 


##### solution
```python
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        def find(i):
            if parent[i] != i:
                parent[i] = find(parent[i])
            return parent[i]
        
        def union(i, j):
            parent[find(i)] = find(j)
        
        n = len(edges)
        parent = list(range(n+1))
        for i, j in edges:
            if find(i) == find(j):
                return [i, j]
            union(i, j)
        return []
```
>
## 7堆
#### 23.合并k个排序链表
[https://leetcode-cn.com/problems/merge-k-sorted-lists](https://leetcode-cn.com/problems/merge-k-sorted-lists) 
##### 原题
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

 

 **示例 1：** 

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6

```
 **示例 2：** 

```
输入：lists = []
输出：[]

```
 **示例 3：** 

```
输入：lists = [[]]
输出：[]

```


 **提示：** 
-  `k == lists.length` 
-  `0 <= k <= 10^4` 
-  `0 <= lists[i].length <= 500` 
-  `-10^4 <= lists[i][j] <= 10^4` 
-  `lists[i]` 按 **升序** 排列
-  `lists[i].length` 的总和不超过 `10^4` 

**标签**
`链表` `分治` `堆（优先队列）` `归并排序` 


##### solution
```python
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        heap = []
        for i, lst in enumerate(lists):
            if not lst:
                continue
            heapq.heappush(heap, (lst.val, i))
        
        dummy = ListNode(-1)
        p = dummy
        while heap:
            _, i = heapq.heappop(heap)
            p.next = lists[i]
            p = p.next
            if lists[i].next:
                lists[i] = lists[i].next
                heapq.heappush(heap, (lists[i].val, i))

        return dummy.next
```
>
#### 295.数据流的中位数
[https://leetcode-cn.com/problems/find-median-from-data-stream](https://leetcode-cn.com/problems/find-median-from-data-stream) 
##### 原题
中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：
- void addNum(int num) - 从数据流中添加一个整数到数据结构中。
- double findMedian() - 返回目前所有元素的中位数。
 **示例：** 

```
addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2
```
 **进阶:** 
- 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？
- 如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？

**标签**
`设计` `双指针` `数据流` `排序` `堆（优先队列）` 

##### solution

-   维护两个堆，heap_min为大根堆，保存小于等于中位数的数；heap_max为小根堆，保存大于等于中位数的数
-   总数量为奇数时，heap_min比heap_max多一个数，中位数为heap_min的头节点
-   总数量为偶数时，heap_min和heap_max个数相等，中位数为heap_min和heap_max头节点的平均值

```python
class MedianFinder:

    def __init__(self):
        self.heap_min = []
        self.heap_max = []

    def addNum(self, num: int) -> None:
        heap_min, heap_max = self.heap_min, self.heap_max
        if not heap_min or num <= -heap_min[0]:
            heapq.heappush(heap_min, -num)
            if len(heap_max) + 1 < len(heap_min):
                heapq.heappush(heap_max, -heapq.heappop(heap_min))
        else:
            heapq.heappush(heap_max, num)
            if len(heap_max) > len(heap_min):
                heapq.heappush(heap_min, -heapq.heappop(heap_max))

    def findMedian(self) -> float:
        heap_min, heap_max = self.heap_min, self.heap_max
        if len(heap_max) == len(heap_min):
            return 0.5 * (heap_max[0] - heap_min[0])
        else:
            return -heap_min[0]
```
>
## 9字典树
#### 208.实现-trie-前缀树
[https://leetcode-cn.com/problems/implement-trie-prefix-tree](https://leetcode-cn.com/problems/implement-trie-prefix-tree) 
##### 原题
 **<a href="https://baike.baidu.com/item/字典树/9825209?fr=aladdin" target="_blank">Trie</a>** （发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：
-  `Trie()` 初始化前缀树对象。
-  `void insert(String word)` 向前缀树中插入字符串 `word` 。
-  `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true` （即，在检索之前已经插入）；否则，返回 `false` 。
-  `boolean startsWith(String prefix)` 如果之前已经插入的字符串  `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。


 **示例：** 

```

输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True

```


 **提示：** 
-  `1 <= word.length, prefix.length <= 2000` 
-  `word` 和 `prefix` 仅由小写英文字母组成
-  `insert` 、 `search` 和 `startsWith` 调用次数 **总计** 不超过 `3 * 10^4` 次

**标签**
`设计` `字典树` `哈希表` `字符串` 


##### solution1 依赖TrieNode实现，设计更合理
```python
class TrieNode:

    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False


class Trie:

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        node = self.root
        for c in word:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                node.children[idx] = TrieNode()
            node = node.children[idx]
        node.isEnd = True

    def search(self, word: str) -> bool:
        node = self.root
        for c in word:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                return False
            node = node.children[idx]
        return node.isEnd

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for c in prefix:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                return False
            node = node.children[idx]
        return True
```
##### solution2 Trie本身实现

```python
class Trie:

    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False

    def insert(self, word: str) -> None:
        node = self
        for c in word:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                node.children[idx] = Trie()
            node = node.children[idx]
        node.isEnd = True

    def search(self, word: str) -> bool:
        node = self
        for c in word:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                return False
            node = node.children[idx]
        return node.isEnd

    def startsWith(self, prefix: str) -> bool:
        node = self
        for c in prefix:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                return False
            node = node.children[idx]
        return True
```



#### 648.单词替换
[https://leetcode-cn.com/problems/replace-words](https://leetcode-cn.com/problems/replace-words) 
##### 原题
在英语中，我们有一个叫做 `词根` (root) 的概念，可以词根 **后面** 添加其他一些词组成另一个较长的单词——我们称这个词为 `继承词` (successor)。例如，词根 `an` ，跟随着单词 `other` (其他)，可以形成新的单词 `another` (另一个)。

现在，给定一个由许多 **词根** 组成的词典 `dictionary` 和一个用空格分隔单词形成的句子 `sentence` 。你需要将句子中的所有 **继承词** 用 **词根** 替换掉。如果 **继承词** 有许多可以形成它的 **词根** ，则用 **最短** 的词根替换它。

你需要输出替换之后的句子。

 

 **示例 1：** 

```

输入：dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"
输出："the cat was rat by the bat"

```
 **示例 2：** 

```

输入：dictionary = ["a","b","c"], sentence = "aadsfasf absbs bbab cadsfafs"
输出："a a b c"

```


 **提示：** 
-  `1 <= dictionary.length <= 1000` 
-  `1 <= dictionary[i].length <= 100` 
-  `dictionary[i]` 仅由小写字母组成。
-  `1 <= sentence.length <= 10^6` 
-  `sentence` 仅由小写字母和空格组成。
-  `sentence` 中单词的总量在范围 `[1, 1000]` 内。
-  `sentence` 中每个单词的长度在范围 `[1, 1000]` 内。
-  `sentence` 中单词之间由一个空格隔开。
-  `sentence` 没有前导或尾随空格。



**标签**
`字典树` `数组` `哈希表` `字符串` 


##### solution
```python
class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False


class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        node = self.root
        for c in word:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                node.children[idx] = TrieNode()
            node = node.children[idx]
        node.isEnd = True
    
    def searchRoot(self, word):
        node = self.root
        wordRoot = ""
        for c in word:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                return word
            node = node.children[idx]
            wordRoot += c
            if node.isEnd:
                return wordRoot
        return word


class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        t = Trie()
        for wordRoot in dictionary:
            t.insert(wordRoot)
        res = []
        for word in sentence.split(" "):
            res.append(t.searchRoot(word))
        return " ".join(res)
```
>
#### 677.键值映射
[https://leetcode-cn.com/problems/map-sum-pairs](https://leetcode-cn.com/problems/map-sum-pairs) 
##### 原题
设计一个 map ，满足以下几点:
- 字符串表示键，整数表示值
- 返回具有前缀等于给定字符串的键的值的总和
实现一个 `MapSum` 类：
-  `MapSum()` 初始化 `MapSum` 对象
-  `void insert(String key, int val)` 插入 `key-val` 键值对，字符串表示键 `key` ，整数表示值 `val` 。如果键 `key` 已经存在，那么原来的键值对 `key-value` 将被替代成新的键值对。
-  `int sum(string prefix)` 返回所有以该前缀 `prefix` 开头的键 `key` 的值的总和。


 **示例 1：** 

```

输入：
["MapSum", "insert", "sum", "insert", "sum"]
[[], ["apple", 3], ["ap"], ["app", 2], ["ap"]]
输出：
[null, null, 3, null, 5]

解释：
MapSum mapSum = new MapSum();
mapSum.insert("apple", 3);  
mapSum.sum("ap");           // 返回 3 (apple = 3)
mapSum.insert("app", 2);    
mapSum.sum("ap");           // 返回 5 (apple + app = 3 + 2 = 5)

```


 **提示：** 
-  `1 <= key.length, prefix.length <= 50` 
-  `key` 和 `prefix` 仅由小写英文字母组成
-  `1 <= val <= 1000` 
- 最多调用 `50` 次 `insert` 和 `sum` 

**标签**
`设计` `字典树` `哈希表` `字符串` 


##### solution
```python
class MapSum:

    def __init__(self):
        self.children = [None] * 26
        self.val = 0
        self.isEnd = False

    def insert(self, key: str, val: int) -> None:
        node = self
        for c in key:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                node.children[idx] = MapSum()
            node = node.children[idx]
        node.val = val
        node.isEnd = True

    def sum(self, prefix: str) -> int:
        res = 0
        node = self
        for c in prefix:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                return res
            node = node.children[idx]
        queue = collections.deque([node])
        while queue:
            node = queue.popleft()
            if node.isEnd:
                res += node.val
            for child_node in node.children:
                if child_node:
                    queue.append(child_node)
        return res
```
>

#### 720.词典中最长的单词

[https://leetcode-cn.com/problems/longest-word-in-dictionary](https://leetcode-cn.com/problems/longest-word-in-dictionary) 

##### 原题

给出一个字符串数组 `words` 组成的一本英语词典。返回 `words` 中最长的一个单词，该单词是由 `words` 词典中其他单词逐步添加一个字母组成。

若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。

 

 **示例 1：** 

```
输入：words = ["w","wo","wor","worl", "world"]
输出："world"
解释： 单词"world"可由"w", "wo", "wor", 和 "worl"逐步添加一个字母组成。

```

 **示例 2：** 

```
输入：words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
输出："apple"
解释："apply" 和 "apple" 都能由词典中的单词组成。但是 "apple" 的字典序小于 "apply" 

```


 **提示：** 

-  `1 <= words.length <= 1000` 
-  `1 <= words[i].length <= 30` 
-  所有输入的字符串 `words[i]` 都只包含小写字母。

**标签**
`字典树` `数组` `哈希表` `字符串` `排序` 

##### solution1 哈希集合

```python
class Solution:
    def longestWord(self, words: List[str]) -> str:
        words.sort(key=lambda x: (-len(x), x), reverse=True)
        d = set([""])
        res = ""
        for w in words:
            if w[:-1] in d:
                d.add(w)
                res = w
        return res
```

##### solution2 字典树

```python
class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False


class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        node = self.root
        for c in word:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                node.children[idx] = TrieNode()
            node = node.children[idx]
        node.isEnd = True
    
    def searchWord(self, word):
        node = self.root
        for c in word:
            idx = ord(c) - ord('a')
            if not node.children[idx] or not node.children[idx].isEnd:
                return False
            node = node.children[idx]
        return True

class Solution:
    def longestWord(self, words: List[str]) -> str:
        t = Trie()
        for w in words:
            t.insert(w)
        longest = ""
        for w in words:
            if t.searchWord(w) and (len(w) > len(longest) or (len(w) == len(longest) and w < longest)):
                longest = w
        return longest
```

> 

