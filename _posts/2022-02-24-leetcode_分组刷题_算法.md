---
layout:     post   				    # 使用的布局（不需要改）
title:      leetcode-分组刷题-算法				# 标题 
subtitle:    #副标题
date:       2022-02-24 				# 时间
author:     FishRedLeaf 						# 作者
header-img: iu_img/my_iu_10.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - DSA与刷题/leetcode
---

[toc]

# 分组刷题-算法

## 1二分查找

https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/

#### 我的模板

##### general

```python
def general(nums, target):
    if not nums:
        return -1
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + ((right - left) >> 1)
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

##### 查找第一个

```python
def left_bound(nums, target):
    if not nums:
        return -1
    left, right = 0, len(nums) - 1
    ans = -1
    while left <= right:
        mid = left + ((right - left) >> 1)
        if nums[mid] == target:
            right = mid - 1
            ans = mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return ans
```

##### 查找最后一个

```python
def right_bound(nums, target):
    if not nums:
        return -1
    left, right = 0, len(nums) - 1
    ans = -1
    while left <= right:
        mid = left + ((right - left) >> 1)
        if nums[mid] == target:
            left = mid + 1
            ans = mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return ans
```



#### B站大雪菜的模板

https://www.bilibili.com/video/BV1Ft41157zW?spm_id_from=333.999.0.0

力扣也有人整理了下https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/tu-jie-er-fen-zui-qing-xi-yi-dong-de-jia-ddvc/

##### 版本1

当我们将区间`[l, r]`分成`[l, mid]`和`[mid+1, r]`时，其更新操作是`r = mid`或者`l = mid + 1`，计算mid时不需要加1，即`mid = (l + r)/2`。

```python
def binary_search(l, r):
    while l < r:
        mid = l + ((r - l) >> 1)
        if check(mid):
            r = mid
        else:
            l = mid + 1
    return l
```

##### 版本2

当我们将区间`[l, r]`分成`[l, mid-1]`和`[mid, r]`时，其更新操作是`r = mid - 1`或者`l = mid`，此时为了防止死循环，计算mid时需要加1，即`mid = (l + r + 1)/2`。

```python
def binary_search(l, r):
    while l < r:
        mid = l + ((1 + r - l) >> 1)
        if check(mid):
            l = mid
        else:
            r = mid - 1
    return l
```



<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0umzaj2umj20u00vfq5c.jpg" alt="image-20220401232634542" style="zoom: 50%;" />



#### 4.寻找两个有序数组的中位数
[https://leetcode-cn.com/problems/median-of-two-sorted-arrays](https://leetcode-cn.com/problems/median-of-two-sorted-arrays) 
##### 原题
给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2` 。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

 

 **示例 1：** 

```

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2

```
 **示例 2：** 

```

输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5

```




 **提示：** 
-  `nums1.length == m` 
-  `nums2.length == n` 
-  `0 <= m <= 1000` 
-  `0 <= n <= 1000` 
-  `1 <= m + n <= 2000` 
-  `-10^6 <= nums1[i], nums2[i] <= 10^6` 

**标签**
`数组` `二分查找` `分治` 

##### solution

-   转成求A和B数组中第k小的数，然后用k/2在A和B中分别找。
-   比如k = 6, 分别看A和B中的第3个数, 已知 A1 < A2 < A3 < A4 < A5... 和 B1 < B2 < B3 < B4 < B5..., 
    -   如果A3 <＝ B3, 那么第6小的数肯定不会是A1, A2, A3, 因为最多有两个数(B1和B2)小于A1, 三个数(B1和B2, A1)小于A2, 四个数(B1和B2, A1和A2)小于A3。
    -   B3至少大于5个数, 所以第6小的数有可能是B1 (A1 < A2 < A3 < A4 < A5 < B1), 有可能是B2 (A1 < A2 < A3 < B1 < A4 < B2), 有可能是B3 (A1 < A2 < A3 < B1 < B2 < B3)。那就可以排除掉A1, A2, A3, 转成求A4, A5, ... B1, B2, B3, ...这些数中第3小的数的问题, k就被减半了。
    -   每次都假设A的元素个数少, pa = min(k/2, lenA)的结果可能导致k == 1或A空, 这两种情况都是终止条件。 
-   整理自http://chaoren.is-programmer.com/posts/42890.html，http://yucoding.blogspot.com/2013/01/leetcode-question-50-median-of-two.html

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        def findMinK(nums1, nums2, k):
            if len(nums1) > len(nums2):
                return findMinK(nums2, nums1, k)
            l1, l2 = len(nums1), len(nums2)
            if l1 == 0:
                return nums2[k-1]
            if k == 1:
                return min(nums1[0], nums2[0])
            pa = min(k // 2, l1)
            pb = k - pa
            return findMinK(nums1[pa:], nums2, k-pa) if nums1[pa-1] <= nums2[pb-1] else findMinK(nums1, nums2[pb:], k-pb)
        
        l1, l2 = len(nums1), len(nums2)
        if (l1 + l2) % 2 == 1:
            return findMinK(nums1, nums2, (l1 + l2) // 2 + 1)
        else:
            return 0.5 * (findMinK(nums1, nums2, (l1 + l2) // 2 + 1) + findMinK(nums1, nums2, (l1 + l2) // 2))
```
>
#### 33.搜索旋转排序数组
[https://leetcode-cn.com/problems/search-in-rotated-sorted-array](https://leetcode-cn.com/problems/search-in-rotated-sorted-array) 
##### 原题
整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前， `nums` 在预先未知的某个下标 `k` （ `0 <= k < nums.length` ）上进行了 **旋转** ，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` （下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为  `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回  `-1`  。

 

 **示例 1：** 

```

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4

```
 **示例 2：** 

```

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```
 **示例 3：** 

```

输入：nums = [1], target = 0
输出：-1

```


 **提示：** 
-  `1 <= nums.length <= 5000` 
-  `-10^4 <= nums[i] <= 10^4` 
-  `nums` 中的每个值都 **独一无二** 
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
-  `-10^4 <= target <= 10^4` 


 **进阶：** 你可以设计一个时间复杂度为 `O(log n)` 的解决方案吗？


**标签**
`数组` `二分查找` 

##### solution

-   数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的
-   以左边有序为例，右边有序同理
    -   如果target在左边，因为左边是有序的，因此可以通过判断target是否落在nums[l]和nums[mid]直接快速确定，那么可以确定新的右边界；
    -   否则target落在无序的右边，可以更新左边界

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        n = len(nums)
        l, r = 0, n - 1
        while l <= r:
            mid = l + ((r - l) >> 1)
            if nums[mid] == target:
                return mid
            elif nums[l] <= nums[mid]:
                if nums[l] <= target < nums[mid]:
                    r = mid - 1
                else:
                    l = mid + 1
            else:  # target <= nums[r]
                if nums[mid] < target <= nums[r]:
                    l = mid + 1
                else:
                    r = mid - 1
        return -1
```
>
#### 34.在排序数组中查找元素的第一个和最后一个位置
[https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array) 
##### 原题
给定一个按照升序排列的整数数组 `nums` ，和一个目标值 `target` 。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target` ，返回  `[-1, -1]` 。

 **进阶：** 
- 你可以设计并实现时间复杂度为  `O(log n)`  的算法解决此问题吗？


 **示例 1：** 

```

输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```
 **示例 2：** 

```

输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```
 **示例 3：** 

```

输入：nums = [], target = 0
输出：[-1,-1]
```


 **提示：** 
-  `0 <= nums.length <= 10^5` 
-  `-10^9 <= nums[i] <= 10^9` 
-  `nums`  是一个非递减数组
-  `-10^9 <= target <= 10^9` 

**标签**
`数组` `二分查找` 

##### solution1 寻找第一个大于target-1的数和第一个大于target的数

-   `find_bigger_than_k(nums, k)`用于找到第一个比k大的数
-   由于可能找不到比k大的数，所以ans默认值设置为nums长度，这样`right_idx = len(nums) - 1`，如果发现最后一个数等于target的话，那么说明right_idx就表示最后一个等于target的数的索引

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def find_bigger_than_k(nums, k):
            l, r = 0, len(nums) - 1
            ans = len(nums)
            while l <= r:
                mid = l + ((r - l) >> 1)
                if nums[mid] > k:
                    r = mid - 1
                    ans = mid
                else:
                    l = mid + 1
            return ans
        
        left_idx = find_bigger_than_k(nums, target - 1)
        right_idx = find_bigger_than_k(nums, target) - 1
        if left_idx <= right_idx and right_idx < len(nums) and nums[left_idx] == target and nums[right_idx] == target:
            return [left_idx, right_idx]
        return [-1, -1]
```

##### solution2 相等时也收缩

-   查找第一个数：找到target时，继续收缩右边界
-   查找最后一个数：找到target时，继续收缩左边界

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def left_bound(nums, target):
            if not nums:
                return -1
            left, right = 0, len(nums) - 1
            ans = -1
            while left <= right:
                mid = left + ((right - left) >> 1)
                if nums[mid] == target:
                    right = mid - 1
                    ans = mid
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    right = mid - 1
            return ans
        
        def right_bound(nums, target):
            if not nums:
                return -1
            left, right = 0, len(nums) - 1
            ans = -1
            while left <= right:
                mid = left + ((right - left) >> 1)
                if nums[mid] == target:
                    left = mid + 1
                    ans = mid
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    right = mid - 1
            return ans
        
        l, r = left_bound(nums, target), right_bound(nums, target)
        return [l, r]
```



##### solution3 判断是否已经是第一个或者最后一个

-   solution2和3本质上是同样的思路

-   `nums[mid] == target`时如果确定搜索区间都搜完了，或者`nums[mid] != nums[mid-1]`，那么可以返回mid

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        res = []
        n = len(nums)
        l, r = 0, n - 1
        while l <= r:
            mid = l + ((r - l) >> 1)
            if nums[mid] == target and (mid == 0 or nums[mid] != nums[mid-1]):
                res.append(mid)
                break
            elif nums[mid] < target:
                l = mid + 1
            else:
                r = mid - 1
        if not res:
            return [-1, -1]
        
        l, r = res[0], n - 1
        while l <= r:
            mid = l + ((r - l) >> 1)
            if nums[mid] == target and (mid == n - 1 or nums[mid] != nums[mid+1]):
                res.append(mid)
                break
            elif nums[mid] > target:
                r = mid - 1
            else:
                l = mid + 1
        return res
```
>
#### 69.x-的平方根
[https://leetcode-cn.com/problems/sqrtx](https://leetcode-cn.com/problems/sqrtx) 
##### 原题
给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。** 

 **注意：** 不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

 

 **示例 1：** 

```

输入：x = 4
输出：2

```
 **示例 2：** 

```

输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。

```


 **提示：** 
-  `0 <= x <= 2^31 - 1` 

**标签**
`数学` `二分查找` 


##### solution
```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x == 0:
            return 0
        l, r = 1, x
        while l <= r:
            mid = l + ((r - l) >> 1)
            mid_square = mid * mid
            if mid_square == x:
                return mid
            elif mid_square < x:
                if (mid + 1) * (mid + 1) > x:
                    return mid
                else:
                    l = mid + 1
            else:
                if (mid - 1) * (mid - 1) < x:
                    return mid - 1
                else:
                    r = mid - 1
        return l
```
>
#### 81.搜索旋转排序数组-ii
[https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii) 
##### 原题
已知存在一个按非降序排列的整数数组 `nums` ，数组中的值不必互不相同。

在传递给函数之前， `nums` 在预先未知的某个下标 `k` （ `0 <= k < nums.length` ）上进行了 **旋转** ，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` （下标 **从 0 开始** 计数）。例如， `[0,1,2,4,4,4,5,6,6,7]` 在下标 `5` 处经旋转后可能变为 `[4,5,6,6,7,0,1,2,4,4]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 `nums` 中存在这个目标值 `target` ，则返回 `true` ，否则返回 `false` 。

你必须尽可能减少整个操作步骤。

 

 **示例 1：** 

```

输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true

```
 **示例 2：** 

```

输入：nums = [2,5,6,0,0,1,2], target = 3
输出：false
```


 **提示：** 
-  `1 <= nums.length <= 5000` 
-  `-10^4 <= nums[i] <= 10^4` 
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
-  `-10^4 <= target <= 10^4` 


 **进阶：** 
- 这是 <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/">搜索旋转排序数组</a> 的延伸题目，本题中的 `nums` 可能包含重复元素。
- 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？



**标签**
`数组` `二分查找` 

##### solution

-   对于数组中有重复元素的情况，二分查找时可能会有 `nums[l] = nums[mid] = nums[r]`，此时无法判断区间`[l, mid]`和区间`[mid+1, r]`哪个是有序的。
-   例如`nums = [3,1,2,3,3,3,3], target = 2`，首次二分时无法判断区间`[0, 3]`和区间`[4, 6]`哪个是有序的。对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。

```python
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        n = len(nums)
        l, r = 0, n - 1
        while l <= r:
            mid = l + ((r - l) >> 1)
            if nums[mid] == target:
                return True
            if nums[l] == nums[mid] == nums[r]:
                l += 1
                r -= 1
            elif nums[l] <= nums[mid]:
                if nums[l] <= target < nums[mid]:
                    r = mid - 1
                else:
                    l = mid + 1
            else:  # target <= nums[r]
                if nums[mid] < target <= nums[r]:
                    l = mid + 1
                else:
                    r = mid - 1
        return False
```
>
#### 153.寻找旋转排序数组中的最小值
[https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array) 
##### 原题
已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]` 
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]` 
注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

 

 **示例 1：** 

```

输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。

```
 **示例 2：** 

```

输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。

```
 **示例 3：** 

```

输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。

```


 **提示：** 
-  `n == nums.length` 
-  `1 <= n <= 5000` 
-  `-5000 <= nums[i] <= 5000` 
-  `nums` 中的所有整数 **互不相同** 
-  `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转

**标签**
`数组` `二分查找` 

##### solution

-   对于`[l, r - 1]`区间的数，要么大于`nums[r]`，要么小于`nums[r]`
    -   如果`nums[mid] > nums[r]`，说明`[l, mid]`是升序的，最小值在`[mid + 1, r]`
    -   如果`nums[mid] < nums[r]`，说明`[mid, r]`是升序的，最小值在`[l, mid]`
    -   因为`nums`中数互不相同，因此只有上述两种情况

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l < r:
            mid = l + ((r - l) >> 1)
            if nums[mid] > nums[r]:
                l = mid + 1
            else:
                r = mid
        return nums[l]
```
>
#### 154.寻找旋转排序数组中的最小值-ii
[https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii) 
##### 原题
已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,4,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,4]` 
- 若旋转 `7` 次，则可以得到 `[0,1,4,4,5,6,7]` 
注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个可能存在 **重复** 元素值的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

 

 **示例 1：** 

```

输入：nums = [1,3,5]
输出：1

```
 **示例 2：** 

```

输入：nums = [2,2,2,0,1]
输出：0

```


 **提示：** 
-  `n == nums.length` 
-  `1 <= n <= 5000` 
-  `-5000 <= nums[i] <= 5000` 
-  `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转


 **进阶：** 
- 这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/">寻找旋转排序数组中的最小值</a> 的延伸题目。
- 允许重复会影响算法的时间复杂度吗？会如何影响，为什么？

**标签**
`数组` `二分查找` 

##### solution

对于`[l, r - 1]`区间的数，要么大于`nums[r]`，要么小于`nums[r]`，要么等于`nums[r]`

-   如果`nums[mid] > nums[r]`，说明`[l, mid]`是升序的，最小值在`[mid + 1, r]`
-   如果`nums[mid] < nums[r]`，说明`[mid, r]`是升序的，最小值在`[l, mid]`
-   如果`nums[mid] = nums[r]`，最小值可能在`[l, mid]`或者`[mid, r]`，无论`nums[r]`是不是最小值，都有一个它的替代品`nums[mid]`，因此可以忽略右端点

<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0upn0zr5qj21jk0pdwg0.jpg" alt="fig4" style="zoom:48%;" />

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l < r:
            mid = l + ((r - l) >> 1)
            if nums[mid] > nums[r]:
                l = mid + 1
            elif nums[mid] < nums[r]:
                r = mid
            else:
                r -= 1
        return nums[l]
```
>
#### 162.寻找峰值
[https://leetcode-cn.com/problems/find-peak-element](https://leetcode-cn.com/problems/find-peak-element) 
##### 原题
峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums` ，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。

 

 **示例 1：** 

```

输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
```
 **示例 2：** 

```

输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。

```


 **提示：** 
-  `1 <= nums.length <= 1000` 
-  `-2^31 <= nums[i] <= 2^31 - 1` 
- 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]` 

**标签**
`数组` `二分查找` 

##### solution

-   mid和左边的mid-1，右边的mid+1，组成的趋势有四种情况
    -   上升：`nums[mid - 1] < nums[mid] < nums[mid + 1]`，搜索区间更新为`[mid + 1, r]`
    -   下降：`nums[mid - 1] > nums[mid] > nums[mid + 1]`，搜索区间更新为`[l, mid - 1]`
    -   峰：`nums[mid - 1] < nums[mid] > nums[mid + 1]`，找到一个可行解
    -   谷：`nums[mid - 1] > nums[mid] < nums[mid + 1]`，搜索区间可以更新为`[mid + 1, r]`，也可以更新为`[l, mid - 1]`
    -   想找峰值就往相对于当前mid位置高的地方移动

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        def get_val(i):
            if i == -1 or i == n:
                return float('-inf')
            return nums[i]
        
        n = len(nums)
        l, r = 0, n - 1
        while l <= r:
            mid = l + ((r - l) >> 1)
            if get_val(mid - 1) < nums[mid] > get_val(mid + 1):
                return mid
            elif nums[mid] < get_val(mid + 1):
                l = mid + 1
            else:
                r = mid - 1
        return -1
```
>
## 2排序
#### 75.颜色分类
[https://leetcode-cn.com/problems/sort-colors](https://leetcode-cn.com/problems/sort-colors) 
##### 原题
给定一个包含红色、白色和蓝色、共 `n` 个元素的数组<meta charset="UTF-8" /> `nums` ， **<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank">原地</a>** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0` 、 `1` 和 `2` 分别表示红色、白色和蓝色。
必须在不使用库的sort函数的情况下解决这个问题。

 

 **示例 1：** 

```

输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]

```
 **示例 2：** 

```

输入：nums = [2,0,1]
输出：[0,1,2]

```


 **提示：** 
-  `n == nums.length` 
-  `1 <= n <= 300` 
-  `nums[i]` 为 `0` 、 `1` 或 `2` 


 **进阶：** 
- 你可以不使用代码库中的排序函数来解决这道题吗？
- 你能想出一个仅使用常数空间的一趟扫描算法吗？

**标签**
`数组` `双指针` `排序` 


##### solution
```python
#
# @lc app=leetcode.cn id=75 lang=python3
#
# [75] 颜色分类
#
class Solution:
    # 双指针
    def sortColors(self, nums: List[int]) -> None:
        zero_idx, two_idx = 0, len(nums)-1
        i = 0
        while i <= two_idx:
            if nums[i] == 0:
                nums[zero_idx], nums[i] = nums[i], nums[zero_idx]
                zero_idx += 1
                i += 1
            elif nums[i] == 2:
                nums[two_idx], nums[i] = nums[i], nums[two_idx]
                two_idx -= 1
            else:
                i += 1
    # # 计数排序
    # def sortColors(self, nums: List[int]) -> None:
    #     """
    #     Do not return anything, modify nums in-place instead.
    #     """
    #     d = {}
    #     for n in nums:
    #         d[n] = d.get(n, 0) + 1
    #     a, b, c = (d.get(i, 0) for i in (0,1,2))
    #     nums[:a] = [0] * a
    #     nums[a:a+b] = [1] * b
    #     nums[a+b:] = [2] * c
```
>
#### 148.排序链表
[https://leetcode-cn.com/problems/sort-list](https://leetcode-cn.com/problems/sort-list) 
##### 原题
给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" style="width: 450px;" />
```

输入：head = [4,2,1,3]
输出：[1,2,3,4]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" style="width: 550px;" />
```

输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]

```
 **示例 3：** 

```

输入：head = []
输出：[]

```


<b>提示：</b>
- 链表中节点的数目在范围 `[0, 5 * 10^4]` 内
-  `-10^5 <= Node.val <= 10^5` 


<b>进阶：</b>你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？


**标签**
`链表` `双指针` `分治` `排序` `归并排序` 


##### solution
```python
#
# @lc app=leetcode.cn id=148 lang=python3
#
# [148] 排序链表
#
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
# 归并排序 55.01%
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        mid = self.getMid(head)
        l1 = head
        l2 = mid.next
        mid.next = None
        l1 = self.sortList(l1)
        l2 = self.sortList(l2)
        return self.merge(l1, l2)
    def merge(self, l1, l2):
        if not l1:
            return l2
        if not l2:
            return l1
        dummy = ListNode(-1)
        cur = dummy
        while l1 and l2:
            if l1.val < l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next
        if l1:
            cur.next = l1
        if l2:
            cur.next = l2
        return dummy.next
    def getMid(self, head):
        if not head or not head.next:
            return None
        slow, fast = head, head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
        return slow
# # 快排两种实现， 都超时
# class Solution:
#     def sortList(self, head: ListNode) -> ListNode:
#         if not head or not head.next:
#             return head
#         self.sort_helper(head, None)
#         return head
#     def sort_helper(self, start, end):
#         if start != end:
#             mid = self.partition(start, end)
#             self.sort_helper(start, mid)
#             self.sort_helper(mid.next, end)
#     def partition(self, start, end):
#         pv = start.val
#         i, j = start, start.next
#         while j != end:
#             if j.val < pv:
#                 i = i.next
#                 i.val, j.val = j.val, i.val
#             j = j.next
#         start.val, i.val = i.val, start.val
#         return i
# class Solution:
#     def sortList(self, head: ListNode) -> ListNode:
#         if not head:
#             return head
#         end = head
#         while end.next:
#             end = end.next
#         self.quickSort(head, end)
#         return head
#     def quickSort(self, start, end):
#         if start != end:
#             mid = self.partition(start, end)
#             self.quickSort(start, mid)
#             if mid.next:
#                 self.quickSort(mid.next, end)
#     def partition(self, start, end):
#         pv = start.val
#         i, j = start, start.next
#         while j != end.next:
#             if j.val < pv:
#                 i = i.next
#                 i.val, j.val = j.val, i.val
#             j = j.next
#         start.val, i.val = i.val, start.val
#         return i
```
>
#### 164.最大间距
[https://leetcode-cn.com/problems/maximum-gap](https://leetcode-cn.com/problems/maximum-gap) 
##### 原题
给定一个无序的数组 `nums` ，返回 *数组在排序之后，相邻元素之间最大的差值* 。如果数组元素个数小于 2，则返回 `0` 。

您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。

 

 **示例 1:** 

```

输入: nums = [3,6,9,1]
输出: 3
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。
```
 **示例 2:** 

```

输入: nums = [10]
输出: 0
解释: 数组元素个数小于 2，因此返回 0。
```


 **提示:** 
-  `1 <= nums.length <= 10^5` 
-  `0 <= nums[i] <= 10^9` 

**标签**
`数组` `桶排序` `基数排序` `排序` 


##### solution
```python
#
# @lc app=leetcode.cn id=164 lang=python3
#
# [164] 最大间距
#
class Solution:
    # 桶排序 46.64%
    def maximumGap(self, nums: List[int]) -> int:
        import math
        n = len(nums)
        if n < 2:
            return 0
        a, b = min(nums), max(nums)
        if a == b:
            return 0
        gap = int(math.ceil((b-a) / (n-1)))
        bucketMin = [float('inf') for _ in range(n+1)]
        bucketMax = [float('-inf') for _ in range(n+1)]
        for num in nums:
            idx = (num - a) // gap
            bucketMin[idx] = min(bucketMin[idx], num)
            bucketMax[idx] = max(bucketMax[idx], num)
        bucketMin = [i for i in bucketMin if i != float('inf')]
        bucketMax = [i for i in bucketMax if i != float('-inf')]
        ans = 0
        for i in range(len(bucketMax)-1):
            ans = max(ans, bucketMin[i+1] - bucketMax[i])
        return ans
    # 基数排序————待补充
    # # 比较排序 17%
    # def maximumGap(self, nums: List[int]) -> int:
    #     nums.sort()
    #     n = len(nums)
    #     res = 0
    #     for i in range(1, n):
    #         res = max(res, nums[i]-nums[i-1])
    #     return res
```
>
#### 215.数组中的第k个最大元素
[https://leetcode-cn.com/problems/kth-largest-element-in-an-array](https://leetcode-cn.com/problems/kth-largest-element-in-an-array) 
##### 原题
给定整数数组 `nums` 和整数 `k` ，请返回数组中第 `**k**` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

 

 **示例 1:** 

```

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5

```
 **示例 2:** 

```

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```


 **提示：** 
-  `1 <= k <= nums.length <= 10^4` 
-  `-10^4 <= nums[i] <= 10^4` 

**标签**
`数组` `分治` `快速选择` `排序` `堆（优先队列）` 


##### solution
```python
#
# @lc app=leetcode.cn id=215 lang=python3
#
# [215] 数组中的第K个最大元素
#
import random
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        # 等价于找排序后索引为k-1的元素
        n = len(nums)
        return self.helper(nums, 0, n-1, k-1)
    def helper(self, nums, left, right, k):
        if left == right:
            return nums[left]
        # nums[mid]为第mid+1个最大元素
        mid = self.partition(nums, left, right)
        if mid == k:
            return nums[mid]
        elif k > mid:
            return self.helper(nums, mid+1, right, k)
        else:
            return self.helper(nums, left, mid-1, k)
    def partition(self, nums, left, right):
        p = random.randint(left, right)
        pv = nums[p]
        nums[p], nums[right] = nums[right], nums[p]
        mid = left
        for i in range(left, right):
            if nums[i] >= pv:
                nums[i], nums[mid] = nums[mid], nums[i]
                mid += 1
        nums[mid], nums[right] = nums[right], nums[mid]
        return mid
```
>
#### 692.前k个高频单词
[https://leetcode-cn.com/problems/top-k-frequent-words](https://leetcode-cn.com/problems/top-k-frequent-words) 
##### 原题
给一非空的单词列表，返回前 *k* 个出现次数最多的单词。

返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。

 **示例 1：** 

```

输入: ["i", "love", "leetcode", "i", "love", "coding"], k = 2
输出: ["i", "love"]
解析: "i" 和 "love" 为出现次数最多的两个单词，均为2次。
    注意，按字母顺序 "i" 在 "love" 之前。

```


 **示例 2：** 

```

输入: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4
输出: ["the", "is", "sunny", "day"]
解析: "the", "is", "sunny" 和 "day" 是出现次数最多的四个单词，
    出现次数依次为 4, 3, 2 和 1 次。

```


 **注意：** 
- 假定 *k* 总为有效值， 1 ≤ *k* ≤ 集合元素数。
- 输入的单词均由小写字母组成。


 **扩展练习：** 
- 尝试以 *O* ( *n* log *k* ) 时间复杂度和 *O* ( *n* ) 空间复杂度解决。

**标签**
`字典树` `哈希表` `字符串` `桶排序` `计数` `排序` `堆（优先队列）` 


##### solution
```python
#
# @lc app=leetcode.cn id=692 lang=python3
#
# [692] 前K个高频单词
#
class Solution:
    # # 堆排序
    # def topKFrequent(self, words: List[str], k: int) -> List[str]:
    #     import heapq
    #     d = {}
    #     for w in words:
    #         d[w] = d.get(w, 0) + 1
    #     lyst = [(-value, key) for key, value in d.items()]
    #     heapq.heapify(lyst)
    #     return [heapq.heappop(lyst)[1] for _ in range(k)]
    # hash+python自带sort
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        d = {}
        for w in words:
            d[w] = d.get(w, 0) + 1
        a = [(key, v) for key, v in d.items()]
        a.sort(key=lambda x : (-x[1], x[0]))
        return [i[0] for i in a][:k]
    # # 官方答案
    # # hash+python自带sort
    # def topKFrequent(self, words: List[str], k: int) -> List[str]:
    #     count = collections.Counter(words)
    #     candidates = count.keys()
    #     candidates.sort(key = lambda w: (-count[w], w))
    #     return candidates[:k]
```
>
## 3动态规划
#### 5.最长回文子串
[https://leetcode-cn.com/problems/longest-palindromic-substring](https://leetcode-cn.com/problems/longest-palindromic-substring) 
##### 原题
给你一个字符串 `s` ，找到 `s` 中最长的回文子串。

 

 **示例 1：** 

```

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。

```
 **示例 2：** 

```

输入：s = "cbbd"
输出："bb"

```


 **提示：** 
-  `1 <= s.length <= 1000` 
-  `s` 仅由数字和英文字母组成

**标签**
`字符串` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=5 lang=python3
#
# [5] 最长回文子串
#
class Solution:
    def longestPalindrome(self, s: str) -> str:
        res = ''
        maxlen = 0
        n = len(s)
        pre = [0] * n
        cur = [0] * n
        for i in range(n):
            for j in range(i+1):
                if i - j <= 1:
                    if s[i] == s[j]:
                        cur[j] = 1
                        if maxlen < i-j+1:
                            res = s[j:i+1]
                            maxlen = i-j+1
                else:
                    if s[i] == s[j] and pre[j+1]:
                        cur[j] = 1
                        if maxlen < i-j+1:
                            res = s[j:i+1]
                            maxlen = i-j+1
            pre = cur
            cur = [0] * n
        return res
```
>
#### 53.最大子序和
[https://leetcode-cn.com/problems/maximum-subarray](https://leetcode-cn.com/problems/maximum-subarray) 
##### 原题
给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 **子数组** 是数组中的一个连续部分。

 

 **示例 1：** 

```

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

```
 **示例 2：** 

```

输入：nums = [1]
输出：1

```
 **示例 3：** 

```

输入：nums = [5,4,-1,7,8]
输出：23

```


 **提示：** 
-  `1 <= nums.length <= 10^5` 
-  `-10^4 <= nums[i] <= 10^4` 


 **进阶：** 如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。

**标签**
`数组` `分治` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=53 lang=python3
#
# [53] 最大子序和
#
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        ans = float('-inf')
        subsum = 0
        for n in nums:
            subsum = max(subsum+n, n)
            ans = max(ans, subsum)
        return ans
```
>
#### 62.不同路径
[https://leetcode-cn.com/problems/unique-paths](https://leetcode-cn.com/problems/unique-paths) 
##### 原题
一个机器人位于一个 `m x n` * * 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

 **示例 1：** 
<img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" />
```

输入：m = 3, n = 7
输出：28
```
 **示例 2：** 

```

输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下

```
 **示例 3：** 

```

输入：m = 7, n = 3
输出：28

```
 **示例 4：** 

```

输入：m = 3, n = 3
输出：6
```


 **提示：** 
-  `1 <= m, n <= 100` 
- 题目数据保证答案小于等于 `2 * 10^9` 

**标签**
`数学` `动态规划` `组合数学` 


##### solution
```python
#
# @lc app=leetcode.cn id=62 lang=python3
#
# [62] 不同路径
#
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[1] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if i + j > 0:
                    if i == 0:
                        dp[i][j] = dp[i][j-1]
                    elif j == 0:
                        dp[i][j] = dp[i-1][j]
                    else:
                        dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
```
>
#### 63.不同路径-ii
[https://leetcode-cn.com/problems/unique-paths-ii](https://leetcode-cn.com/problems/unique-paths-ii) 
##### 原题
一个机器人位于一个<meta charset="UTF-8" /> `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" />
```

输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg" />
```

输入：obstacleGrid = [[0,1],[0,0]]
输出：1

```


 **提示：** 
-  `m == obstacleGrid.length` 
-  `n == obstacleGrid[i].length` 
-  `1 <= m, n <= 100` 
-  `obstacleGrid[i][j]` 为 `0` 或 `1` 

**标签**
`数组` `动态规划` `矩阵` 


##### solution
```python
#
# @lc app=leetcode.cn id=63 lang=python3
#
# [63] 不同路径 II
#
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        dp = [[1] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if obstacleGrid[i][j]:
                    dp[i][j] = 0
                else:
                    if i + j > 0:
                        if i == 0:
                            dp[i][j] = dp[i][j-1]
                        elif j == 0:
                            dp[i][j] = dp[i-1][j]
                        else:
                            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
```
>
#### 64.最小路径和
[https://leetcode-cn.com/problems/minimum-path-sum](https://leetcode-cn.com/problems/minimum-path-sum) 
##### 原题
给定一个包含非负整数的 ` *m*  x  *n* `  网格  `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

 **说明：** 每次只能向下或者向右移动一步。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" style="width: 242px; height: 242px;" />
```

输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。

```
 **示例 2：** 

```

输入：grid = [[1,2,3],[4,5,6]]
输出：12

```


 **提示：** 
-  `m == grid.length` 
-  `n == grid[i].length` 
-  `1 <= m, n <= 200` 
-  `0 <= grid[i][j] <= 100` 

**标签**
`数组` `动态规划` `矩阵` 


##### solution
```python
#
# @lc app=leetcode.cn id=64 lang=python3
#
# [64] 最小路径和
#
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [[float('inf')] * n for _ in range(m)]
        dp[0][0] = grid[0][0]
        for i in range(m):
            for j in range(n):
                if i + j > 0:
                    if i == 0:
                        dp[i][j] = grid[i][j] + dp[i][j-1]
                    elif j == 0:
                        dp[i][j] = grid[i][j] + dp[i-1][j]
                    else:
                        dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
        return dp[-1][-1]
```
>
#### 70.爬楼梯
[https://leetcode-cn.com/problems/climbing-stairs](https://leetcode-cn.com/problems/climbing-stairs) 
##### 原题
假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

 **示例 1：** 

```

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```
 **示例 2：** 

```

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶

```


 **提示：** 
-  `1 <= n <= 45` 

**标签**
`记忆化搜索` `数学` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=70 lang=python3
#
# [70] 爬楼梯
#
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2:
            return n
        p2, p1, cur = 0, 1, 2
        for _ in range(3, n+1):
            tmp = p1 + cur
            p2 = p1
            p1 = cur
            cur = tmp
        return cur
```
>
#### 120.三角形最小路径和
[https://leetcode-cn.com/problems/triangle](https://leetcode-cn.com/problems/triangle) 
##### 原题
给定一个三角形 `triangle` ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。 **相邻的结点** 在这里指的是 **下标** 与 **上一层结点下标** 相同或者等于 **上一层结点下标 + 1** 的两个结点。也就是说，如果正位于当前行的下标 `i` ，那么下一步可以移动到下一行的下标 `i` 或 `i + 1` 。

 

 **示例 1：** 

```

输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

```
 **示例 2：** 

```

输入：triangle = [[-10]]
输出：-10

```


 **提示：** 
-  `1 <= triangle.length <= 200` 
-  `triangle[0].length == 1` 
-  `triangle[i].length == triangle[i - 1].length + 1` 
-  `-10^4 <= triangle[i][j] <= 10^4` 


 **进阶：** 
- 你可以只使用 `O(n)`  的额外空间（ `n` 为三角形的总行数）来解决这个问题吗？

**标签**
`数组` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=120 lang=python3
#
# [120] 三角形最小路径和
#
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        if not triangle:
            return []
        if len(triangle) == 1:
            return triangle[0][0]
        n = len(triangle)
        pre = [triangle[0][0]]
        for i, cur_layer in enumerate(triangle):
            if i >= 1:
                cur = [cur_layer[0] + pre[0]]
                for j in range(1, i):
                    cur.append(cur_layer[j] + min(pre[j], pre[j-1]))
                cur.append(pre[-1] + cur_layer[-1])
                pre = cur
        return min(pre)
```
>
#### 121.买卖股票的最佳时机
[https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock) 
##### 原题
给定一个数组 `prices` ，它的第  `i` 个元素  `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

 

 **示例 1：** 

```

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

```
 **示例 2：** 

```

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

```


 **提示：** 
-  `1 <= prices.length <= 10^5` 
-  `0 <= prices[i] <= 10^4` 

**标签**
`数组` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=121 lang=python3
#
# [121] 买卖股票的最佳时机
#
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        res = 0
        pre_min = prices[0]
        for i, p in enumerate(prices):
            if i >= 1:
                res = max(res, p - pre_min)
                pre_min = min(pre_min, p)
        return res
```
>
#### 123.买卖股票的最佳时机-iii
[https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii) 
##### 原题
给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成  **两笔 ** 交易。

 **注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

 **示例 1:** 

```

输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```
 **示例 2：** 

```

输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

```
 **示例 3：** 

```

输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```
 **示例 4：** 

```

输入：prices = [1]
输出：0

```


 **提示：** 
-  `1 <= prices.length <= 10^5` 
-  `0 <= prices[i] <= 10^5` 

**标签**
`数组` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=123 lang=python3
#
# [123] 买卖股票的最佳时机 III
#
class Solution:
    # 36.45%
    def maxProfit(self, prices):
        buy1, buy2 = float('-inf'), float('-inf')
        sell1, sell2 = 0, 0
        for i in prices:
            buy1 = max(buy1, -i)
            sell1 = max(sell1, buy1+i)
            buy2 = max(buy2, sell1-i)
            sell2 = max(sell2, buy2+i)
        return sell2
    # 68.48%
    # def maxProfit(self, prices: List[int]) -> int:
    #     n = len(prices)
    #     if n < 2:
    #         return 0
    #     pre_min = prices[0]
    #     pre_max_profit = [0] * n
    #     for i in range(1, n):
    #         pre_max_profit[i] = max(pre_max_profit[i-1], prices[i]-pre_min)
    #         pre_min = min(pre_min, prices[i])
    #     post_max = prices[n-1]
    #     post_max_profit = [0] * n
    #     for i in range(n-2, -1, -1):
    #         post_max_profit[i] = max(post_max_profit[i+1], post_max-prices[i])
    #         post_max = max(post_max, prices[i])
    #     res = 0
    #     for i in range(n):
    #         res = max(res, pre_max_profit[i]+post_max_profit[i])
    #     return res
```
>
#### 152.乘积最大子序列
[https://leetcode-cn.com/problems/maximum-product-subarray](https://leetcode-cn.com/problems/maximum-product-subarray) 
##### 原题
给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。

 **子数组** 是数组的连续子序列。

 

 **示例 1:** 

```

输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。

```
 **示例 2:** 

```

输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```


 **提示:** 
-  `1 <= nums.length <= 2 * 10^4` 
-  `-10 <= nums[i] <= 10` 
-  `nums` 的任何前缀或后缀的乘积都 **保证** 是一个 **32-位** 整数

**标签**
`数组` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=152 lang=python3
#
# [152] 乘积最大子序列
# https://leetcode-cn.com/problems/maximum-product-subarray/solution/duo-chong-si-lu-qiu-jie-by-powcai-3/
class Solution:
    # def maxProduct(self, nums):
    #     premax, premin = nums[0], nums[0]
    #     res = nums[0]
    #     for i, n in enumerate(nums):
    #         if i >= 1:
    #             curmax = max(premax*n, premin*n, n)
    #             curmin = min(premax*n, premin*n, n)
    #             res = max(res, curmax)
    #             premax, premin = curmax, curmin
    #     return res
    def maxProduct(self, nums: List[int]) -> int:
        maxdp = [nums[0] for _ in range(len(nums))]
        mindp = [nums[0] for _ in range(len(nums))]
        for i in range(1, len(nums)):
            maxdp[i] = max(maxdp[i-1]*nums[i], mindp[i-1]*nums[i], nums[i])
            mindp[i] = min(maxdp[i-1]*nums[i], mindp[i-1]*nums[i], nums[i])
        return max(maxdp)
# print(Solution().maxProduct([2,3,-2,4]))
```
>
#### 198.打家劫舍
[https://leetcode-cn.com/problems/house-robber](https://leetcode-cn.com/problems/house-robber) 
##### 原题
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统， **如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

 **示例 1：** 

```

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```
 **示例 2：** 

```

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

```


 **提示：** 
-  `1 <= nums.length <= 100` 
-  `0 <= nums[i] <= 400` 

**标签**
`数组` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=198 lang=python3
#
# [198] 打家劫舍
#
# https://www.cnblogs.com/grandyang/p/4383632.html
# dp[i] = max(num[i] + dp[i - 2], dp[i - 1])
class Solution:
    def rob(self, nums):
        L = len(nums)
        if L <= 0:
            return 0
        if L == 1:
            return nums[0]
        # 89.59%
        p2, p1 = 0, nums[0]
        for i in range(2, L+1):
            tmp = max(p2+nums[i-1], p1)
            p2 = p1
            p1 = tmp
        return tmp
        # 54.57%
        # dp = [0] * (L+1)
        # dp[1] = nums[0]
        # for i in range(2, L+1):
        #     dp[i] = max(dp[i-2]+nums[i-1], dp[i-1])
        # return dp[-1]
# print(Solution().rob([1,2,3,1]))
```
>
#### 213.打家劫舍-ii
[https://leetcode-cn.com/problems/house-robber-ii](https://leetcode-cn.com/problems/house-robber-ii) 
##### 原题
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统， **如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

 

 **示例 1：** 

```

输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

```
 **示例 2：** 

```

输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```
 **示例 3：** 

```

输入：nums = [1,2,3]
输出：3

```


 **提示：** 
-  `1 <= nums.length <= 100` 
-  `0 <= nums[i] <= 1000` 

**标签**
`数组` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=213 lang=python3
#
# [213] 打家劫舍 II
#
class Solution:
    def rob(self, nums: List[int]) -> int:
        L = len(nums)
        if L == 0:
            return 0
        if L == 1:
            return nums[0]
        if L == 2:
            return max(nums[0], nums[1])
        def rob_line(nums):
            p2, p1 = 0, nums[0]
            for i in range(2, len(nums)+1):
                tmp = max(p2+nums[i-1], p1)
                p2 = p1
                p1 = tmp
            return tmp
        return max(rob_line(nums[1:]), rob_line(nums[:-1]))
```
>
#### 221.最大正方形
[https://leetcode-cn.com/problems/maximal-square](https://leetcode-cn.com/problems/maximal-square) 
##### 原题
在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg" style="width: 400px; height: 319px;" />
```

输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg" style="width: 165px; height: 165px;" />
```

输入：matrix = [["0","1"],["1","0"]]
输出：1

```
 **示例 3：** 

```

输入：matrix = [["0"]]
输出：0

```


 **提示：** 
-  `m == matrix.length` 
-  `n == matrix[i].length` 
-  `1 <= m, n <= 300` 
-  `matrix[i][j]` 为 `'0'` 或 `'1'` 

**标签**
`数组` `动态规划` `矩阵` 


##### solution
```python
#
# @lc app=leetcode.cn id=221 lang=python3
#
# [221] 最大正方形
#
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        ans = 0
        if not matrix:
            return ans
        rows, cols = len(matrix), len(matrix[0])
        dp = [[0] * (cols+1) for _ in range(rows+1)]
        for i in range(1, rows+1):
            for j in range(1, cols+1):
                if matrix[i-1][j-1] == '1':
                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
                    ans = max(ans, dp[i][j])
        return ans ** 2
```
>
#### 300.最长上升子序列
[https://leetcode-cn.com/problems/longest-increasing-subsequence](https://leetcode-cn.com/problems/longest-increasing-subsequence) 
##### 原题
给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

 **子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如， `[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。


 **示例 1：** 

```

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

```
 **示例 2：** 

```

输入：nums = [0,1,0,3,2,3]
输出：4

```
 **示例 3：** 

```

输入：nums = [7,7,7,7,7,7,7]
输出：1

```


 **提示：** 
-  `1 <= nums.length <= 2500` 
-  `-10^4 <= nums[i] <= 10^4` 


<b>进阶：</b>
- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

**标签**
`数组` `二分查找` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=300 lang=python3
#
# [300] 最长上升子序列
#
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return n
        cells = [nums[0]]
        for num in nums[1:]:
            if num > cells[-1]:
                cells.append(num)
                continue
            l, r = 0, len(cells)-1
            while l < r:
                mid = l + ((r-l) >> 1)
                if cells[mid] < num:
                    l = mid + 1
                else:
                    r = mid
            cells[l] = num
        return len(cells)
    # def lengthOfLIS(self, nums: List[int]) -> int:
    #     if not nums:
    #         return 0
    #     L = len(nums)
    #     dp = [1] * L
    #     for i in range(L):
    #         for j in range(i):
    #             if nums[i] > nums[j]:
    #                 dp[i] = max(dp[i], dp[j] + 1)
    #     return max(dp)
```
>
#### 312.戳气球
[https://leetcode-cn.com/problems/burst-balloons](https://leetcode-cn.com/problems/burst-balloons) 
##### 原题
有 `n` 个气球，编号为 `0` 到 `n - 1` ，每个气球上都标有一个数字，这些数字存在数组  `nums`  中。

现在要求你戳破所有的气球。戳破第 `i` 个气球，你可以获得  `nums[i - 1] * nums[i] * nums[i + 1]` 枚硬币。 这里的 `i - 1` 和 `i + 1` 代表和  `i`  相邻的两个气球的序号。如果 `i - 1` 或 `i + 1` 超出了数组的边界，那么就当它是一个数字为 `1` 的气球。

求所能获得硬币的最大数量。


 **示例 1：** 

```

输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
```
 **示例 2：** 

```

输入：nums = [1,5]
输出：10

```


 **提示：** 
-  `n == nums.length` 
-  `1 <= n <= 500` 
-  `0 <= nums[i] <= 100` 

**标签**
`数组` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=312 lang=python3
#
# [312] 戳气球
# https://leetcode-cn.com/problems/burst-balloons/solution/python-dp-yuan-lian-jie-httpsleetcodecomproblemsbu/
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1] + nums + [1]
        n = len(nums)
        # dp[i][j]表示从戳破i+1到j-1的气球的最大收益，
        # 完成后，i+1~j-1之间的气球都没了
        dp = [[0] * n for _ in range(n)]
        for j in range(2, n):
            for i in range(j-2, -1, -1):
                for k in range(i+1, j):
                    # 假设最后删除的是气球k，那么此时i+1~k-1和k+1~j-1的气球都没了，
                    # 此时戳破气球k的收益为nums[i]*nums[k]*nums[j]
                    dp[i][j] = max(dp[i][j], dp[i][k]+dp[k][j]+nums[i]*nums[k]*nums[j])
        '''
        dp[i][j]依赖于dp[i][k]和dp[k][j]
        k在i+1~j-1之间
        k < j => j依赖于之前的信息
        k > i => i依赖于之后的信息
        为保证遍历到(i,j)时，需要的子问题的解都已经求得，
        j从前往后遍历，i从后往前遍历
        '''
        return dp[0][-1]
```
>
#### 322.零钱兑换
[https://leetcode-cn.com/problems/coin-change](https://leetcode-cn.com/problems/coin-change) 
##### 原题
给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

 

 **示例 1：** 

```

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```
 **示例 2：** 

```

输入：coins = [2], amount = 3
输出：-1
```
 **示例 3：** 

```

输入：coins = [1], amount = 0
输出：0

```


 **提示：** 
-  `1 <= coins.length <= 12` 
-  `1 <= coins[i] <= 2^31 - 1` 
-  `0 <= amount <= 10^4` 

**标签**
`广度优先搜索` `数组` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=322 lang=python3
#
# [322] 零钱兑换
#
class Solution:
    def coinChange(self, coins, amount):
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        for i in range(1, amount+1):
            for coin in coins:
                if coin <= i:
                    dp[i] = min(dp[i], dp[i-coin] + 1)
            # print(dp)
        return dp[-1] if dp[-1] != float('inf') else -1
# print(Solution().coinChange([1,2,5], 11))
```
>
#### 334.递增的三元子序列
[https://leetcode-cn.com/problems/increasing-triplet-subsequence](https://leetcode-cn.com/problems/increasing-triplet-subsequence) 
##### 原题
给你一个整数数组 `nums` ，判断这个数组中是否存在长度为 `3` 的递增子序列。

如果存在这样的三元组下标 `(i, j, k)` 且满足 `i < j < k` ，使得 `nums[i] < nums[j] < nums[k]` ，返回 `true` ；否则，返回 `false` 。

 

 **示例 1：** 

```

输入：nums = [1,2,3,4,5]
输出：true
解释：任何 i < j < k 的三元组都满足题意

```
 **示例 2：** 

```

输入：nums = [5,4,3,2,1]
输出：false
解释：不存在满足题意的三元组
```
 **示例 3：** 

```

输入：nums = [2,1,5,0,4,6]
输出：true
解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 < nums[4] == 4 < nums[5] == 6

```


 **提示：** 
-  `1 <= nums.length <= 5 * 10^5` 
-  `-2^31 <= nums[i] <= 2^31 - 1` 


 **进阶：** 你能实现时间复杂度为 `O(n)` ，空间复杂度为 `O(1)` 的解决方案吗？


**标签**
`贪心` `数组` 


##### solution
```python
#
# @lc app=leetcode.cn id=334 lang=python3
#
# [334] 递增的三元子序列
#
class Solution:
    # 贪心
    def increasingTriplet(self, nums: List[int]) -> bool:
        a, b = float('inf'), float('inf')
        for n in nums:
            if a >= n:
                a = n
            elif b >= n:  # a < n <= b
                b = n
            else:
                return True
        return False
    # dp超时
    # def increasingTriplet(self, nums: List[int]) -> bool:
    #     dp = [1] * len(nums)
    #     for i, n in enumerate(nums):
    #         for j in range(i):
    #             if n > nums[j]:
    #                 dp[i] = max(dp[i], dp[j]+1)
    #                 if dp[i] == 3:
    #                     return True
    #     return False
```
>
#### 337.打家劫舍-iii
[https://leetcode-cn.com/problems/house-robber-iii](https://leetcode-cn.com/problems/house-robber-iii) 
##### 原题
小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为<meta charset="UTF-8" /> `root` 。

除了<meta charset="UTF-8" /> `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

 

 **示例 1:** 

<img alt="" src="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg" />

```

输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
```
 **示例 2:** 

<img alt="" src="https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg" />

```

输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9

```


 **提示：** 

<meta charset="UTF-8" />
- 树的节点数在 `[1, 10^4]` 范围内
-  `0 <= Node.val <= 10^4` 

**标签**
`树` `深度优先搜索` `动态规划` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=337 lang=python3
#
# [337] 打家劫舍 III
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def rob(self, root: TreeNode) -> int:
        def dfs(root):
            if not root:
                return 0, 0
            # 当前节点最终确定的最大值(考虑了不包含和包含当前节点两种情况)，不包含当前节点的最大值
            lpre, lppre = dfs(root.left)
            rpre, rppre = dfs(root.right)
            # 不包含当前节点，取左子节点的最大值和右子节点的最大值直接相加
            # 包含当前节点，取左边不包含左子节点的最大值和右边不包含右子节点的最大值，再加上当前节点的值
            return max(root.val+lppre+rppre, lpre+rpre), lpre+rpre
        return dfs(root)[0]
    # def rob(self, root: TreeNode) -> int:
    #     def dfs(root):
    #         # 返回值: (不包含当前节点的最大值，包含当前节点的最大值)
    #         if not root:
    #             return (0, 0)
    #         l0, l1 = dfs(root.left)
    #         r0, r1 = dfs(root.right)
    #         res0 = max(l0, l1) + max(r0, r1)
    #         res1 = l0 + r0 + root.val
    #         return (res0, res1)
    #     res = dfs(root)
    #     return max(res[0], res[1])
```
>
#### 354.俄罗斯套娃信封问题
[https://leetcode-cn.com/problems/russian-doll-envelopes](https://leetcode-cn.com/problems/russian-doll-envelopes) 
##### 原题
给你一个二维整数数组 `envelopes` ，其中 `envelopes[i] = [w<sub>i</sub>, h<sub>i</sub>]` ，表示第 `i` 个信封的宽度和高度。

当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算 **最多能有多少个** 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

 **注意** ：不允许旋转信封。


 **示例 1：** 

```

输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
```
 **示例 2：** 

```

输入：envelopes = [[1,1],[1,1],[1,1]]
输出：1

```


 **提示：** 
-  `1 <= envelopes.length <= 10^5` 
-  `envelopes[i].length == 2` 
-  `1 <= w<sub>i</sub>, h<sub>i</sub> <= 10^5` 

**标签**
`数组` `二分查找` `动态规划` `排序` 


##### solution
```python
#
# @lc app=leetcode.cn id=354 lang=python3
#
# [354] 俄罗斯套娃信封问题
#
from bisect import bisect_left
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        n = len(envelopes)
        if n < 2:
            return n
        envelopes = sorted(envelopes, key=lambda a : (a[0], -a[1]))
        # LIS
        nums = [envelopes[i][1] for i in range(n)]
        cells = [nums[0]]
        for num in nums[1:]:
            if num > cells[-1]:
                cells.append(num)
                continue
            l, r = 0, len(cells)-1
            while l < r:
                mid = l + ((r-l)>>1)
                if cells[mid] < num:
                    l = mid + 1
                else:
                    r = mid
            cells[l] = num
        return len(cells)
    # # 超时
    # def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
    #     if not envelopes:
    #         return 0
    #     # [[wi, hi]] 对w升序，w相同则对h降序
    #     envelopes = sorted(envelopes, key=lambda a : (a[0], -a[1]))
    #     # LIS
    #     n = len(envelopes)
    #     dp = [1] * n
    #     for i in range(n):
    #         for j in range(i):
    #             if envelopes[i][1] > envelopes[j][1]:
    #                 dp[i] = max(dp[i], dp[j]+1)
    #     return max(dp)
```
>
#### 376.摆动序列
[https://leetcode-cn.com/problems/wiggle-subsequence](https://leetcode-cn.com/problems/wiggle-subsequence) 
##### 原题
如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。** 第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
- 

	例如，  `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)`  是正负交替出现的。

- 相反， `[1, 4, 7, 2, 5]`  和  `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
 **子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

 

 **示例 1：** 

```

输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。

```
 **示例 2：** 

```

输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。

```
 **示例 3：** 

```

输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2

```


 **提示：** 
-  `1 <= nums.length <= 1000` 
-  `0 <= nums[i] <= 1000` 


 **进阶：** 你能否用  `O(n)` 时间复杂度完成此题?


**标签**
`贪心` `数组` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=376 lang=python3
#
# [376] 摆动序列
#
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return n
        up, down = 1, 1
        for i in range(1, n):
            if nums[i] > nums[i-1]:
                up = down + 1
            elif nums[i] < nums[i-1]:
                down = up + 1
        return max(up, down)
    # def wiggleMaxLength(self, nums: List[int]) -> int:
    #     n = len(nums)
    #     if n < 2:
    #         return n
    #     up = [1] * n
    #     down = [1] * n
    #     for i in range(1, n):
    #         if nums[i] > nums[i-1]:
    #             up[i] = down[i-1] + 1
    #             down[i] = down[i-1]
    #         elif nums[i] < nums[i-1]:
    #             down[i] = up[i-1] + 1
    #             up[i] = up[i-1]
    #         else:
    #             down[i] = down[i-1]
    #             up[i] = up[i-1]
    #     return max(up[-1], down[-1])
```
>
#### 518.零钱兑换-ii
[https://leetcode-cn.com/problems/coin-change-2](https://leetcode-cn.com/problems/coin-change-2) 
##### 原题
给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。


 **示例 1：** 

```

输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1

```
 **示例 2：** 

```

输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。

```
 **示例 3：** 

```

输入：amount = 10, coins = [10] 
输出：1

```


 **提示：** 
-  `1 <= coins.length <= 300` 
-  `1 <= coins[i] <= 5000` 
-  `coins` 中的所有值 **互不相同** 
-  `0 <= amount <= 5000` 

**标签**
`数组` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=518 lang=python3
#
# [518] 零钱兑换 II
#
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0] * (amount+1)
        dp[0] = 1
        for coin in coins:
            for i in range(amount+1):
                if i+coin <= amount:
                    dp[i+coin] += dp[i]
        return dp[-1]
```
>
#### 980.不同路径-iii
[https://leetcode-cn.com/problems/unique-paths-iii](https://leetcode-cn.com/problems/unique-paths-iii) 
##### 原题
在二维网格 `grid` 上，有 4 种类型的方格：
-  `1` 表示起始方格。且只有一个起始方格。
-  `2` 表示结束方格，且只有一个结束方格。
-  `0` 表示我们可以走过的空方格。
-  `-1` 表示我们无法跨越的障碍。
返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目 **。** 

 **每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格** 。

 

 **示例 1：** 

```
输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
输出：2
解释：我们有以下两条路径：
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
```
 **示例 2：** 

```
输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]
输出：4
解释：我们有以下四条路径： 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
```
 **示例 3：** 

```
输入：[[0,1],[2,0]]
输出：0
解释：
没有一条路能完全穿过每一个空的方格一次。
请注意，起始和结束方格可以位于网格中的任意位置。

```


 **提示：** 
-  `1 <= grid.length * grid[0].length <= 20` 

**标签**
`位运算` `数组` `回溯` `矩阵` 


##### solution
```python
#
# @lc app=leetcode.cn id=980 lang=python3
#
# [980] 不同路径 III
# https://blog.csdn.net/qq_17550379/article/details/86589259
class Solution:
    def uniquePathsIII(self, grid: List[List[int]]) -> int:
        p = 1
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    start = (i, j)
                elif grid[i][j] == 2:
                    end = (i, j)
                elif grid[i][j] == 0:
                    p += 1
        def dfs(i, j, p):
            if not (0 <= i < m and 0 <= j < n and grid[i][j] >= 0):
                return 0
            if end == (i, j) and p == 0:
                return 1
            tmp = grid[i][j]
            grid[i][j] = -1
            res = dfs(i-1, j, p-1) + dfs(i+1, j, p-1) \
                + dfs(i, j-1, p-1) + dfs(i, j+1, p-1)
            grid[i][j] = tmp
            return res
        return dfs(start[0], start[1], p)
```
>
## 4贪心
#### 122.买卖股票的最佳时机-ii
[https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii) 
##### 原题
给定一个数组 `prices` ，其中 `prices[i]` 表示股票第 `i` 天的价格。

在每一天，你可能会决定购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以购买它，然后在 **同一天** 出售。<br />
返回 *你能获得的 **最大** 利润* 。

 

 **示例 1:** 

```

输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

```
 **示例 2:** 

```

输入: prices = [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

```
 **示例 3:** 

```

输入: prices = [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```


 **提示：** 
-  `1 <= prices.length <= 3 * 10^4` 
-  `0 <= prices[i] <= 10^4` 

**标签**
`贪心` `数组` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=122 lang=python3
#
# [122] 买卖股票的最佳时机 II
#
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        n = len(prices)
        res = 0
        for i in range(1, n):
            if prices[i] > prices[i-1]:
                res += prices[i] - prices[i-1]
        return res
```
>
## 5回溯
#### 17.电话号码的字母组合
[https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number) 
##### 原题
给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" style="width: 200px;" />

 

 **示例 1：** 

```

输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]

```
 **示例 2：** 

```

输入：digits = ""
输出：[]

```
 **示例 3：** 

```

输入：digits = "2"
输出：["a","b","c"]

```


 **提示：** 
-  `0 <= digits.length <= 4` 
-  `digits[i]` 是范围 `['2', '9']` 的一个数字。

**标签**
`哈希表` `字符串` `回溯` 


##### solution
```python
#
# @lc app=leetcode.cn id=17 lang=python3
#
# [17] 电话号码的字母组合
#
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        self.res = []
        n = len(digits)
        d = {'2':['a','b','c'],
            '3':['d','e','f'],
            '4':['g','h','i'],
            '5':['j','k','l'],
            '6':['m','n','o'],
            '7':['p','q','r','s'],
            '8':['t','u','v'],
            '9':['w','x','y','z']}
        def dfs(digits, path):
            if len(digits) == 0:
                self.res.append(path)
            else:
                for c in d[digits[0]]:
                    dfs(digits[1:], path+c)
        dfs(digits, '')
        return self.res
```
>
#### 22.括号生成
[https://leetcode-cn.com/problems/generate-parentheses](https://leetcode-cn.com/problems/generate-parentheses) 
##### 原题
数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

 

 **示例 1：** 

```

输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]

```
 **示例 2：** 

```

输入：n = 1
输出：["()"]

```


 **提示：** 
-  `1 <= n <= 8` 

**标签**
`字符串` `动态规划` `回溯` 


##### solution
```python
#
# @lc app=leetcode.cn id=22 lang=python3
#
# [22] 括号生成
#
class Solution:
    def generateParenthesis(self, n):
        self.res = []
        def dfs(left, path, n):
            if len(path) == 2*n:
                if left == 0:
                    self.res.append(path)
                return
            if left < n:
                dfs(left+1, path+'(', n)
            if left > 0:
                dfs(left-1, path+')', n)
        dfs(0, '', n)
        return self.res
# print(Solution().generateParenthesis(3))
```
>
#### 46.全排列
[https://leetcode-cn.com/problems/permutations](https://leetcode-cn.com/problems/permutations) 
##### 原题
给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

 

 **示例 1：** 

```

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

```
 **示例 2：** 

```

输入：nums = [0,1]
输出：[[0,1],[1,0]]

```
 **示例 3：** 

```

输入：nums = [1]
输出：[[1]]

```


 **提示：** 
-  `1 <= nums.length <= 6` 
-  `-10 <= nums[i] <= 10` 
-  `nums` 中的所有整数 **互不相同** 

**标签**
`数组` `回溯` 


##### solution
```python
#
# @lc app=leetcode.cn id=46 lang=python3
#
# [46] 全排列
#
class Solution:
    # 基于回溯算法98.84%
    def permute(self, nums: List[int]) -> List[List[int]]:
        self.res = []
        L = len(nums)
        def dfs(nums, path, visited):
            if len(path) == L:
                self.res.append(path)
                return
            for n in nums:
                if n not in visited:
                    visited.add(n)
                    dfs(nums, path+[n], visited)
                    visited.remove(n)
        dfs(nums, [], set())
        return self.res
    # 14.59%
    # def permute(self, nums: List[int]) -> List[List[int]]:
    #     if not nums:
    #         return []
    #     if len(nums) == 1:
    #         return [nums]
    #     res = []
    #     for i, n in enumerate(nums):
    #         rest = nums[:i] + nums[i+1:]
    #         for a in self.permute(rest):
    #             res.append([n] + a)
    #     return res
```
>
#### 47.全排列-ii
[https://leetcode-cn.com/problems/permutations-ii](https://leetcode-cn.com/problems/permutations-ii) 
##### 原题
给定一个可包含重复数字的序列 `nums` ， ***按任意顺序*** 返回所有不重复的全排列。

 

 **示例 1：** 

```

输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]

```
 **示例 2：** 

```

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

```


 **提示：** 
-  `1 <= nums.length <= 8` 
-  `-10 <= nums[i] <= 10` 

**标签**
`数组` `回溯` 


##### solution
```python
#
# @lc app=leetcode.cn id=47 lang=python3
#
# [47] 全排列 II
#
class Solution:
    def permuteUnique(self, nums):
        self.res = []
        nums.sort()
        L = len(nums)
        def dfs(nums, path, visited):
            if len(path) == L:
                self.res.append(path)
                return
            for i, n in enumerate(nums):
                if i in visited:
                    continue
                # [1,2,2,3]保证第一个1和第二个1加进visited的先后顺序
                if i > 0 and nums[i-1] == n and i-1 not in visited:
                    continue
                visited.add(i)
                dfs(nums, path+[n], visited)
                visited.remove(i)
        dfs(nums, [], set())
        return self.res
# print(Solution().permuteUnique([1,1,2]))
```
>
#### 78.子集
[https://leetcode-cn.com/problems/subsets](https://leetcode-cn.com/problems/subsets) 
##### 原题
给你一个整数数组  `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

 

 **示例 1：** 

```

输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

```
 **示例 2：** 

```

输入：nums = [0]
输出：[[],[0]]

```


 **提示：** 
-  `1 <= nums.length <= 10` 
-  `-10 <= nums[i] <= 10` 
-  `nums` 中的所有元素 **互不相同** 

**标签**
`位运算` `数组` `回溯` 


##### solution
```python
#
# @lc app=leetcode.cn id=78 lang=python3
#
# [78] 子集
#
class Solution:
    # 回溯标准写法
    def subsets(self, nums: List[int]) -> List[List[int]]:
        self.ans = []
        def backtrack(nums, index, path):
            if index == len(nums):
                self.ans.append(path)
                return
            backtrack(nums, index+1, path)
            backtrack(nums, index+1, path+[nums[index]])
        backtrack(nums, 0, [])
        return self.ans
    # dfs
    # def subsets(self, nums: List[int]) -> List[List[int]]:
    #     self.ans = []
    #     def dfs(nums, index, path):
    #         self.ans.append(path)
    #         for i in range(index, len(nums)):
    #             dfs(nums, i+1, path+[nums[i]])
    #     dfs(nums, 0, [])
    #     return self.ans
    # 一种巧妙的方法
    # def subsets(self, nums):
    #     res = [[]]
    #     for i in range(len(nums)):
    #         for subres in res[:]:
    #             res.append(subres+[nums[i]])
    #     return res
```
>
#### 89.格雷编码
[https://leetcode-cn.com/problems/gray-code](https://leetcode-cn.com/problems/gray-code) 
##### 原题
 **n 位格雷码序列** 是一个由 `2^n` 个整数组成的序列，其中：

- 每个整数都在范围 `[0, 2^n - 1]` 内（含 `0` 和 `2^n - 1` ）
- 第一个整数是 `0` 
- 一个整数在序列中出现 **不超过一次** 
- 每对 **相邻** 整数的二进制表示 **恰好一位不同** ，且
-  **第一个** 和 **最后一个** 整数的二进制表示 **恰好一位不同** 
给你一个整数 `n` ，返回任一有效的 **n 位格雷码序列** 。

 

 **示例 1：** 

```

输入：n = 2
输出：[0,1,3,2]
解释：
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。
- 00 和 01 有一位不同
- 01 和 11 有一位不同
- 11 和 10 有一位不同
- 10 和 00 有一位不同
[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- 00 和 10 有一位不同
- 10 和 11 有一位不同
- 11 和 01 有一位不同
- 01 和 00 有一位不同

```
 **示例 2：** 

```

输入：n = 1
输出：[0,1]

```


 **提示：** 
-  `1 <= n <= 16` 

**标签**
`位运算` `数学` `回溯` 


##### solution
```python
#
# @lc app=leetcode.cn id=89 lang=python3
#
# [89] 格雷编码
#
class Solution:
    def grayCode(self, n: int) -> List[int]:
        res, head = [0], 1
        for _ in range(n):
            for j in range(len(res)-1, -1, -1):
                res.append(head + res[j])
            head <<= 1
        return res
```
>
#### 90.子集-ii
[https://leetcode-cn.com/problems/subsets-ii](https://leetcode-cn.com/problems/subsets-ii) 
##### 原题
给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。


 **示例 1：** 

```

输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]

```
 **示例 2：** 

```

输入：nums = [0]
输出：[[],[0]]

```


 **提示：** 
-  `1 <= nums.length <= 10` 
-  `-10 <= nums[i] <= 10` 

**标签**
`位运算` `数组` `回溯` 


##### solution
```python
#
# @lc app=leetcode.cn id=90 lang=python3
#
# [90] 子集 II
#
class Solution:
    # 89.84%
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = [[]]
        temp_size = 0
        for i in range(len(nums)):
            start = temp_size if i >= 1 and nums[i] == nums[i-1] else 0
            temp_size = len(res)
            for j in range(start, temp_size):
                res.append(res[j]+[nums[i]])
        return res
    # 回溯去重 24%
    # def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
    #     self.ans = []
    #     def backtrack(nums, index, path):
    #         if index == len(nums):
    #             if sorted(path) not in self.ans:
    #                 self.ans.append(sorted(path))
    #             return
    #         backtrack(nums, index+1, path)
    #         backtrack(nums, index+1, path+[nums[index]])
    #     backtrack(nums, 0, [])
    #     return self.ans
```
>
#### 306.累加数
[https://leetcode-cn.com/problems/additive-number](https://leetcode-cn.com/problems/additive-number) 
##### 原题
 **累加数** 是一个字符串，组成它的数字可以形成累加序列。

一个有效的 **累加序列** 必须 **至少** 包含 3 个数。除了最开始的两个数以外，序列中的每个后续数字必须是它之前两个数字之和。

给你一个只包含数字 `'0'-'9'` 的字符串，编写一个算法来判断给定输入是否是 **累加数** 。如果是，返回 `true` ；否则，返回 `false` 。

 **说明：** 累加序列里的数，除数字 0 之外， **不会** 以 0 开头，所以不会出现 `1, 2, 03` 或者 `1, 02, 3` 的情况。

 

 **示例 1：** 

```

输入："112358"
输出：true 
解释：累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8

```
 **示例 2：** 

```

输入："199100199"
输出：true 
解释：累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199
```


 **提示：** 
-  `1 <= num.length <= 35` 
-  `num` 仅由数字（ `0` - `9` ）组成


 **进阶：** 你计划如何处理由过大的整数输入导致的溢出?


**标签**
`字符串` `回溯` 


##### solution
```python
#
# @lc app=leetcode.cn id=306 lang=python3
#
# [306] 累加数
#
class Solution:
    def isAdditiveNumber(self, num: str) -> bool:
        n = len(num)
        for x in range(n//2+1):
            if x > 0 and num[0] == '0':
                break
            for y in range(x+1, n):
                if y > x+1 and num[x+1] == '0':
                    break
                i, j, k = 0, x, y
                while k < n:
                    a = int(num[i:j+1])
                    b = int(num[j+1:k+1])
                    add = str(int(a + b))
                    if not num.startswith(add, k+1):
                        break
                    if len(add) + k + 1 == n:
                        return True
                    i = j+1
                    j = k
                    k = k + len(add)
        return False
```
>
#### 842.将数组拆分成斐波那契序列
[https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence](https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence) 
##### 原题
给定一个数字字符串 `num` ，比如 `"123456579"` ，我们可以将它分成「斐波那契式」的序列 `[123, 456, 579]` 。

形式上， **斐波那契式** 序列是一个非负整数列表 `f` ，且满足：
-  `0 <= f[i] < 2^31` ，（也就是说，每个整数都符合 **32 位** 有符号整数类型）
-  `f.length >= 3` 
- 对于所有的 `0 <= i < f.length - 2` ，都有 `f[i] + f[i + 1] = f[i + 2]` 
另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 `0` 本身。

返回从 `num` 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 `[]` 。

 

 **示例 1：** 

```

输入：num = "1101111"
输出：[11,0,11,11]
解释：输出[110,1,111]也可以。
```
 **示例 2：** 

```

输入: num = "112358130"
输出: []
解释: 无法拆分。

```
 **示例 3：** 

```

输入："0123"
输出：[]
解释：每个块的数字不能以零开头，因此 "01"，"2"，"3" 不是有效答案。

```


 **提示：** 
-  `1 <= num.length <= 200` 
-  `num` 中只含有数字

**标签**
`字符串` `回溯` 


##### solution
```python
#
# @lc app=leetcode.cn id=842 lang=python3
#
# [842] 将数组拆分成斐波那契序列
# https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/dfshui-su-yong-quan-ju-bian-liang-resji-lu-fu-he-t/
class Solution:
    def splitIntoFibonacci(self, S):
        self.res = []
        num = S
        def dfs(num, count):
            if count >= 3 and len(num) == 0:
                return True
            for i in range(1, len(num)+1):
                if int(num[:i]) > 2**31-1:
                    break
                if i > 1 and num[0] == '0':
                    continue
                if count < 2:
                    self.res.append(int(num[:i]))
                    if dfs(num[i:], count+1):
                        return True
                    self.res.pop()
                else:
                    if self.res[-1] + self.res[-2] == int(num[:i]):
                        self.res.append(int(num[:i]))
                        if dfs(num[i:], count+1):
                            return True
                        self.res.pop()
            return False
        if dfs(num, 0):
            return self.res
        else:
            return []
# print(Solution().splitIntoFibonacci("123456579"))
```
>