---
layout:     post   				    # 使用的布局（不需要改）
title:      leetcode-分组刷题-数据结构 				# 标题 
subtitle:    #副标题
date:       2022-02-27 				# 时间
author:     FishRedLeaf 						# 作者
header-img: iu_img/my_iu_7.png 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - DSA与刷题/leetcode
---

[toc]

# 分组刷题-数据结构

## 1数组
### 哈希
#### 1.两数之和
[https://leetcode-cn.com/problems/two-sum](https://leetcode-cn.com/problems/two-sum) 
###### 原题
给定一个整数数组 `nums`  和一个整数目标值 `target` ，请你在该数组中找出 **和为目标值** *`target`*   的那  **两个**  整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

 **示例 1：** 

```

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

```
 **示例 2：** 

```

输入：nums = [3,2,4], target = 6
输出：[1,2]

```
 **示例 3：** 

```

输入：nums = [3,3], target = 6
输出：[0,1]

```


 **提示：** 
-  `2 <= nums.length <= 10^4` 
-  `-10^9 <= nums[i] <= 10^9` 
-  `-10^9 <= target <= 10^9` 
-  **只会存在一个有效答案** 
 **进阶：** 你可以想出一个时间复杂度小于 `O(n^2)` 的算法吗？


**标签**
`数组` `哈希表` 


##### solution
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        d = {}
        for i, n in enumerate(nums):
            if target - n in d:
                return [d[target - n], i]
            d[n] = i
```
>
#### 36.有效的数独
[https://leetcode-cn.com/problems/valid-sudoku](https://leetcode-cn.com/problems/valid-sudoku) 
###### 原题
请你判断一个 `9 x 9` 的数独是否有效。只需要 **根据以下规则** ，验证已经填入的数字是否有效即可。
- 数字 `1-9` 在每一行只能出现一次。
- 数字 `1-9` 在每一列只能出现一次。
- 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）


 **注意：** 
- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 空白格用 `'.'` 表示。

 **示例 1：** 
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzta28wn9tj206y06ymxb.jpg" style="height:250px; width:250px" />

```

输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true

```
 **示例 2：** 

```

输入：board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```


 **提示：** 
-  `board.length == 9` 
-  `board[i].length == 9` 
-  `board[i][j]` 是一位数字（ `1-9` ）或者 `'.'` 

**标签**
`数组` `哈希表` `矩阵` 


##### solution
```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        n = len(board)
        row = [set() for _ in range(n)]
        col = [set() for _ in range(n)]
        block = [set() for _ in range(n)]

        for i in range(n):
            for j in range(n):
                z = i // 3 * 3 + j // 3
                v = board[i][j]
                if v == ".":
                    continue
                if v in row[i] or v in col[j] or v in block[z]:
                    return False
                row[i].add(v)
                col[j].add(v)
                block[z].add(v)
        return True
```
>
#### 169.求众数
[https://leetcode-cn.com/problems/majority-element](https://leetcode-cn.com/problems/majority-element) 
###### 原题
给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于**   `⌊ n/2 ⌋`  的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

 **示例 1：** 

```

输入：[3,2,3]
输出：3
```
 **示例 2：** 

```

输入：[2,2,1,1,1,2,2]
输出：2

```


 **进阶：** 
- 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

**标签**
`数组` `哈希表` `分治` `计数` `排序` 

##### solution 摩尔投票法

https://cloud.tencent.com/developer/article/1600607

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        res, cnt = None, 0
        for n in nums:
            if cnt == 0:
                res, cnt = n, 1
                continue
            if res == n:
                cnt += 1
            else:
                cnt -= 1
        return res
```
>
#### 217.存在重复元素
[https://leetcode-cn.com/problems/contains-duplicate](https://leetcode-cn.com/problems/contains-duplicate) 
###### 原题
给你一个整数数组 `nums` 。如果任一值在数组中出现 **至少两次** ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 。


 **示例 1：** 

```

输入：nums = [1,2,3,1]
输出：true
```
 **示例 2：** 

```

输入：nums = [1,2,3,4]
输出：false
```
 **示例 3：** 

```

输入：nums = [1,1,1,3,3,4,3,2,4,2]
输出：true
```


 **提示：** 
-  `1 <= nums.length <= 10^5` 
-  `-10^9 <= nums[i] <= 10^9` 

**标签**
`数组` `哈希表` `排序` 


##### solution
```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        d = {}
        for n in nums:
            d[n] = d.get(n, 0) + 1
            if d[n] > 1:
                return True
        return False
```
>
#### 349.两个数组的交集
[https://leetcode-cn.com/problems/intersection-of-two-arrays](https://leetcode-cn.com/problems/intersection-of-two-arrays) 
###### 原题
给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

 

 **示例 1：** 

```

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]

```
 **示例 2：** 

```

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的

```


 **提示：** 
-  `1 <= nums1.length, nums2.length <= 1000` 
-  `0 <= nums1[i], nums2[i] <= 1000` 

**标签**
`数组` `哈希表` `双指针` `二分查找` `排序` 


##### solution
```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        # method1

        # return list(set(nums1) & set(nums2))

        nums1_set = set(nums1)
        res_set = set()
        for n in nums2:
            if n in nums1_set:
                res_set.add(n)
        return list(res_set)
```
>
#### 350.两个数组的交集2
[https://leetcode-cn.com/problems/intersection-of-two-arrays-ii](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii) 
###### 原题
给你两个整数数组 `nums1` 和 `nums2` ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

 

 **示例 1：** 

```

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]

```
 **示例 2:** 

```

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```


 **提示：** 
-  `1 <= nums1.length, nums2.length <= 1000` 
-  `0 <= nums1[i], nums2[i] <= 1000` 


 ** **进阶** ：** 
- 如果给定的数组已经排好序呢？你将如何优化你的算法？
- 如果 `nums1` 的大小比 `nums2` 小，哪种方法更优？
- 如果 `nums2` 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

**标签**
`数组` `哈希表` `双指针` `二分查找` `排序` 


##### solution
```python
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1_dict = Counter(nums1)
        res = []
        for n in nums2:
            if n in nums1_dict:
                res.append(n)
                nums1_dict[n] -= 1
                if nums1_dict[n] == 0:
                    del nums1_dict[n]
        return res
print(Solution().intersection([1,2,2,1], [2,2]))
```
>
### 找规律
#### 48.旋转图像
[https://leetcode-cn.com/problems/rotate-image](https://leetcode-cn.com/problems/rotate-image) 
###### 原题
给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 **<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。 **请不要** 使用另一个矩阵来旋转图像。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" style="height: 188px; width: 500px;" />
```

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" style="height: 201px; width: 500px;" />
```

输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

```


 **提示：** 
-  `n == matrix.length == matrix[i].length` 
-  `1 <= n <= 20` 
-  `-1000 <= matrix[i][j] <= 1000` 



**标签**
`数组` `数学` `矩阵` 


##### solution
```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """  

        1  2  3  4  

        5  6  7  8  

        9  10 11 12  

        13 14 15 16  

        2 8 15 9  

        (0, 1) (1, 3) (3, 2) (2, 0)  

        """  

        n = len(matrix)
        for i in range(n // 2):
            for j in range((n + 1) // 2):
                tmp = matrix[i][j]
                matrix[i][j] = matrix[n - j - 1][i]
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j -1]
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]
                matrix[j][n - i - 1] = tmp

    def rotate1(self, matrix: List[List[int]]) -> None:
        """  

        Do not return anything, modify matrix in-place instead.  

        """  
        
        # 1 将矩阵进行上下翻转  
        
        # 2 将矩阵沿着轴对角线轴对称的元素交换  
        
        n = len(matrix)
        for i in range(n // 2):
            matrix[i], matrix[n - i - 1] = matrix[n - i - 1], matrix[i]
        
        for i in range(n):
            for j in range(i+1, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
```
>
#### 54.螺旋矩阵
[https://leetcode-cn.com/problems/spiral-matrix](https://leetcode-cn.com/problems/spiral-matrix) 
###### 原题
给你一个 `m` 行 `n` 列的矩阵  `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" style="width: 242px; height: 242px;" />
```

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" style="width: 322px; height: 242px;" />
```

输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]

```


 **提示：** 
-  `m == matrix.length` 
-  `n == matrix[i].length` 
-  `1 <= m, n <= 10` 
-  `-100 <= matrix[i][j] <= 100` 

**标签**
`数组` `矩阵` `模拟` 


##### solution
```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
      	# 用四个变量来控制边界，然后因为方向总是：→↓←↑ 左右下上循环往复  
        
        if not matrix:
            return []
        direction = 0
        left_bound, right_bound = 0, len(matrix[0]) - 1
        up_bound, down_bound = 0, len(matrix) - 1
        res = []
        while True:
            if direction == 0:
                for i in range(left_bound, right_bound+1):
                    res.append(matrix[up_bound][i])
                up_bound += 1
            elif direction == 1:
                for i in range(up_bound, down_bound+1):
                    res.append(matrix[i][right_bound])
                right_bound -= 1
            elif direction == 2:
                for i in range(right_bound, left_bound-1, -1):
                    res.append(matrix[down_bound][i])
                down_bound -= 1
            else:
                for i in range(down_bound, up_bound-1, -1):
                    res.append(matrix[i][left_bound])
                left_bound += 1
            if left_bound > right_bound or up_bound > down_bound:
                return res
            direction = (1 + direction) % 4
```
>
#### 59.螺旋矩阵2
[https://leetcode-cn.com/problems/spiral-matrix-ii](https://leetcode-cn.com/problems/spiral-matrix-ii) 
###### 原题
给你一个正整数  `n` ，生成一个包含 `1` 到  `n^2`  所有元素，且元素按顺时针顺序螺旋排列的  `n x n` 正方形矩阵 `matrix` 。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" style="width: 242px; height: 242px;" />
```

输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]

```
 **示例 2：** 

```

输入：n = 1
输出：[[1]]

```


 **提示：** 
-  `1 <= n <= 20` 

**标签**
`数组` `矩阵` `模拟` 


##### solution
```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        matrix = [[0] * n for _ in range(n)]
        direction = 0
        left_bound, right_bound = 0, n-1
        up_bound, down_bound = 0, n-1
        cur, loops = 1, n * n
        while cur <= loops:
            if direction == 0:
                for i in range(left_bound, right_bound+1):
                    matrix[up_bound][i] = cur
                    cur += 1
                up_bound += 1
            elif direction == 1:
                for i in range(up_bound, down_bound+1):
                    matrix[i][right_bound] = cur
                    cur += 1
                right_bound -= 1
            elif direction == 2:
                for i in range(right_bound, left_bound-1, -1):
                    matrix[down_bound][i] = cur
                    cur += 1
                down_bound -= 1
            else:
                for i in range(down_bound, up_bound-1, -1):
                    matrix[i][left_bound] = cur
                    cur += 1
                left_bound += 1
            if left_bound > right_bound or up_bound > down_bound:
                return matrix
            direction = (1 + direction) % 4
        return matrix
```
>
#### 73.矩阵置零
[https://leetcode-cn.com/problems/set-matrix-zeroes](https://leetcode-cn.com/problems/set-matrix-zeroes) 
###### 原题
给定一个 ` *m* x *n* ` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank">原地</a>** 算法 **。** 


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" style="width: 450px; height: 169px;" />
```

输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" style="width: 450px; height: 137px;" />
```

输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]

```


 **提示：** 
-  `m == matrix.length` 
-  `n == matrix[0].length` 
-  `1 <= m, n <= 200` 
-  `-2^31 <= matrix[i][j] <= 2^31 - 1` 


 **进阶：** 
- 一个直观的解决方案是使用 `O( *m* *n* )` 的额外空间，但这并不是一个好的解决方案。
- 一个简单的改进方案是使用 `O( *m* + *n* )` 的额外空间，但这仍然不是最好的解决方案。
- 你能想出一个仅使用常量空间的解决方案吗？

**标签**
`数组` `哈希表` `矩阵` 


##### solution
```python
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """  
        
        Do not return anything, modify matrix in-place instead.  
        
        """  
        
        m, n = len(matrix), len(matrix[0])
        row0, col0 = False, False
        for i in range(n):
            if matrix[0][i] == 0:
                row0 = True
                break
        
        for i in range(m):
            if matrix[i][0] == 0:
                col0 = True
                break
        
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == 0:
                    matrix[i][0] = matrix[0][j] = 0
        
        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][0] == 0 or matrix[0][j] == 0:
                    matrix[i][j] = 0
        
        if row0:
            for i in range(n):
                matrix[0][i] = 0
        
        if col0:
            for i in range(m):
                matrix[i][0] = 0
```
>
#### 74.搜索二维矩阵
[https://leetcode-cn.com/problems/search-a-2d-matrix](https://leetcode-cn.com/problems/search-a-2d-matrix) 
###### 原题
编写一个高效的算法来判断  `m x n`  矩阵中，是否存在一个目标值。该矩阵具有如下特性：
- 每行中的整数从左到右按升序排列。
- 每行的第一个整数大于前一行的最后一个整数。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" style="width: 322px; height: 242px;" />
```

输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true

```
 **示例 2：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzxy89x6elj208y06q3yj.jpg" style="width: 322px; height: 242px;" />
```

输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false

```


 **提示：** 
-  `m == matrix.length` 
-  `n == matrix[i].length` 
-  `1 <= m, n <= 100` 
-  `-10^4 <= matrix[i][j], target <= 10^4` 

**标签**
`数组` `二分查找` `矩阵` 


##### solution
```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        if not matrix or not matrix[0]:
            return False
        m, n = len(matrix), len(matrix[0])
        up, down = 0, m-1
        while up <= down:
            row_mid = up + ((down - up) >> 1)
            if matrix[row_mid][0] <= target <= matrix[row_mid][n -1]:
                left, right = 0, n-1
                while left <= right:
                    mid = left + ((right - left) >> 1)
                    if matrix[row_mid][mid] == target:
                        return True
                    elif matrix[row_mid][mid] < target:
                        left = mid + 1
                    else:
                        right = mid - 1
                return False
            elif matrix[row_mid][0] > target:
                down = row_mid - 1
            else:
                up = row_mid + 1
        return False
```
>
#### 238.除自身以数组的乘积
[https://leetcode-cn.com/problems/product-of-array-except-self](https://leetcode-cn.com/problems/product-of-array-except-self) 
###### 原题
给你一个整数数组 `nums` ，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。

题目数据 **保证** 数组 `nums` 之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请 **不要使用除法，** 且在 `O( *n* )` 时间复杂度内完成此题。

 

 **示例 1:** 

```

输入: nums = [1,2,3,4]
输出: [24,12,8,6]

```
 **示例 2:** 

```

输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]

```


 **提示：** 
-  `2 <= nums.length <= 10^5` 
-  `-30 <= nums[i] <= 30` 
-  **保证** 数组 `nums` 之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内


 **进阶：** 你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 **不被视为** 额外空间。）


**标签**
`数组` `前缀和` 


##### solution
```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        '''  
        
        2,3,4,5,6  
        
        step1: 1,2,6,24,120  
        
        step2: 360,120,30,6,1  
        
        res:   360,240,180,144,120  
        
        '''  
        
        n = len(nums)
        left, right = [1] * n, [1] * n
        for i in range(1, n):
            left[i] = left[i-1] * nums[i-1]
        for i in range(n-2, -1, -1):
            right[i] = right[i+1] * nums[i+1]
        res = []
        for i in range(n):
            res.append(left[i] * right[i])
        return res
```
>
#### 240.搜索二维矩阵2
[https://leetcode-cn.com/problems/search-a-2d-matrix-ii](https://leetcode-cn.com/problems/search-a-2d-matrix-ii) 
###### 原题
编写一个高效的算法来搜索 ` *m* x *n* ` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：
- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。


<b>示例 1：</b>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" />
```

输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true

```
<b>示例 2：</b>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg" />
```

输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false

```


 **提示：** 
-  `m == matrix.length` 
-  `n == matrix[i].length` 
-  `1 <= n, m <= 300` 
-  `-10^9 <= matrix[i][j] <= 10^9` 
- 每行的所有元素从左到右升序排列
- 每列的所有元素从上到下升序排列
-  `-10^9 <= target <= 10^9` 

**标签**
`数组` `二分查找` `分治` `矩阵` 


##### solution
```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        if not matrix:
            return False
        m, n = len(matrix), len(matrix[0])
        i, j = m-1, 0
        while i >= 0 and j <= n-1:
            if matrix[i][j] == target:
                return True
            elif matrix[i][j] < target:
                j += 1
            else:
                i -= 1
        return False
```
>
### 双指针
#### 11.盛最多水的容器
[https://leetcode-cn.com/problems/container-with-most-water](https://leetcode-cn.com/problems/container-with-most-water) 
###### 原题
给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

 **说明：** 你不能倾斜容器。

 

 **示例 1：** 

<img alt="" src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" />

```

输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```
 **示例 2：** 

```

输入：height = [1,1]
输出：1

```


 **提示：** 
-  `n == height.length` 
-  `2 <= n <= 10^5` 
-  `0 <= height[i] <= 10^4` 

**标签**
`贪心` `数组` `双指针` 


##### solution
```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left, right = 0, len(height)-1
        res = 0
        while left < right:
            cur_height = min(height[left], height[right])
            cur_width = right - left
            res = max(res, cur_height * cur_width)
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        return res
```
>
#### 15.三数之和
[https://leetcode-cn.com/problems/3sum](https://leetcode-cn.com/problems/3sum) 
###### 原题
给你一个包含 `n` 个整数的数组  `nums` ，判断  `nums`  中是否存在三个元素 *a，b，c ，* 使得  *a + b + c =* 0 ？请你找出所有和为 `0` 且不重复的三元组。

 **注意：** 答案中不可以包含重复的三元组。

 

 **示例 1：** 

```

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]

```
 **示例 2：** 

```

输入：nums = []
输出：[]

```
 **示例 3：** 

```

输入：nums = [0]
输出：[]

```


 **提示：** 
-  `0 <= nums.length <= 3000` 
-  `-10^5 <= nums[i] <= 10^5` 

**标签**
`数组` `双指针` `排序` 


##### solution
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        if n < 3:
            return []
        res = []
        nums.sort()
        for i in range(n-2):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            left, right = i+1, n-1
            while left < right:
                sum_ = nums[i] + nums[left] + nums[right]
                if sum_ == 0:
                    res.append([nums[i], nums[left], nums[right]])
                    left += 1
                    right -= 1
                    while left < right and nums[left] == nums[left-1]:
                        left += 1
                    while left < right and nums[right] == nums[right+1]:
                        right -= 1
                elif sum_ < 0:
                    left += 1
                else:
                    right -= 1
        return res
```
>
#### 16.最接近的三数之和
[https://leetcode-cn.com/problems/3sum-closest](https://leetcode-cn.com/problems/3sum-closest) 
###### 原题
给你一个长度为 `n` 的整数数组 `nums` 和 一个目标值 `target` 。请你从 `nums` 中选出三个整数，使它们的和与 `target` 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。

 

 **示例 1：** 

```

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。

```
 **示例 2：** 

```

输入：nums = [0,0,0], target = 1
输出：0

```


 **提示：** 
-  `3 <= nums.length <= 1000` 
-  `-1000 <= nums[i] <= 1000` 
-  `-10^4 <= target <= 10^4` 

**标签**
`数组` `双指针` `排序` 


##### solution
```python
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        n = len(nums)
        nums.sort()
        res, diff = None, float('inf')
        for i in range(n-2):
            left, right = i+1, n-1
            while left < right:
                sum_ = nums[i] + nums[left] + nums[right]
                if abs(sum_ - target) < diff:
                    res, diff = sum_, abs(sum_ - target)
                if sum_ == target:
                    return sum_
                elif sum_ < target:
                    left += 1
                else:
                    right -= 1
        return res
```
>
#### 26.删除排序数组中的重复项
[https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array) 
###### 原题
给你一个 **升序排列** 的数组 `nums` ，请你 **<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank"> 原地</a>** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 `k` 个元素，那么 `nums` 的前 `k` 个元素应该保存最终结果。

将最终结果插入 `nums` 的前 `k` 个位置后返回 `k` 。

不要使用额外的空间，你必须在 **<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank">原地 </a>修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

 **判题标准:** 

系统会用下面的代码来测试你的题解:

```

int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```
如果所有断言都通过，那么您的题解将被 **通过** 。

 

 **示例 1：** 

```

输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

```
 **示例 2：** 

```

输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。

```


 **提示：** 
-  `0 <= nums.length <= 3 * 10^4` 
-  `-10^4 <= nums[i] <= 10^4` 
-  `nums` 已按 **升序** 排列

**标签**
`数组` `双指针` 


##### solution
```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        i, j = 0, 1
        while j < len(nums):
            if nums[j] != nums[i]:
                nums[i+1] = nums[j]
                i += 1
            j += 1
        return i+1
```
>
#### 88.合并两个有序数组
[https://leetcode-cn.com/problems/merge-sorted-array](https://leetcode-cn.com/problems/merge-sorted-array) 
###### 原题
给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2` ，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

 **注意：** 最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况， `nums1` 的初始长度为 `m + n` ，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。 `nums2` 的长度为 `n` 。

 

 **示例 1：** 

```

输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。

```
 **示例 2：** 

```

输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。

```
 **示例 3：** 

```

输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。

```


 **提示：** 
-  `nums1.length == m + n` 
-  `nums2.length == n` 
-  `0 <= m, n <= 200` 
-  `1 <= m + n <= 200` 
-  `-10^9 <= nums1[i], nums2[j] <= 10^9` 


 **进阶：** 你可以设计实现一个时间复杂度为 `O(m + n)` 的算法解决此问题吗？


**标签**
`数组` `双指针` `排序` 


##### solution
```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """  
        
        Do not return anything, modify nums1 in-place instead.  
        
        """  
        
        i, j, k = m-1, n-1, m+n-1
        nums1[:] = nums1[:m] + nums2[:n]
        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
        while i >= 0:
            nums1[k] = nums1[i]
            k -= 1
            i -= 1
        while j >= 0:
            nums1[k] = nums2[j]
            k -= 1
            j -= 1
```
>
#### 283.移动零
[https://leetcode-cn.com/problems/move-zeroes](https://leetcode-cn.com/problems/move-zeroes) 
###### 原题
给定一个数组 `nums` ，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

 **请注意** ，必须在不复制数组的情况下原地对数组进行操作。

 

 **示例 1:** 

```

输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]

```
 **示例 2:** 

```

输入: nums = [0]
输出: [0]
```


 **提示** :
<meta charset="UTF-8" />
-  `1 <= nums.length <= 10^4` 
-  `-2^31 <= nums[i] <= 2^31 - 1` 


<b>进阶：</b>你能尽量减少完成的操作次数吗？


**标签**
`数组` `双指针` 


##### solution
```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """  
        Do not return anything, modify nums in-place instead.  
        """  
        i, j = 0, 0
        while j < len(nums):
            if nums[j] != 0:
                nums[i] = nums[j]
                i += 1
            j += 1
        nums[i:] = [0] * (len(nums) - i)
```
>
#### 392.判断子序列
[https://leetcode-cn.com/problems/is-subsequence](https://leetcode-cn.com/problems/is-subsequence) 
###### 原题
给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如， `"ace"` 是 `"abcde"` 的一个子序列，而 `"aec"` 不是）。

 **进阶：** 

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

 **致谢：** 

特别感谢 **** <a href="https://leetcode.com/pbrother/">@pbrother </a>添加此问题并且创建所有测试用例。

 

 **示例 1：** 

```

输入：s = "abc", t = "ahbgdc"
输出：true

```
 **示例 2：** 

```

输入：s = "axc", t = "ahbgdc"
输出：false

```


 **提示：** 
-  `0 <= s.length <= 100` 
-  `0 <= t.length <= 10^4` 
- 两个字符串都只由小写字符组成。

**标签**
`双指针` `字符串` `动态规划` 


##### solution
```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        i, j = 0, 0
        while i < len(s) and j < len(t):
            if s[i] == t[j]:
                i += 1
            j += 1
        return i == len(s)
```
>
### 其他
#### 31.下一个排列
[https://leetcode-cn.com/problems/next-permutation](https://leetcode-cn.com/problems/next-permutation) 
###### 原题
整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。
- 例如， `arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列： `[1,2,3]` 、 `[1,3,2]` 、 `[3,1,2]` 、 `[2,3,1]` 。
整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。
- 例如， `arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
- 类似地， `arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。
给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须 **<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank"> 原地 </a>** 修改，只允许使用额外常数空间。

 

 **示例 1：** 

```

输入：nums = [1,2,3]
输出：[1,3,2]

```
 **示例 2：** 

```

输入：nums = [3,2,1]
输出：[1,2,3]

```
 **示例 3：** 

```

输入：nums = [1,1,5]
输出：[1,5,1]

```


 **提示：** 
-  `1 <= nums.length <= 100` 
-  `0 <= nums[i] <= 100` 

**标签**
`数组` `双指针` 

##### solution

-   从右往左，寻找第一个降序的点，例如`[8,9,4,5,2,1]`, `5,2,1`是降序，找到4的索引partition
-   如果索引为-1，表示整个序列都是降序的，因此直接反转就行
-   否则在partition右边，从右往左找第一个比partition大的数，并交换，得到`[8,9,5,4,2,1]`
-   partition右边从降序改为升序，得到`[8,9,5,1,2,4]`

```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """  
        
        Do not return anything, modify nums in-place instead.  
        
        """  
        
        n = len(nums)

        partition = -1
        for i in range(n-1, -1, -1):
            if nums[i] > nums[i-1]:
                partition = i - 1
                break
        if partition == -1:
            nums[:] = nums[::-1]
            return
        
        for i in range(n-1, partition, -1):
            if nums[i] > nums[partition]:
                nums[i], nums[partition] = nums[partition], nums[i]
                break
        
        nums[partition+1:] = nums[partition+1:][::-1]
```
>
#### 41.缺失的第一个正数
[https://leetcode-cn.com/problems/first-missing-positive](https://leetcode-cn.com/problems/first-missing-positive) 
###### 原题
给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。
请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

 

 **示例 1：** 

```

输入：nums = [1,2,0]
输出：3

```
 **示例 2：** 

```

输入：nums = [3,4,-1,1]
输出：2

```
 **示例 3：** 

```

输入：nums = [7,8,9,11,12]
输出：1

```


 **提示：** 
-  `1 <= nums.length <= 5 * 10^5` 
-  `-2^31 <= nums[i] <= 2^31 - 1` 

**标签**
`数组` `哈希表` 

##### solution1 数和下标关联法

-   假设下标`i`位置的数是`x`，为了把数`x`放到下标`x-1`的位置，交换下标`i`和下标`x-1`的值，如果下标i位置的数仍然满足条件`1 <= nums[i] <= n and nums[i] != nums[nums[i] - 1]`，则继续交换

```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:

        def swap(nums, i, j):
            nums[i], nums[j] = nums[j], nums[i]

        n = len(nums)
        for i in range(n):
            while 1 <= nums[i] <= n and nums[i] != nums[nums[i] - 1]:
                swap(nums, i, nums[i] - 1)
        for i in range(n):
            if i+1 != nums[i]:
                return i+1
        return n+1
```

##### solution2 添加负号法

-   检查是否有第一个正整数1。
    -   如果没有，1 即为答案。
    -   如果有1
        -   如果 nums = [1]，答案即为 2
        -   如果数组长度大于1
            -   将负数、0和大于`n`的数都替换为1
            -   遍历数组。当读到数字 a 时，替换第 a 个元素的符号。注意重复元素：只能改变一次符号。由于没有下标`n`，使用下标 0 位置保存是否存在数字 n。  
            -   从下标为1的位置遍历数组，返回第一个正数元素的下标。 
            -   如果下标`1 ~ (n-1)`都为负数，那么检查`nums[0]`是否为正数，如果是则返回`n`，如果不是返回`n+1`

```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        if 1 not in nums:
            return 1
        if n == 1:
            return 2
        for i in range(n):
            if nums[i] <= 0 or nums[i] > n:
                nums[i] = 1
        for i in range(n):
            a = abs(nums[i])
            if a == n:
                nums[0] = -abs(nums[0])
            else:
                nums[a] = -abs(nums[a])
        for i in range(1, n):
            if nums[i] > 0:
                return i
        if nums[0] > 0:
            return n
        return n+1
print(Solution().firstMissingPositive2([1,3,-1,5,2]))
```
>
#### 56.合并区间
[https://leetcode-cn.com/problems/merge-intervals](https://leetcode-cn.com/problems/merge-intervals) 
###### 原题
以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

 

 **示例 1：** 

```

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

```
 **示例 2：** 

```

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```


 **提示：** 
-  `1 <= intervals.length <= 10^4` 
-  `intervals[i].length == 2` 
-  `0 <= start<sub>i</sub> <= end<sub>i</sub> <= 10^4` 

**标签**
`数组` `排序` 


##### solution
```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key = lambda x: x[0])
        res = []
        for interval in intervals:
            if res and res[-1][1] >= interval[0]:
                res[-1] = [res[-1][0], max(res[-1][1], interval[1])]
            else:
                res.append(interval)
        return res
```
>
#### 118.杨辉三角
[https://leetcode-cn.com/problems/pascals-triangle](https://leetcode-cn.com/problems/pascals-triangle) 
###### 原题
给定一个非负整数  *`numRows` ，* 生成「杨辉三角」的前  *`numRows`  * 行。

<small>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</small>

<img alt="" src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" />

 

 **示例 1:** 

```

输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]

```
 **示例 2:** 

```

输入: numRows = 1
输出: [[1]]

```


 **提示:** 
-  `1 <= numRows <= 30` 

**标签**
`数组` `动态规划` 


##### solution
```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        if numRows >= 1:
            res.append([1])
        if numRows >= 2:
            res.append([1, 1])
        for i in range(3, numRows+1):
            tmp = [1]
            for i in range(1, len(res[-1])):
                tmp.append(res[-1][i] + res[-1][i-1])
            tmp.append(1)
            res.append(tmp)
        return res
```
>
#### 189.旋转数组
[https://leetcode-cn.com/problems/rotate-array](https://leetcode-cn.com/problems/rotate-array) 
###### 原题
给你一个数组，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

 

 **示例 1:** 

```

输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]

```
 **示例 2:** 

```

输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```


 **提示：** 
-  `1 <= nums.length <= 10^5` 
-  `-2^31 <= nums[i] <= 2^31 - 1` 
-  `0 <= k <= 10^5` 


 **进阶：** 
- 尽可能想出更多的解决方案，至少有 **三种** 不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 `O(1)` 的 **原地** 算法解决这个问题吗？

**标签**
`数组` `数学` `双指针` 


##### solution
```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """  
        
        Do not return anything, modify nums in-place instead.  
        
        """  
        
        # method1  
        
        # n = len(nums)  
        
        # k %= n  
        
        # nums[:] = nums[n-k:] + nums[:n-k]  
        
  
        n = len(nums)
        k %= n
        nums[n-k:] = nums[n-k:][::-1]
        nums[:n-k] = nums[:n-k][::-1]
        nums[:] = nums[::-1]
```
>
#### 268.缺失数字
[https://leetcode-cn.com/problems/missing-number](https://leetcode-cn.com/problems/missing-number) 
###### 原题
给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。


 **示例 1：** 

```

输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```
 **示例 2：** 

```

输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```
 **示例 3：** 

```

输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
```
 **示例 4：** 

```

输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
```


 **提示：** 
-  `n == nums.length` 
-  `1 <= n <= 10^4` 
-  `0 <= nums[i] <= n` 
-  `nums` 中的所有数字都 **独一无二** 


 **进阶：** 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?


**标签**
`位运算` `数组` `哈希表` `数学` `排序` 


##### solution
```python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        res = n
        for i in range(n):
            res ^= i
        for i in nums:
            res ^= i
        return res
```
>
#### 287.寻找重复数
[https://leetcode-cn.com/problems/find-the-duplicate-number](https://leetcode-cn.com/problems/find-the-duplicate-number) 
###### 原题
给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n` ），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

 

 **示例 1：** 

```

输入：nums = [1,3,4,2,2]
输出：2

```
 **示例 2：** 

```

输入：nums = [3,1,3,4,2]
输出：3

```


 **提示：** 
-  `1 <= n <= 10^5` 
-  `nums.length == n + 1` 
-  `1 <= nums[i] <= n` 
-  `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次** 


<b>进阶：</b>
- 如何证明 `nums` 中至少存在一个重复的数字?
- 你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？

**标签**
`位运算` `数组` `双指针` `二分查找` 

##### solution 二分查找 

时间复杂度`O(nlogn)`空间复杂度`O(1)`

-   https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/

-   本质是使用二分在`[1,n]`中找到一个数
-   如果在`[1,mid]`之间有超过mid个数小于等于mid，则这个重复的数一定在`[1,mid] `

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        n = len(nums) - 1
        left, right = 1, n
        while left < right:
            mid = left + ((right - left) >> 1)
            cnt = 0
            for a in nums:
                cnt += a <= mid
            if cnt > mid:
                right = mid
            else:
                left = mid + 1
        return left
```



##### solution 链表快慢指针找环的入口

-   https://leetcode-cn.com/problems/find-the-duplicate-number/solution/287xun-zhao-zhong-fu-shu-by-kirsche/
-   索引和数之间建立映射，n -> nums[n]，形成链表
-   如果有重复数，那么多个索引会指向同一个数，形成链表中的环，环的入口就是重复的数

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow, fast = nums[0], nums[nums[0]]
        while slow != fast:
            slow = nums[slow]
            fast = nums[nums[fast]]
        
        cur = 0
        while slow != cur:
            slow = nums[slow]
            cur = nums[cur]
        return cur
```
>
## 2字符串
#### 8.字符串转换整数-atoi
[https://leetcode-cn.com/problems/string-to-integer-atoi](https://leetcode-cn.com/problems/string-to-integer-atoi) 
##### 原题
请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 `atoi` 函数）。

函数 `myAtoi(string s)` 的算法如下：
- 读入字符串并丢弃无用的前导空格
- 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
- 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
- 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 `0` 。必要时更改符号（从步骤 2 开始）。
- 如果整数数超过 32 位有符号整数范围 `[−2^31,  2^31 − 1]` ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 `−2^31` 的整数应该被固定为 `−2^31` ，大于 `2^31 − 1` 的整数应该被固定为 `2^31 − 1` 。
- 返回整数作为最终结果。
 **注意：** 
- 本题中的空白字符只包括空格字符 `' '` 。
- 除前导空格或数字后的其余字符串外， **请勿忽略** 任何其他字符。


 **示例 1：** 

```

输入：s = "42"
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
解析得到整数 42 。
由于 "42" 在范围 [-2^31, 2^31 - 1] 内，最终结果为 42 。
```
 **示例 2：** 

```

输入：s = "   -42"
输出：-42
解释：
第 1 步："   -42"（读入前导空格，但忽视掉）
            ^
第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   -42"（读入 "42"）
               ^
解析得到整数 -42 。
由于 "-42" 在范围 [-2^31, 2^31 - 1] 内，最终结果为 -42 。

```
 **示例 3：** 

```

输入：s = "4193 with words"
输出：4193
解释：
第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）
             ^
解析得到整数 4193 。
由于 "4193" 在范围 [-2^31, 2^31 - 1] 内，最终结果为 4193 。

```


 **提示：** 
-  `0 <= s.length <= 200` 
-  `s` 由英文字母（大写和小写）、数字（ `0-9` ）、 `' '` 、 `'+'` 、 `'-'` 和 `'.'` 组成

**标签**
`字符串` 


##### solution
```python
class Solution:
    def myAtoi(self, s: str) -> int:
        s = s.lstrip()
        if not s:
            return 0
        symbol = True
        if s[0] in ["+", "-"]:
            if s[0] == "-":
                symbol = False
            s = s[1:]
        
        i = 0
        res = 0
        while i < len(s) and s[i].isdigit():
            res = 10 * res + int(s[i])
            i += 1
        
        res = res if symbol else -res
        if res > 2**31-1:
            res = 2**31-1
        if res < -2**31:
            res = -2**31
        
        return res
```
>
#### 13.罗马数字转整数
[https://leetcode-cn.com/problems/roman-to-integer](https://leetcode-cn.com/problems/roman-to-integer) 
##### 原题
罗马数字包含以下七种字符: `I` ， `V` ， `X` ， `L` ， `C` ， `D` 和 `M` 。

```

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```
例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。 `12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII` , 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII` ，而是 `IV` 。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX` 。这个特殊的规则只适用于以下六种情况：
-  `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
-  `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
-  `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。

 

 **示例 1:** 

```

输入: s = "III"
输出: 3
```
 **示例 2:** 

```

输入: s = "IV"
输出: 4
```
 **示例 3:** 

```

输入: s = "IX"
输出: 9
```
 **示例 4:** 

```

输入: s = "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.

```
 **示例 5:** 

```

输入: s = "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```


 **提示：** 
-  `1 <= s.length <= 15` 
-  `s` 仅含字符 `('I', 'V', 'X', 'L', 'C', 'D', 'M')` 
- 题目数据保证 `s` 是一个有效的罗马数字，且表示整数在范围 `[1, 3999]` 内
- 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
- IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
- 关于罗马数字的详尽书写规则，可以参考 <a href="https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97#knowledge_article">罗马数字 - Mathematics </a>。

**标签**
`哈希表` `数学` `字符串` 


##### solution
```python
class Solution:
    def romanToInt(self, s: str) -> int:
        d = {'I':1,
            'V':5,
            'X':10,
            'L':50,
            'C':100,
            'D':500,
            'M':1000}
        res = 0
        for i, c in enumerate(s):
            if i > 0 and d[c] > d[s[i-1]]:
                res += d[c] - 2 * d[s[i-1]]
            else:
                res += d[c]
        return res
```
>
#### 14.最长公共前缀
[https://leetcode-cn.com/problems/longest-common-prefix](https://leetcode-cn.com/problems/longest-common-prefix) 
##### 原题
编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""` 。

 

 **示例 1：** 

```

输入：strs = ["flower","flow","flight"]
输出："fl"

```
 **示例 2：** 

```

输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```


 **提示：** 
-  `1 <= strs.length <= 200` 
-  `0 <= strs[i].length <= 200` 
-  `strs[i]` 仅由小写英文字母组成

**标签**
`字符串` 


##### solution
```python
#
# @lc app=leetcode.cn id=14 lang=python3
#
# [14] 最长公共前缀
#
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ''
        i, j, id = 0, 0, 0
        while j < len(strs) and i < len(strs[j]):
            if j == 0:
                char = strs[j][i]
            else:
                if char != strs[j][i]:
                    # 直接退出while循环
                    break
            if j == len(strs)-1:
                i += 1
                j = 0
                id += 1
            else:
                j += 1
        return strs[0][:id]
# print(Solution().longestCommonPrefix(["flower","flow","flight"]))
```
>
#### 28.实现str-str
[https://leetcode-cn.com/problems/implement-strstr](https://leetcode-cn.com/problems/implement-strstr) 
##### 原题
实现 <a href="https://baike.baidu.com/item/strstr/811469" target="_blank">strStr()</a> 函数。

给你两个字符串  `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  `-1` **** 。

 

 **说明：** 

当  `needle`  是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当  `needle`  是空字符串时我们应当返回 0 。这与 C 语言的 <a href="https://baike.baidu.com/item/strstr/811469" target="_blank">strstr()</a> 以及 Java 的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)" target="_blank">indexOf()</a> 定义相符。

 

 **示例 1：** 

```

输入：haystack = "hello", needle = "ll"
输出：2

```
 **示例 2：** 

```

输入：haystack = "aaaaa", needle = "bba"
输出：-1

```
 **示例 3：** 

```

输入：haystack = "", needle = ""
输出：0

```


 **提示：** 
-  `0 <= haystack.length, needle.length <= 5 * 10^4` 
-  `haystack` 和 `needle` 仅由小写英文字符组成

**标签**
`双指针` `字符串` `字符串匹配` 


##### solution
```python
#
# @lc app=leetcode.cn id=28 lang=python3
#
# [28] 实现strStr()
#
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if not needle:
            return 0
        l1, l2 = len(haystack), len(needle)
        if l2 > l1:
            return -1
        for i in range(l1-l2+1):
            if needle == haystack[i:i+l2]:
                return i
        return -1
```
>
#### 38.报数
[https://leetcode-cn.com/problems/count-and-say](https://leetcode-cn.com/problems/count-and-say) 
##### 原题
给定一个正整数 `n` ，输出外观数列的第 `n` 项。

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

你可以将其视作是由递归公式定义的数字字符串序列：
-  `countAndSay(1) = "1"` 
-  `countAndSay(n)` 是对 `countAndSay(n-1)` 的描述，然后转换成另一个数字字符串。
前五项如下：

```

1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"

```
要 **描述** 一个数字字符串，首先要将字符串分割为 **最小** 数量的组，每个组都由连续的最多 **相同字符** 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。

例如，数字字符串 `"3322251"` 的描述如下图：
<img alt="" src="https://pic.leetcode-cn.com/1629874763-TGmKUh-image.png" style="width: 581px; height: 172px;" />


 **示例 1：** 

```

输入：n = 1
输出："1"
解释：这是一个基本样例。

```
 **示例 2：** 

```

输入：n = 4
输出："1211"
解释：
countAndSay(1) = "1"
countAndSay(2) = 读 "1" = 一 个 1 = "11"
countAndSay(3) = 读 "11" = 二 个 1 = "21"
countAndSay(4) = 读 "21" = 一 个 2 + 一 个 1 = "12" + "11" = "1211"

```


 **提示：** 
-  `1 <= n <= 30` 

**标签**
`字符串` 


##### solution
```python
#
# @lc app=leetcode.cn id=38 lang=python3
#
# [38] 报数
#
class Solution:
    def countAndSay(self, n: int) -> str:
        ans = '1'
        n -= 1
        while n > 0:
            pre = ans[0]
            res = ''
            count = 1
            for i in range(1, len(ans)):
                if ans[i] == pre:
                    count += 1
                else:
                    res += str(count) + pre
                    pre = ans[i]
                    count = 1
            res += str(count) + pre
            ans = res
            n -= 1
        return ans
```
>
#### 43.字符串相乘
[https://leetcode-cn.com/problems/multiply-strings](https://leetcode-cn.com/problems/multiply-strings) 
##### 原题
给定两个以字符串形式表示的非负整数 `num1` 和 `num2` ，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

 **注意：** 不能使用任何内置的 BigInteger 库或直接将输入转换为整数。

 

 **示例 1:** 

```

输入: num1 = "2", num2 = "3"
输出: "6"
```
 **示例 2:** 

```

输入: num1 = "123", num2 = "456"
输出: "56088"
```


 **提示：** 
-  `1 <= num1.length, num2.length <= 200` 
-  `num1` 和 `num2` 只能由数字组成。
-  `num1` 和 `num2` 都不包含任何前导零，除了数字0本身。

**标签**
`数学` `字符串` `模拟` 


##### solution
```python
#
# @lc app=leetcode.cn id=43 lang=python3
#
# [43] 字符串相乘
#
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        num1, num2 = num1[::-1], num2[::-1]
        l1, l2 = len(num1), len(num2)
        res = [0] * (l1 + l2)
        for i in range(l1):
            for j in range(l2):
                res[i+j] += int(num1[i]) * int(num2[j])
#        print(res)
        ans = []
        for i in range(len(res)):
            if i < len(res)-1:
                res[i+1] += res[i] // 10
            ans.append(str(res[i]%10))
        # >1是为了保证0+0=0，让输出为'0'而不是''
        while len(ans) > 1 and ans[-1] == '0':
            ans.pop(-1)
#        print(ans)
        return ''.join(ans[::-1])
```
>
#### 49.字母异位词分组
[https://leetcode-cn.com/problems/group-anagrams](https://leetcode-cn.com/problems/group-anagrams) 
##### 原题
给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

 **字母异位词** 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

 

 **示例 1:** 

```

输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```
 **示例 2:** 

```

输入: strs = [""]
输出: [[""]]

```
 **示例 3:** 

```

输入: strs = ["a"]
输出: [["a"]]
```


 **提示：** 
-  `1 <= strs.length <= 10^4` 
-  `0 <= strs[i].length <= 100` 
-  `strs[i]` 仅包含小写字母

**标签**
`哈希表` `字符串` `排序` 


##### solution
```python
#
# @lc app=leetcode.cn id=49 lang=python3
#
# [49] 字母异位词分组
#
class Solution:
    # 使用26个字母的列表作为哈希值
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        from collections import defaultdict
        res = defaultdict(list)
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            res[tuple(count)].append(s)
        return list(res.values())
    # 使用字母排列的最小序作为每个字符串的哈希值
    # def groupAnagrams2(self, strs):
    #     """
    #     :type strs: List[str]
    #     :rtype: List[List[str]]
    #     """
    #     ddd = {} #"aet" : ["ate","eat","tea"] 键为最小序
    #     for s in strs:
    #         key = ''.join(sorted(list(s)))
    #         if key in ddd:
    #             ddd[key].append(s)
    #         else:
    #             ddd[key] = [s]
    #     return ddd.values()
    # 超时
    # def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
    #     l = len(strs)
    #     d = [{} for _ in range(l)]
    #     for i in range(l):
    #         s = strs[i]
    #         for c in s:
    #             d[i][c] = d[i].get(c, 0) + 1
    #     unique_d = []
    #     for k in d:
    #         if k in unique_d:
    #             continue
    #         else:
    #             unique_d.append(k)
    #     res = [[] for _ in range(len(unique_d))]
    #     for i in range(l):
    #         idx = unique_d.index(d[i])
    #         res[idx].append(strs[i])
    #     return res
```
>
#### 76.最小覆盖子串
[https://leetcode-cn.com/problems/minimum-window-substring](https://leetcode-cn.com/problems/minimum-window-substring) 
##### 原题
给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

 

 **注意：** 
- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。


 **示例 1：** 

```

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"

```
 **示例 2：** 

```

输入：s = "a", t = "a"
输出："a"

```
 **示例 3:** 

```

输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```


 **提示：** 
-  `1 <= s.length, t.length <= 10^5` 
-  `s` 和 `t` 由英文字母组成

 **进阶：** 你能设计一个在 `o(n)` 时间内解决此问题的算法吗？

**标签**
`哈希表` `字符串` `滑动窗口` 


##### solution
```python
#
# @lc app=leetcode.cn id=76 lang=python3
#
# [76] 最小覆盖子串
#
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if not s or not t:
            return ""
        d = {}
        for c in t:
            d[c] = d.get(c, 0) + 1
        # from collections import Counter
        # d = Counter(t)
        l, r = 0, 0
        ans = float('inf'), None, None
        required = len(d)
        formed = 0
        window = {}
        while r < len(s):
            c = s[r]
            window[c] = window.get(c, 0) + 1
            if c in d and d[c] == window[c]:
                formed += 1
            while l <= r and required == formed:
                c = s[l]
                if r-l+1 < ans[0]:
                    ans = (r-l+1, l, r)
                window[c] -= 1
                if c in d and window[c] < d[c]:
                    formed -= 1
                l += 1
            r += 1
        return "" if ans[0] == float('inf') else s[ans[1]:ans[2]+1]
```
>
#### 125.验证回文串
[https://leetcode-cn.com/problems/valid-palindrome](https://leetcode-cn.com/problems/valid-palindrome) 
##### 原题
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

 **说明：** 本题中，我们将空字符串定义为有效的回文串。

 

 **示例 1:** 

```

输入: "A man, a plan, a canal: Panama"
输出: true
解释："amanaplanacanalpanama" 是回文串

```
 **示例 2:** 

```

输入: "race a car"
输出: false
解释："raceacar" 不是回文串

```


 **提示：** 
-  `1 <= s.length <= 2 * 10^5` 
- 字符串 `s` 由 ASCII 字符组成

**标签**
`双指针` `字符串` 


##### solution
```python
#
# @lc app=leetcode.cn id=125 lang=python3
#
# [125] 验证回文串
#
class Solution:
    def isPalindrome(self, s: str) -> bool:
        if not s:
            return True
        import re
        s = re.sub('[^0-9A-Za-z]', '' , s)
        return s.lower() == s.lower()[::-1]
```
>
#### 151.翻转字符串里的单词
[https://leetcode-cn.com/problems/reverse-words-in-a-string](https://leetcode-cn.com/problems/reverse-words-in-a-string) 
##### 原题
给你一个字符串 `s` ，逐个翻转字符串中的所有 **单词** 。

 **单词** 是由非空格字符组成的字符串。 `s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

请你返回一个翻转 `s` 中单词顺序并用单个空格相连的字符串。

 **说明：** 
- 输入字符串 `s` 可以在前面、后面或者单词间包含多余的空格。
- 翻转后单词间应当仅用一个空格分隔。
- 翻转后的字符串中不应包含额外的空格。


 **示例 1：** 

```

输入：s = "the sky is blue"
输出："blue is sky the"

```
 **示例 2：** 

```

输入：s = "  hello world  "
输出："world hello"
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。

```
 **示例 3：** 

```

输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，将翻转后单词间的空格减少到只含一个。

```
 **示例 4：** 

```

输入：s = "  Bob    Loves  Alice   "
输出："Alice Loves Bob"

```
 **示例 5：** 

```

输入：s = "Alice does not even like bob"
输出："bob like even not does Alice"

```


 **提示：** 
-  `1 <= s.length <= 10^4` 
-  `s` 包含英文大小写字母、数字和空格 `' '` 
-  `s` 中 **至少存在一个** 单词


 **进阶：** 
- 请尝试使用  ` *O* (1)` 额外空间复杂度的原地解法。

**标签**
`双指针` `字符串` 


##### solution
```python
#
# @lc app=leetcode.cn id=151 lang=python3
#
# [151] 翻转字符串里的单词
#
class Solution:
    def reverseWords(self, s: str) -> str:
        res, tmp = [], ''
        for c in s.strip():
            if c != ' ':
                tmp += c
            else:
                if tmp.strip():
                    res.append(tmp)
                    tmp = ''
        if tmp.strip():
            res.append(tmp)
        ans = ''
        for i in res[::-1]:
            ans += i + ' '
        return ans[:-1]
```
>
#### 242.有效的字母异位词
[https://leetcode-cn.com/problems/valid-anagram](https://leetcode-cn.com/problems/valid-anagram) 
##### 原题
给定两个字符串 ` *s* ` 和 ` *t* ` ，编写一个函数来判断 ` *t* ` 是否是 ` *s* ` 的字母异位词。

 **注意：** 若  ` *s* ` 和 ` *t* ` * * 中每个字符出现的次数都相同，则称  ` *s* ` 和 ` *t* ` * * 互为字母异位词。

 

 **示例 1:** 

```

输入: s = "anagram", t = "nagaram"
输出: true

```
 **示例 2:** 

```

输入: s = "rat", t = "car"
输出: false
```


 **提示:** 
-  `1 <= s.length, t.length <= 5 * 10^4` 
-  `s` 和 `t`  仅包含小写字母


 **进阶: ** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？


**标签**
`哈希表` `字符串` `排序` 


##### solution
```python
#
# @lc app=leetcode.cn id=242 lang=python3
#
# [242] 有效的字母异位词
#
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        d = {}
        for c in s:
            d[c] = d.get(c, 0) + 1
        for c in t:
            if c not in d:
                return False
            d[c] -= 1
            if d[c] == 0:
                d.pop(c)
        if not d:
            return True
        return False
```
>
#### 344.反转字符串
[https://leetcode-cn.com/problems/reverse-string](https://leetcode-cn.com/problems/reverse-string) 
##### 原题
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须 **<a href="https://baike.baidu.com/item/原地算法" target="_blank">原地</a>修改输入数组** 、使用 O(1) 的额外空间解决这一问题。

 

 **示例 1：** 

```

输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]

```
 **示例 2：** 

```

输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```


 **提示：** 
-  `1 <= s.length <= 10^5` 
-  `s[i]` 都是 <a href="https://baike.baidu.com/item/ASCII" target="_blank">ASCII</a> 码表中的可打印字符

**标签**
`递归` `双指针` `字符串` 


##### solution
```python
#
# @lc app=leetcode.cn id=344 lang=python3
#
# [344] 反转字符串
#
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        l = len(s)
        if l == 0 or l == 1:
            return
        for i in range(l//2):
            s[i], s[l-i-1] = s[l-i-1], s[i]
```
>
#### 387.字符串中的第一个唯一字符
[https://leetcode-cn.com/problems/first-unique-character-in-a-string](https://leetcode-cn.com/problems/first-unique-character-in-a-string) 
##### 原题
给定一个字符串 `s` ，找到 *它的第一个不重复的字符，并返回它的索引* 。如果不存在，则返回 `-1` 。

 

 **示例 1：** 

```

输入: s = "leetcode"
输出: 0

```
 **示例 2:** 

```

输入: s = "loveleetcode"
输出: 2

```
 **示例 3:** 

```

输入: s = "aabb"
输出: -1

```


 **提示:** 
-  `1 <= s.length <= 10^5` 
-  `s` 只包含小写字母

**标签**
`队列` `哈希表` `字符串` `计数` 


##### solution
```python
#
# @lc app=leetcode.cn id=387 lang=python3
#
# [387] 字符串中的第一个唯一字符
#
class Solution:
    def firstUniqChar(self, s: str) -> int:
        d = {}
        for c in s:
            d[c] = d.get(c, 0) + 1
        for i, c in enumerate(s):
            if d[c] == 1:
                return i
        return -1
```
>
#### 415.字符串相加
[https://leetcode-cn.com/problems/add-strings](https://leetcode-cn.com/problems/add-strings) 
##### 原题
给定两个字符串形式的非负整数 `num1` 和 `num2` ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 `BigInteger` ）， 也不能直接将输入的字符串转换为整数形式。

 

 **示例 1：** 

```

输入：num1 = "11", num2 = "123"
输出："134"

```
 **示例 2：** 

```

输入：num1 = "456", num2 = "77"
输出："533"

```
 **示例 3：** 

```

输入：num1 = "0", num2 = "0"
输出："0"

```




 **提示：** 
-  `1 <= num1.length, num2.length <= 10^4` 
-  `num1` 和 `num2` 都只包含数字 `0-9` 
-  `num1` 和 `num2` 都不包含任何前导零

**标签**
`数学` `字符串` `模拟` 


##### solution
```python
#
# @lc app=leetcode.cn id=415 lang=python3
#
# [415] 字符串相加
#
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        res = ''
        num1, num2 = num1[::-1], num2[::-1]
        l = max(len(num1), len(num2))
        if len(num1) < l:
            num1 += '0' * (l-len(num1))
        else:
            num2 += '0' * (l-len(num2))
#        print(num1, num2)
        c = 0
        for i in range(l):
            n = int(num1[i]) + int(num2[i]) + c
            res += str(n)[-1]
            c = n // 10
#            print(res, c)
        if c != 0:
            res += str(c)
        return res[::-1]
```
>
#### 438.找到字符串中所有字母异位词
[https://leetcode-cn.com/problems/find-all-anagrams-in-a-string](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string) 
##### 原题
给定两个字符串 `s` 和 `p` ，找到 `s` **** 中所有 `p` **** 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

 **异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

 

 **示例 1:** 

```

输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。

```
 **示例 2:** 

```

输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。

```


 **提示:** 
-  `1 <= s.length, p.length <= 3 * 10^4` 
-  `s` 和 `p` 仅包含小写字母

**标签**
`哈希表` `字符串` `滑动窗口` 


##### solution
```python
#
# @lc app=leetcode.cn id=438 lang=python3
#
# [438] 找到字符串中所有字母异位词
#
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        lp = len(p)
        dict_p = {}
        for c in p:
            dict_p[c] = dict_p.get(c, 0) + 1
        dict_window = {}
        res = []
        for i, c in enumerate(s):
            dict_window[c] = dict_window.get(c, 0) + 1
            if i >= lp:
                dict_window[s[i-lp]] -= 1
                if dict_window[s[i-lp]] == 0:
                    del dict_window[s[i-lp]]
            if dict_window == dict_p:
                res.append(i-lp+1)
        return res
    # def findAnagrams(self, s: str, p: str) -> List[int]:
    #     p = sorted(p)
    #     res = []
    #     for i in range(len(s) - len(p) + 1):
    #         if sorted(s[i:i+len(p)]) == p:
    #             res.append(i)
    #     return res
```
>
#### 557.反转字符串中的单词-iii
[https://leetcode-cn.com/problems/reverse-words-in-a-string-iii](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii) 
##### 原题
给定一个字符串<meta charset="UTF-8" /> `s` ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

 

 **示例 1：** 

```

输入：s = "Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"

```
 **示例 2:** 

```

输入： s = "God Ding"
输出："doG gniD"

```


 ** ** ** **提示：** ** ** ** 
-  `1 <= s.length <= 5 * 10^4` 
- <meta charset="UTF-8" /> `s` 包含可打印的 **ASCII** 字符。
- <meta charset="UTF-8" /> `s` 不包含任何开头或结尾空格。
- <meta charset="UTF-8" /> `s` 里 **至少** 有一个词。
- <meta charset="UTF-8" /> `s` 中的所有单词都用一个空格隔开。

**标签**
`双指针` `字符串` 


##### solution
```python
#
# @lc app=leetcode.cn id=557 lang=python3
#
# [557] 反转字符串中的单词 III
#
class Solution:
    def reverseWords(self, s: str) -> str:
        res, tmp = [], ''
        for c in s.strip():
            if c != ' ':
                tmp += c
            else:
                if tmp.strip():
                    res.append(tmp[::-1])
                    tmp = ''
        if tmp.strip():
            res.append(tmp[::-1])
        ans = ''
        for i in res:
            ans += i + ' '
        return ans[:-1]
```
>
#### 567.字符串的排列
[https://leetcode-cn.com/problems/permutation-in-string](https://leetcode-cn.com/problems/permutation-in-string) 
##### 原题
给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` **** 的排列。如果是，返回 `true` ；否则，返回 `false` 。

换句话说， `s1` 的排列之一是 `s2` 的 **子串** 。

 

 **示例 1：** 

```

输入：s1 = "ab" s2 = "eidbaooo"
输出：true
解释：s2 包含 s1 的排列之一 ("ba").

```
 **示例 2：** 

```

输入：s1= "ab" s2 = "eidboaoo"
输出：false

```


 **提示：** 
-  `1 <= s1.length, s2.length <= 10^4` 
-  `s1` 和 `s2` 仅包含小写字母

**标签**
`哈希表` `双指针` `字符串` `滑动窗口` 


##### solution
```python
#
# @lc app=leetcode.cn id=567 lang=python3
#
# [567] 字符串的排列
#
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        d = {}
        for c in s1:
            d[c] = d.get(c, 0) + 1
        window = {}
        n = len(s1)
        for i, c in enumerate(s2):
            window[c] = window.get(c, 0) + 1
            if i >= n:
                window[s2[i-n]] = window.get(s2[i-n], 0) - 1
                if window[s2[i-n]] == 0:
                    del window[s2[i-n]]
            if window == d:
                return True
        return False
    # 超时解法
    # def checkInclusion(self, s1: str, s2: str) -> bool:
    #     l1, l2 = len(s1), len(s2)
    #     if l1 > l2:
    #         return False
    #     s1 = sorted(s1)
    #     for i in range(l2-l1+1):
    #         if s1 == sorted(s2[i:i+l1]):
    #             return True
    #     return False
    # 这对应子序列包含问题的解
    # def checkInclusion(self, s1: str, s2: str) -> bool:
    #     d = {}
    #     for c in s1:
    #         d[c] = d.get(c, 0) + 1
    #     for c in s2:
    #         if c in d:
    #             d[c] -= 1
    #             if d[c] == 0:
    #                 d.pop(c)
    #     return True if not d else False
```
>
#### 657.机器人能否返回原点
[https://leetcode-cn.com/problems/robot-return-to-origin](https://leetcode-cn.com/problems/robot-return-to-origin) 
##### 原题
在二维平面上，有一个机器人从原点 `(0, 0)` 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 ** `(0, 0)` 处结束** 。

移动顺序由字符串 `moves` 表示。字符 `move[i]` 表示其第 `i` 次移动。机器人的有效动作有 `R` （右）， `L` （左）， `U` （上）和 `D` （下）。

如果机器人在完成所有动作后返回原点，则返回 `true` 。否则，返回 `false` 。

 **注意：** 机器人“面朝”的方向无关紧要。 `“R”` 将始终使机器人向右移动一次， `“L”` 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。

 

 **示例 1:** 

```

输入: moves = "UD"
输出: true
解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。
```
 **示例 2:** 

```

输入: moves = "LL"
输出: false
解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。
```


 **提示:** 
-  `1 <= moves.length <= 2 * 10^4` 
-  `moves` 只包含字符 `'U'` , `'D'` , `'L'` 和 `'R'` 

**标签**
`字符串` `模拟` 


##### solution
```python
#
# @lc app=leetcode.cn id=657 lang=python3
#
# [657] 机器人能否返回原点
#
class Solution:
    def judgeCircle(self, moves: str) -> bool:
        return moves.count('U')==moves.count('D') and moves.count('R')==moves.count('L')
```
>
## 3链表
#### 2.两数相加
[https://leetcode-cn.com/problems/add-two-numbers](https://leetcode-cn.com/problems/add-two-numbers) 
##### 原题
给你两个  **非空** 的链表，表示两个非负的整数。它们每位数字都是按照  **逆序**  的方式存储的，并且每个节点只能存储  **一位**  数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" style="width: 483px; height: 342px;" />
```

输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.

```
 **示例 2：** 

```

输入：l1 = [0], l2 = [0]
输出：[0]

```
 **示例 3：** 

```

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]

```


 **提示：** 
- 每个链表中的节点数在范围 `[1, 100]` 内
-  `0 <= Node.val <= 9` 
- 题目数据保证列表表示的数字不含前导零

**标签**
`递归` `链表` `数学` 


##### solution
```python
#
# @lc app=leetcode.cn id=2 lang=python
#
# [2] 两数相加
#
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        if not l1:
            return l2
        if not l2:
            return l1
        if l1.val + l2.val < 10:
            l3 = ListNode(l1.val+l2.val)
            l3.next = self.addTwoNumbers(l1.next, l2.next)
        else:
            tmp = ListNode(1)
            l3 = ListNode(l1.val+l2.val-10)
            l3.next = self.addTwoNumbers(self.addTwoNumbers(l1.next, tmp), l2.next)
        return l3
```
>
#### 19.删除链表的倒数第n个节点
[https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list) 
##### 原题
给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" style="width: 542px; height: 222px;" />
```

输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]

```
 **示例 2：** 

```

输入：head = [1], n = 1
输出：[]

```
 **示例 3：** 

```

输入：head = [1,2], n = 1
输出：[1]

```


 **提示：** 
- 链表中结点的数目为 `sz` 
-  `1 <= sz <= 30` 
-  `0 <= Node.val <= 100` 
-  `1 <= n <= sz` 


 **进阶：** 你能尝试使用一趟扫描实现吗？


**标签**
`链表` `双指针` 


##### solution
```python
#
# @lc app=leetcode.cn id=19 lang=python
#
# [19] 删除链表的倒数第N个节点
#
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution(object):
    def removeNthFromEnd(self, head, n):
        """
        :type head: ListNode
        :type n: int
        :rtype: ListNode
        """
        if not head:
            return head
        # 正向行进n-1步到达正数第n个节点
        p = head
        for _ in range(n-1):
            p = p.next
        # 如果此时p.next为空，说明链表长度为n，那么倒数第n个节点为head
        if not p.next:
            return head.next
        #
        p1 = head
        # while循环至少跑一步，因为此时p.next不为空。因此pre_p1不会未定义
        while p.next:
            p = p.next
            pre_p1 = p1
            p1 = p1.next
        pre_p1.next = p1.next
        return head
```
>
#### 21.合并两个有序链表
[https://leetcode-cn.com/problems/merge-two-sorted-lists](https://leetcode-cn.com/problems/merge-two-sorted-lists) 
##### 原题
将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" style="width: 662px; height: 302px;" />
```

输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

```
 **示例 2：** 

```

输入：l1 = [], l2 = []
输出：[]

```
 **示例 3：** 

```

输入：l1 = [], l2 = [0]
输出：[0]

```


 **提示：** 
- 两个链表的节点数目范围是 `[0, 50]` 
-  `-100 <= Node.val <= 100` 
-  `l1` 和 `l2` 均按 **非递减顺序** 排列

**标签**
`递归` `链表` 


##### solution
```python
#
# @lc app=leetcode.cn id=21 lang=python3
#
# [21] 合并两个有序链表
#
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1:
            return l2
        if not l2:
            return l1
        if l1.val > l2.val:
            l3 = ListNode(l2.val)
            l3.next = self.mergeTwoLists(l1, l2.next)
        else:
            l3 = ListNode(l1.val)
            l3.next = self.mergeTwoLists(l1.next, l2)
        return l3
```
>
#### 25.k-个一组翻转链表
[https://leetcode-cn.com/problems/reverse-nodes-in-k-group](https://leetcode-cn.com/problems/reverse-nodes-in-k-group) 
##### 原题
给你一个链表，每  *k * 个节点一组进行翻转，请你返回翻转后的链表。

 *k * 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是  *k * 的整数倍，那么请将最后剩余的节点保持原有顺序。

 **进阶：** 
- 你可以设计一个只使用常数额外空间的算法来解决此问题吗？
-  **你不能只是单纯的改变节点内部的值** ，而是需要实际进行节点交换。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" style="width: 542px; height: 222px;" />
```

输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" style="width: 542px; height: 222px;" />
```

输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]

```
 **示例 3：** 

```

输入：head = [1,2,3,4,5], k = 1
输出：[1,2,3,4,5]

```
 **示例 4：** 

```

输入：head = [1], k = 1
输出：[1]

```
 **提示：** 
- 列表中节点的数量在范围 `sz` 内
-  `1 <= sz <= 5000` 
-  `0 <= Node.val <= 1000` 
-  `1 <= k <= sz` 

**标签**
`递归` `链表` 


##### solution
```python
#
# @lc app=leetcode.cn id=25 lang=python3
#
# [25] K 个一组翻转链表
#
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        p = head
        c = 0
        while p:
            p = p.next
            c += 1
        n = c // k
        if n == 0 or k == 1:
            return head
        dummy = ListNode(-1)
        dummy.next = head
        pbefore = dummy
        pre, p = None, head
        tail = head
        for i in range(n):
            # 反转(i-1)*k+1 ~ i*k之间的链表
            for _ in range(k-1):
                tmp = p.next
                p.next = pre
                pre = p
                p = tmp
            tail.next = p.next
            pbefore.next = p
            p.next = pre
            pbefore = tail
            pre, p = None, tail.next
            tail = tail.next
        return dummy.next
# def create(items):
#     head = ListNode(items[0])
#     p = head
#     for i in items[1:]:
#         p.next = ListNode(i)
#         p = p.next
#     return head
# def print_nodes(head):
#     while head:
#         print(head.val, end=' ')
#         head = head.next
#     print()
# head = create([1,2,3,4,5])
# print_nodes(head)
# head = Solution().reverseKGroup(head, 1)
# print_nodes(head)
```
>
#### 61.旋转链表
[https://leetcode-cn.com/problems/rotate-list](https://leetcode-cn.com/problems/rotate-list) 
##### 原题
给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动  `k` * * 个位置。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" style="width: 600px; height: 254px;" />
```

输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" style="width: 472px; height: 542px;" />
```

输入：head = [0,1,2], k = 4
输出：[2,0,1]

```


 **提示：** 
- 链表中节点的数目在范围 `[0, 500]` 内
-  `-100 <= Node.val <= 100` 
-  `0 <= k <= 2 * 10^9` 

**标签**
`链表` `双指针` 


##### solution
```python
#
# @lc app=leetcode.cn id=61 lang=python
#
# [61] 旋转链表
#
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution(object):
    def rotateRight(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        if not head:
            return head
        c = 0
        p = head
        while p:
            p = p.next
            c += 1
        p = head
        k = k % c
        if k == 0:
            return head
        for _ in range(c-k-1):
            p = p.next
        res = p.next
        p.next = None
        p1 = res
        while p1.next:
            p1 = p1.next
        p1.next = head
        return res
```
>
#### 82.删除排序链表中的重复元素-ii
[https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii) 
##### 原题
给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" style="height: 142px; width: 500px;" />
```

输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg" style="height: 164px; width: 400px;" />
```

输入：head = [1,1,1,2,3]
输出：[2,3]

```


 **提示：** 
- 链表中节点数目在范围 `[0, 300]` 内
-  `-100 <= Node.val <= 100` 
- 题目数据保证链表已经按升序 **排列** 

**标签**
`链表` `双指针` 


##### solution
```python
#
# @lc app=leetcode.cn id=82 lang=python3
#
# [82] 删除排序链表中的重复元素 II
#
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head:
            return head
        dummy = ListNode(-1)
        dummy.next = head
        pre, p = dummy, head
        while p:
            duplicate = False
            while p.next and p.val == p.next.val:
                p = p.next
                duplicate = True
            if duplicate:
                pre.next = p.next
            else:
                pre = p
            p = p.next
        return dummy.next
```
>
#### 83.删除排序链表中的重复元素
[https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list) 
##### 原题
给定一个已排序的链表的头<meta charset="UTF-8" /> `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" style="height: 160px; width: 200px;" />
```

输入：head = [1,1,2]
输出：[1,2]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" style="height: 123px; width: 300px;" />
```

输入：head = [1,1,2,3,3]
输出：[1,2,3]

```


 **提示：** 
- 链表中节点数目在范围 `[0, 300]` 内
-  `-100 <= Node.val <= 100` 
- 题目数据保证链表已经按升序 **排列** 

**标签**
`链表` 


##### solution
```python
#
# @lc app=leetcode.cn id=83 lang=python3
#
# [83] 删除排序链表中的重复元素
#
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head:
            return head
        pre, p = ListNode(None), head
        while p:
            if pre.val != p.val:
                pre = p
                p = p.next
            else:
                p = p.next
                pre.next = p
        return head
```
>
#### 92.反转链表-ii
[https://leetcode-cn.com/problems/reverse-linked-list-ii](https://leetcode-cn.com/problems/reverse-linked-list-ii) 
##### 原题
给你单链表的头指针 `head` 和两个整数  `left` 和 `right` ，其中  `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" style="width: 542px; height: 222px;" />
```

输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]

```
 **示例 2：** 

```

输入：head = [5], left = 1, right = 1
输出：[5]

```


 **提示：** 
- 链表中节点数目为 `n` 
-  `1 <= n <= 500` 
-  `-500 <= Node.val <= 500` 
-  `1 <= left <= right <= n` 


 **进阶：** 你可以使用一趟扫描完成反转吗？


**标签**
`链表` 


##### solution
```python
#
# @lc app=leetcode.cn id=92 lang=python3
#
# [92] 反转链表 II
#
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        """
        1->2->3->4->5->NULL
        dummy->1->2->3->4->5->NULL
        m=2,n=4
        dummy->1-> 2<-3-<4 ->5->NULL
        pbefore:dummy
        m-1(1)个循环之后
        pbefore:1
        tail:pbefore.next(2)
        pre, p = None, 2
        n-m(2)个循环之后
        2->None, pre, p = 2, 3
        3->2,    pre, p = 3, 4
        2.next = 5
        1.next = 4
        4.next = 3
        dummy->1->4->3->2->5->NULL
        return dummy.next
        """
        if m == n:
            return head
        dummy = ListNode(-1)
        dummy.next = head
        pbefore = dummy
        for _ in range(m-1):
            pbefore = pbefore.next
        pre, p = None, pbefore.next
        # tail为反转开始的节点，经过反转变为尾节点
        tail = pbefore.next
        for _ in range(n-m):
            tmp = p.next
            p.next = pre
            pre = p
            p = tmp
        tail.next = p.next
        pbefore.next = p
        p.next = pre
        # 如果m=1，那么dummy.next将不再是head
        # 此时，dummy和pbefore指向相同，在第34行dummy.next改变了
        return dummy.next
```
>
#### 138.复制带随机指针的链表
[https://leetcode-cn.com/problems/copy-list-with-random-pointer](https://leetcode-cn.com/problems/copy-list-with-random-pointer) 
##### 原题
给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **<a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin" target="_blank">深拷贝</a>** 。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。 **复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：
-  `val` ：一个表示 `Node.val` 的整数。
-  `random_index` ：随机指针指向的节点索引（范围从 `0` 到 `n-1` ）；如果不指向任何节点，则为 `null` 。
你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

 

 **示例 1：** 

<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" style="height: 142px; width: 700px;" />

```

输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]

```
 **示例 2：** 

<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" style="height: 114px; width: 700px;" />

```

输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]

```
 **示例 3：** 

 **<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" style="height: 122px; width: 700px;" />** 

```

输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]

```


 **提示：** 
-  `0 <= n <= 1000` <meta charset="UTF-8" />
-  `-10^4 <= Node.val <= 10^4` 
-  `Node.random` 为 `null` 或指向链表中的节点。

**标签**
`哈希表` `链表` 


##### solution
```python
#
# @lc app=leetcode.cn id=138 lang=python
#
# [138] 复制带随机指针的链表
#
"""
# Definition for a Node.
class Node(object):
    def __init__(self, val, next, random):
        self.val = val
        self.next = next
        self.random = random
"""
class Solution(object):
    def copyRandomList(self, head):
        """
        :type head: Node
        :rtype: Node
        """
        if not head:
            return head
        p = head
        while p:
            tmp = Node(p.val, p.next, None)
            p.next = tmp
            p = tmp.next
        p = head
        while p:
            p.next.random = p.random.next if p.random else None
            p = p.next.next
        p = head
        p1 = p.next
        res = p1
        while p:
            p.next = p1.next
            p = p.next
            p1.next = p.next if p else None
            p1 = p1.next
        return res
```
>
#### 141.环形链表
[https://leetcode-cn.com/problems/linked-list-cycle](https://leetcode-cn.com/problems/linked-list-cycle) 
##### 原题
给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 **注意： `pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

 *如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

 

 **示例 1：** 

<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" />

```

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

```
 **示例 2：** 

<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" />

```

输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。

```
 **示例 3：** 

<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" />

```

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。

```


 **提示：** 
- 链表中节点的数目范围是 `[0, 10^4]` 
-  `-10^5 <= Node.val <= 10^5` 
-  `pos` 为 `-1` 或者链表中的一个 **有效索引** 。


 **进阶：** 你能用 `O(1)` （即，常量）内存解决此问题吗？


**标签**
`哈希表` `链表` `双指针` 


##### solution
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        pFast, pSlow = head, head
        while pFast and pFast.next:
            pFast = pFast.next.next
            pSlow = pSlow.next
            if pSlow == pFast:
                return True
        return False
```
>
#### 142.环形链表2
[https://leetcode-cn.com/problems/linked-list-cycle-ii](https://leetcode-cn.com/problems/linked-list-cycle-ii) 
##### 原题
给定一个链表的头节点 `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null` 。* 

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（ **索引从 0 开始** ）。如果 `pos` 是 `-1` ，则在该链表中没有环。 **注意： `pos` 不作为参数进行传递** ，仅仅是为了标识链表的实际情况。

 **不允许修改** 链表。


 **示例 1：** 

<img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" />

```

输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。

```
 **示例 2：** 

<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" />

```

输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。

```
 **示例 3：** 

<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" />

```

输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。

```


 **提示：** 
- 链表中节点的数目范围在范围 `[0, 10^4]` 内
-  `-10^5 <= Node.val <= 10^5` 
-  `pos` 的值为 `-1` 或者链表中的一个有效索引


 **进阶：** 你是否可以使用 `O(1)` 空间解决此题？


**标签**
`哈希表` `链表` `双指针` 


##### solution
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None
'''
三种解法
set 使用额外空间较大
来自剑指offer 步骤较多
Floyd 需要证明
'''
# class Solution(object):
#     def detectCycle(self, head):
#         """
#         :type head: ListNode
#         :rtype: ListNode
#         """
#         visited = set()
#         p = head
#         while p:
#             if p in visited:
#                 return p
#             else:
#                 visited.add(p)
#                 p = p.next
#         return None
# class Solution(object):
#     def detectCycle(self, head):
#         """
#         :type head: ListNode
#         :rtype: ListNode
#         """
#         if not head:
#             return None
#         def hasCycle(head):
#             slow, fast = head, head
#             while fast and fast.next:
#                 slow = slow.next
#                 fast = fast.next.next
#                 if slow == fast:
#                     return slow
#             return None
#         meetingNode = hasCycle(head)
#         if not meetingNode:
#             return None
#         p = meetingNode.next
#         c = 1
#         while p != meetingNode:
#             p = p.next
#             c += 1
#         p1, p2 = head, head
#         for _ in range(c):
#             p1 = p1.next
#         while p1 != p2:
#             p1 = p1.next
#             p2 = p2.next
#         return p1
# Floyd算法
# https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode/
# head到环入口节点距离L，入口节点到meetingNode距离a，meetingNode节点到入口节点距离b
# p1, p2 = head, meetingNode
# 最终相遇在环入口节点时，各自走的距离为
# L+k1*(a+b), k2(a+b)+b
# 相遇时距离head 的距离分别为
# L+k1*(a+b), L+a + k2*(a+b)+b = L+(k2+1)*(a+b)
# 都是在环的入口节点上(即 L + 整数倍 * (a+b))
# 注意各自走的距离L+k1*(a+b) = k2(a+b)+b
# meetingNode: 快慢指针 2 * (L+a) = L + n * (a+b) + a => L = (n-1)*(a+b) + b
# 因此只要满足k2-k1 = n-1即可
class Solution(object):
    def detectCycle(self, head):
        if not head:
            return None
        def hasCycle(head):
            slow, fast = head, head
            while fast and fast.next:
                slow = slow.next
                fast = fast.next.next
                if slow == fast:
                    return slow
            return None
        meetingNode = hasCycle(head)
        if not meetingNode:
            return None
        p1, p2 = head, meetingNode
        while p1 != p2:
            p1 = p1.next
            p2 = p2.next
        return p1
```
>
#### 143.重排链表
[https://leetcode-cn.com/problems/reorder-list](https://leetcode-cn.com/problems/reorder-list) 
##### 原题
给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

```

L0 → L1 → … → Ln - 1 → Ln

```
请将其重新排列后变为：

```

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 

 **示例 1：** 

<img alt="" src="https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png" style="width: 240px; " />

```

输入：head = [1,2,3,4]
输出：[1,4,2,3]
```
 **示例 2：** 

<img alt="" src="https://pic.leetcode-cn.com/1626420320-YUiulT-image.png" style="width: 320px; " />

```

输入：head = [1,2,3,4,5]
输出：[1,5,2,4,3]
```


 **提示：** 
- 链表的长度范围为 `[1, 5 * 10^4]` 
-  `1 <= node.val <= 1000` 

**标签**
`栈` `递归` `链表` `双指针` 


##### solution
```python
#
# @lc app=leetcode.cn id=143 lang=python3
#
# [143] 重排链表
#
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
# def printListNode(head):
#     while head:
#         print(head.val, end=' ')
#         head = head.next
#     print()
class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head:
            return
        # 1 2 3 4 5
        p1, p2 = head, head.next
        while p2 and p2.next:
            p1 = p1.next
            p2 = p2.next.next
        # p1: 3, p: 4
        pre, p = None, p1.next
        # 4 5 -> 5 4
        p1.next = None
        while p:
            tmp = p.next
            p.next = pre
            pre = p
            p = tmp
        # p: None, p1: 5
        while head and pre:
            tmp = pre.next
            pre.next = head.next
            head.next = pre
            head = pre.next
            pre = tmp
# head = ListNode(1)
# a = ListNode(2)
# b = ListNode(3)
# c = ListNode(4)
# d = ListNode(5)
# head.next = a
# a.next = b
# b.next = c
# c.next = d
# Solution().reorderList(head)
# printListNode(head)
```
>
#### 160.相交链表
[https://leetcode-cn.com/problems/intersection-of-two-linked-lists](https://leetcode-cn.com/problems/intersection-of-two-linked-lists) 
##### 原题
给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交 **：** 

<a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" style="height: 130px; width: 400px;" /></a>

题目数据 **保证** 整个链式结构中不存在环。

 **注意** ，函数返回结果后，链表必须 **保持其原始结构** 。

 **自定义评测：** 

 **评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：
-  `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0` 
-  `listA` - 第一个链表
-  `listB` - 第二个链表
-  `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
-  `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数
评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。

 

 **示例 1：** 

<a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" target="_blank"><img alt="" src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" style="height: 130px; width: 400px;" /></a>

```

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

```
 **示例 2：** 

<a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" target="_blank"><img alt="" src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" style="height: 136px; width: 350px;" /></a>

```

输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

```
 **示例 3：** 

<a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" style="height: 126px; width: 200px;" /></a>

```

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。

```


 **提示：** 
-  `listA` 中节点数目为 `m` 
-  `listB` 中节点数目为 `n` 
-  `1 <= m, n <= 3 * 10^4` 
-  `1 <= Node.val <= 10^5` 
-  `0 <= skipA <= m` 
-  `0 <= skipB <= n` 
- 如果 `listA` 和 `listB` 没有交点， `intersectVal` 为 `0` 
- 如果 `listA` 和 `listB` 有交点， `intersectVal == listA[skipA] == listB[skipB]` 


 **进阶：** 你能否设计一个时间复杂度 `O(m + n)` 、仅用 `O(1)` 内存的解决方案？


**标签**
`哈希表` `链表` `双指针` 


##### solution
```python
#
# @lc app=leetcode.cn id=160 lang=python
#
# [160] 相交链表
#
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution(object):
    # https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/tu-jie-xiang-jiao-lian-biao-by-user7208t/
    #     a1->a2->c1->c2->c3
    # b1->b2->b3->c1->c2->c3
    # x+c+y = y+c+x, x指a1->a2的距离，x指重合部分的距离，y指b1->b2->b3的距离
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        p1, p2 = headA, headB
        while p1 != p2:
            p1 = p1.next if p1 else headB
            p2 = p2.next if p2 else headA
        return p1
    def getIntersectionNode2(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        p1, p2 = headA, headB
        c1, c2 = 0, 0
        while p1:
            p1 = p1.next
            c1 += 1
        while p2:
            p2 = p2.next
            c2 += 1
        if c1 > c2:
            for _ in range(c1-c2):
                headA = headA.next
        else:
            for _ in range(c2-c1):
                headB = headB.next
        while headA != headB:
            headA = headA.next
            headB = headB.next
        return headA
```
>
#### 206.反转链表
[https://leetcode-cn.com/problems/reverse-linked-list](https://leetcode-cn.com/problems/reverse-linked-list) 
##### 原题
给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" style="width: 542px; height: 222px;" />
```

输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" style="width: 182px; height: 222px;" />
```

输入：head = [1,2]
输出：[2,1]

```
 **示例 3：** 

```

输入：head = []
输出：[]

```


 **提示：** 
- 链表中节点的数目范围是 `[0, 5000]` 
-  `-5000 <= Node.val <= 5000` 


 **进阶：** 链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

**标签**
`递归` `链表` 


##### solution
```python
#
# @lc app=leetcode.cn id=206 lang=python3
#
# [206] 反转链表
#
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        pre, p = None, head
        while p:
            tmp = p.next
            p.next = pre
            pre = p
            p = tmp
        return pre
    # def reverseList(self, head: ListNode) -> ListNode:
    #     if not head:
    #         return head
    #     pre, p = head, head.next
    #     pre.next = None
    #     while p:
    #         tmp = p.next
    #         p.next = pre
    #         pre = p
    #         p = tmp
    #     return pre
```
>
#### 234.回文链表
[https://leetcode-cn.com/problems/palindrome-linked-list](https://leetcode-cn.com/problems/palindrome-linked-list) 
##### 原题
给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" style="width: 422px; height: 62px;" />
```

输入：head = [1,2,2,1]
输出：true

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" style="width: 182px; height: 62px;" />
```

输入：head = [1,2]
输出：false

```


 **提示：** 
- 链表中节点数目在范围 `[1, 10^5]` 内
-  `0 <= Node.val <= 9` 


 **进阶：** 你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？


**标签**
`栈` `递归` `链表` `双指针` 


##### solution
```python
#
# @lc app=leetcode.cn id=234 lang=python3
#
# [234] 回文链表
#
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        # e.g. 1->2->3->4->5->NULL
        if not head:
            return True
        p1, p2 = head, head.next
        while p2 and p2.next:
            p1 = p1.next
            p2 = p2.next.next
        # p1 = 3
        # 反转p1->……->NULL,3->4->5->NULL
        p = p1.next
        p1.next = None
        while p:
            tmp = p.next
            p.next = p1
            p1 = p
            p = tmp
        # 5->4->3
        while p1 and head:
            if p1.val != head.val:
                return False
            p1 = p1.next
            head = head.next
        return True
# a = ListNode(1)
# a.next = ListNode(2)
# print(Solution().isPalindrome(a))
```
>
#### 328.奇偶链表
[https://leetcode-cn.com/problems/odd-even-linked-list](https://leetcode-cn.com/problems/odd-even-linked-list) 
##### 原题
给定单链表的头节点 `head` ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。

 **第一个** 节点的索引被认为是 **奇数** ， **第二个** 节点的索引为 **偶数** ，以此类推。

请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。

你必须在 `O(1)` 的额外空间复杂度和 `O(n)` 的时间复杂度下解决这个问题。

 

 **示例 1:** 

<img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg" style="height: 123px; width: 300px;" />

```

输入: head = [1,2,3,4,5]
输出: [1,3,5,2,4]
```
 **示例 2:** 

<img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg" style="height: 142px; width: 500px;" />

```

输入: head = [2,1,3,5,6,4,7]
输出: [2,3,6,7,1,5,4]
```


 **提示:** 
-  `n ==` 链表中的节点数
-  `0 <= n <= 10^4` 
-  `-10^6 <= Node.val <= 10^6` 

**标签**
`链表` 


##### solution
```python
#
# @lc app=leetcode.cn id=328 lang=python
#
# [328] 奇偶链表
#
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution(object):
    def oddEvenList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head or not head.next:
            return head
        odd, even = head, head.next
        even_head = even
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        odd.next = even_head
        return head
```
>
## 4栈和队列
### 队列
#### 239.滑动窗口最大值
[https://leetcode-cn.com/problems/sliding-window-maximum](https://leetcode-cn.com/problems/sliding-window-maximum) 
###### 原题
给你一个整数数组 `nums` ，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

 

 **示例 1：** 

```

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

```
 **示例 2：** 

```

输入：nums = [1], k = 1
输出：[1]

```


<b>提示：</b>
-  `1 <= nums.length <= 10^5` 
-  `-10^4 <= nums[i] <= 10^4` 
-  `1 <= k <= nums.length` 

**标签**
`队列` `数组` `滑动窗口` `单调队列` `堆（优先队列）` 


##### solution
```python
#
# @lc app=leetcode.cn id=239 lang=python3
#
# [239] 滑动窗口最大值
#
class Solution:
    def maxSlidingWindow(self, nums, k):
        res = []
        if not nums:
            return res
        if len(nums) >= k:
            deque = []  # 存放元素的索引
            for i in range(k):
                while deque and nums[deque[-1]] < nums[i]:
                    deque.pop()
                deque.append(i)
            # print(deque)
            for i in range(k, len(nums)):
                res.append(nums[deque[0]])
                while deque and nums[deque[-1]] < nums[i]:
                    deque.pop()
                while deque and deque[0] <= i-k:
                    deque.pop(0)
                deque.append(i)
                # print(deque)
            res.append(nums[deque[0]])
        return res
    # 18.77 %
    # def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
    #     res = []
    #     if  not nums:
    #         return res
    #     for i in range(len(nums)-k+1):
    #         res.append(max(nums[i:i+k]))
    #     return res
# print(Solution().maxSlidingWindow([1,3,1,2,0,5], 3))
```
>
#### 622.design-circular-queue
[https://leetcode-cn.com/problems/design-circular-queue](https://leetcode-cn.com/problems/design-circular-queue) 
###### 原题
设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。

你的实现应该支持如下操作：
-  `MyCircularQueue(k)` : 构造器，设置队列长度为 k 。
-  `Front` : 从队首获取元素。如果队列为空，返回 -1 。
-  `Rear` : 获取队尾元素。如果队列为空，返回 -1 。
-  `enQueue(value)` : 向循环队列插入一个元素。如果成功插入则返回真。
-  `deQueue()` : 从循环队列中删除一个元素。如果成功删除则返回真。
-  `isEmpty()` : 检查循环队列是否为空。
-  `isFull()` : 检查循环队列是否已满。


 **示例：** 

```
MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4
```


 **提示：** 
- 所有的值都在 0 至 1000 的范围内；
- 操作数将在 1 至 1000 的范围内；
- 请不要使用内置的队列库。

**标签**
`设计` `队列` `数组` `链表` 


##### solution
```python
#
# @lc app=leetcode.cn id=622 lang=python3
#
# [622] Design Circular Queue
#
class MyCircularQueue:
    def __init__(self, k: int):
        """
        Initialize your data structure here. Set the size of the queue to be k.
        """
        self.max_len = k
        self.queue = [""] * k
        self.start = -1
        self.end = -1
    def enQueue(self, value: int) -> bool:
        """
        Insert an element into the circular queue. Return true if the operation is successful.
        """
        if not self.isFull():
            if self.start == -1:
                self.start = 0
            self.end = (self.end + 1) % self.max_len
            self.queue[self.end] = value
            return True
        else:
            return False
    def deQueue(self) -> bool:
        """
        Delete an element from the circular queue. Return true if the operation is successful.
        """
        if not self.isEmpty():
            if self.start == self.end:
                self.start, self.end = -1, -1
            else:
                self.start = (self.start + 1) % self.max_len
            return True
        else:
            return False
    def Front(self) -> int:
        """
        Get the front item from the queue.
        """
        return -1 if self.isEmpty() else self.queue[self.start]
    def Rear(self) -> int:
        """
        Get the last item from the queue.
        """
        return -1 if self.isEmpty() else self.queue[self.end]
    def isEmpty(self) -> bool:
        """
        Checks whether the circular queue is empty or not.
        """
        return self.start == -1 and self.end == -1
    def isFull(self) -> bool:
        """
        Checks whether the circular queue is full or not.
        """
        return (self.end + 1) % self.max_len == self.start
# Your MyCircularQueue object will be instantiated and called as such:
# obj = MyCircularQueue(k)
# param_1 = obj.enQueue(value)
# param_2 = obj.deQueue()
# param_3 = obj.Front()
# param_4 = obj.Rear()
# param_5 = obj.isEmpty()
# param_6 = obj.isFull()
```
>
#### 641.design-circular-deque
[https://leetcode-cn.com/problems/design-circular-deque](https://leetcode-cn.com/problems/design-circular-deque) 
###### 原题
设计实现双端队列。

实现 `MyCircularDeque` 类:
-  `MyCircularDeque(int k)` ：构造函数,双端队列最大为 `k` 。
-  `boolean insertFront()` ：将一个元素添加到双端队列头部。 如果操作成功返回 `true` ，否则返回 `false` 。
-  `boolean insertLast()` ：将一个元素添加到双端队列尾部。如果操作成功返回 `true` ，否则返回 `false` 。
-  `boolean deleteFront()` ：从双端队列头部删除一个元素。 如果操作成功返回 `true` ，否则返回 `false` 。
-  `boolean deleteLast()` ：从双端队列尾部删除一个元素。如果操作成功返回 `true` ，否则返回 `false` 。
-  `int getFront()` )：从双端队列头部获得一个元素。如果双端队列为空，返回 `-1` 。
-  `int getRear()` ：获得双端队列的最后一个元素。 如果双端队列为空，返回 `-1` 。
-  `boolean isEmpty()` ：若双端队列为空，则返回 `true` ，否则返回 `false` 。
-  `boolean isFull()` ：若双端队列满了，则返回 `true` ，否则返回 `false` 。


 **示例 1：** 

```

输入
["MyCircularDeque", "insertLast", "insertLast", "insertFront", "insertFront", "getRear", "isFull", "deleteLast", "insertFront", "getFront"]
[[3], [1], [2], [3], [4], [], [], [], [4], []]
输出
[null, true, true, true, false, 2, true, true, true, 4]

解释
MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3
circularDeque.insertLast(1);			        // 返回 true
circularDeque.insertLast(2);			        // 返回 true
circularDeque.insertFront(3);			        // 返回 true
circularDeque.insertFront(4);			        // 已经满了，返回 false
circularDeque.getRear();  				// 返回 2
circularDeque.isFull();				        // 返回 true
circularDeque.deleteLast();			        // 返回 true
circularDeque.insertFront(4);			        // 返回 true
circularDeque.getFront();				// 返回 4
 
```


 **提示：** 
-  `1 <= k <= 1000` 
-  `0 <= value <= 1000` 
-  `insertFront` , `insertLast` , `deleteFront` , `deleteLast` , `getFront` , `getRear` , `isEmpty` , `isFull` 调用次数不大于 `2000` 次

**标签**
`设计` `队列` `数组` `链表` 


##### solution
```python
#
# @lc app=leetcode.cn id=641 lang=python3
#
# [641] Design Circular Deque
#
class MyCircularDeque:
    def __init__(self, k: int):
        """
        Initialize your data structure here. Set the size of the deque to be k.
        """
        self.max_len = k
        self.queue = []
    def insertFront(self, value: int) -> bool:
        """
        Adds an item at the front of Deque. Return true if the operation is successful.
        """
        if not self.isFull():
            self.queue.insert(0, value)
            return True
        return False
    def insertLast(self, value: int) -> bool:
        """
        Adds an item at the rear of Deque. Return true if the operation is successful.
        """
        if not self.isFull():
            self.queue.append(value)
            return True
        return False
    def deleteFront(self) -> bool:
        """
        Deletes an item from the front of Deque. Return true if the operation is successful.
        """
        if not self.isEmpty():
            self.queue.pop(0)
            return True
        return False
    def deleteLast(self) -> bool:
        """
        Deletes an item from the rear of Deque. Return true if the operation is successful.
        """
        if not self.isEmpty():
            self.queue.pop()
            return True
        return False
    def getFront(self) -> int:
        """
        Get the front item from the deque.
        """
        if not self.isEmpty():
            return self.queue[0]
        return -1
    def getRear(self) -> int:
        """
        Get the last item from the deque.
        """
        if not self.isEmpty():
            return self.queue[-1]
        return -1
    def isEmpty(self) -> bool:
        """
        Checks whether the circular deque is empty or not.
        """
        return not self.queue
    def isFull(self) -> bool:
        """
        Checks whether the circular deque is full or not.
        """
        return len(self.queue) == self.max_len
# Your MyCircularDeque object will be instantiated and called as such:
# obj = MyCircularDeque(k)
# param_1 = obj.insertFront(value)
# param_2 = obj.insertLast(value)
# param_3 = obj.deleteFront()
# param_4 = obj.deleteLast()
# param_5 = obj.getFront()
# param_6 = obj.getRear()
# param_7 = obj.isEmpty()
# param_8 = obj.isFull()
```
>
### 栈
#### 20.有效的括号
[https://leetcode-cn.com/problems/valid-parentheses](https://leetcode-cn.com/problems/valid-parentheses) 
###### 原题
给定一个只包括 `'('` ， `')'` ， `'{'` ， `'}'` ， `'['` ， `']'`  的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：
- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。


 **示例 1：** 

```

输入：s = "()"
输出：true

```
 **示例 2：** 

```

输入：s = "()[]{}"
输出：true

```
 **示例 3：** 

```

输入：s = "(]"
输出：false

```
 **示例 4：** 

```

输入：s = "([)]"
输出：false

```
 **示例 5：** 

```

输入：s = "{[]}"
输出：true
```


 **提示：** 
-  `1 <= s.length <= 10^4` 
-  `s` 仅由括号 `'()[]{}'` 组成

**标签**
`栈` `字符串` 


##### solution
```python
#
# @lc app=leetcode.cn id=20 lang=python
#
# [20] 有效的括号
#
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        left = ['(', '[', '{']
        right = [')', ']', '}']
        stack = []
        for c in s:
            if c in left:
                stack.append(c)
            else:
                idx = right.index(c)
                if not stack:
                    return False
                popItem = stack.pop()
                if popItem != left[idx]:
                    return False
        if not stack:
            return True
        return False
```
>
#### 71.简化路径
[https://leetcode-cn.com/problems/simplify-path](https://leetcode-cn.com/problems/simplify-path) 
###### 原题
给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为更加简洁的规范路径。

<p class="MachineTrans-lang-zh-CN">在 Unix 风格的文件系统中，一个点（ `.` ）表示当前目录本身；此外，两个点 （ `..` ） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即， `'//'` ）都被视为单个斜杠 `'/'` 。 对于此问题，任何其他格式的点（例如， `'...'` ）均被视为文件/目录名称。

请注意，返回的 **规范路径** 必须遵循下述格式：
- 始终以斜杠 `'/'` 开头。
- 两个目录名之间必须只有一个斜杠 `'/'` 。
- 最后一个目录名（如果存在） **不能** 以 `'/'` 结尾。
- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'` 或 `'..'` ）。
返回简化后得到的 **规范路径** 。

 

 **示例 1：** 

```

输入：path = "/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。 
```
 **示例 2：** 

```

输入：path = "/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。

```
 **示例 3：** 

```

输入：path = "/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。

```
 **示例 4：** 

```

输入：path = "/a/./b/../../c/"
输出："/c"

```


 **提示：** 
-  `1 <= path.length <= 3000` 
-  `path` 由英文字母，数字， `'.'` ， `'/'` 或 `'_'` 组成。
-  `path` 是一个有效的 Unix 风格绝对路径。

**标签**
`栈` `字符串` 


##### solution
```python
#
# @lc app=leetcode.cn id=71 lang=python3
#
# [71] 简化路径
#
class Solution:
    def simplifyPath(self, path: str) -> str:
        s = path.split('/')
        stack = []
        for c in s:
            if c in ["", "."]:
                continue
            if c == "..":
                if stack:
                    stack.pop()
            else:
                stack.append(c)
        return '/' + '/'.join(stack)
```
>
#### 150.逆波兰表达式求值
[https://leetcode-cn.com/problems/evaluate-reverse-polish-notation](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation) 
###### 原题
根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" target="_blank"> 逆波兰表示法</a>，求表达式的值。

有效的算符包括 `+` 、 `-` 、 `*` 、 `/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

<b>注意 </b>两个整数之间的除法只保留整数部分。

可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

 

 **示例 1：** 

```

输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

```
 **示例 2：** 

```

输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

```
 **示例 3：** 

```

输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```


 **提示：** 
-  `1 <= tokens.length <= 10^4` 
-  `tokens[i]` 是一个算符（ `"+"` 、 `"-"` 、 `"*"` 或 `"/"` ），或是在范围 `[-200, 200]` 内的一个整数


 **逆波兰表达式：** 

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。
- 平常使用的算式则是一种中缀表达式，如 `( 1 + 2 ) * ( 3 + 4 )` 。
- 该算式的逆波兰表达式写法为 `( ( 1 2 + ) ( 3 4 + ) * )` 。
逆波兰表达式主要有以下两个优点：
- 去掉括号后表达式无歧义，上式即便写成 `1 2 + 3 4 + *` 也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

**标签**
`栈` `数组` `数学` 


##### solution
```python
#
# @lc app=leetcode.cn id=150 lang=python3
#
# [150] 逆波兰表达式求值
#
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for t in tokens:
            if t in ["+", "-", "*", "/"]:
                p2 = int(stack.pop())
                p1 = int(stack.pop())
                if t == "+":
                    c = p1 + p2
                elif t == "-":
                    c = p1 - p2
                elif t == "*":
                    c = p1 * p2
                else:
                    c = int(p1 / p2)
                stack.append(c)
            else:
                stack.append(int(t))
        return stack[0]
# print(Solution().evalRPN(["2","1","+","3","*"]))
# -2//3 != int(-2/3) (-1, 0)
# print(Solution().evalRPN(["10","6","9","3","+","-11","*","/","*","17","+","5","+"]))
```
>
#### 155.最小栈
[https://leetcode-cn.com/problems/min-stack](https://leetcode-cn.com/problems/min-stack) 
###### 原题
设计一个支持 `push` ， `pop` ， `top` 操作，并能在常数时间内检索到最小元素的栈。
-  `push(x)` &mdash;&mdash; 将元素 x 推入栈中。
-  `pop()` &mdash;&mdash; 删除栈顶的元素。
-  `top()` &mdash;&mdash; 获取栈顶元素。
-  `getMin()` &mdash;&mdash; 检索栈中的最小元素。


 **示例:** 

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.

```


 **提示：** 
-  `pop` 、 `top` 和 `getMin` 操作总是在 **非空栈** 上调用。

**标签**
`栈` `设计` 


##### solution
```python
#
# @lc app=leetcode.cn id=155 lang=python
#
# [155] 最小栈
#
class MinStack(object):
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.min_ = None
    def push(self, x):
        """
        :type x: int
        :rtype: None
        """
        self.stack.append(x)
        if self.min_ == None or self.min_ > x:
            self.min_ = x
    def pop(self):
        """
        :rtype: None
        """
        popItem = self.stack.pop()
        if len(self.stack) == 0:
            self.min_ = None
        if popItem == self.min_:
            self.min_ = min(self.stack)
    def top(self):
        """
        :rtype: int
        """
        return self.stack[-1]
    def getMin(self):
        """
        :rtype: int
        """
        return self.min_
# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
```
>
## 5二叉树
### 后序遍历
#### 104.二叉树的最大深度
[https://leetcode-cn.com/problems/maximum-depth-of-binary-tree](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree) 
###### 原题
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

 **说明:** 叶子节点是指没有子节点的节点。

 **示例：** <br>
给定二叉树 `[3,9,20,null,null,15,7]` ，

```
    3
   / \
  9  20
    /  \
   15   7
```
返回它的最大深度 3 。


**标签**
`树` `深度优先搜索` `广度优先搜索` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=104 lang=python3
#
# [104] 二叉树的最大深度
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```
>
#### 110.平衡二叉树
[https://leetcode-cn.com/problems/balanced-binary-tree](https://leetcode-cn.com/problems/balanced-binary-tree) 
###### 原题
给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

<blockquote>
一个二叉树 *每个节点 * 的左右两个子树的高度差的绝对值不超过 1 。
</blockquote>



 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" style="width: 342px; height: 221px;" />
```

输入：root = [3,9,20,null,null,15,7]
输出：true

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" style="width: 452px; height: 301px;" />
```

输入：root = [1,2,2,3,3,null,null,4,4]
输出：false

```
 **示例 3：** 

```

输入：root = []
输出：true

```


 **提示：** 
- 树中的节点数在范围 `[0, 5000]` 内
-  `-10^4 <= Node.val <= 10^4` 

**标签**
`树` `深度优先搜索` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=110 lang=python3
#
# [110] 平衡二叉树
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 95.58 %
    def isBalanced(self, root: TreeNode) -> bool:
        self.flag = True
        def maxDepth(root):
            if not root:
                return 0
            left = maxDepth(root.left)
            right = maxDepth(root.right)
            if abs(left - right) > 1:
                self.flag = False
            return 1 + max(left, right)
        maxDepth(root)
        return True if self.flag else False
    # 10.48 %
    # def isBalanced(self, root: TreeNode) -> bool:
    #     if not root:
    #         return True
    #     left = self.maxDepth(root.left)
    #     right = self.maxDepth(root.right)
    #     if abs(left - right) > 1:
    #         return False
    #     return self.isBalanced(root.left) and self.isBalanced(root.right)
    # def maxDepth(self, root):
    #     if not root:
    #         return 0
    #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```
>
#### 124.二叉树中的最大路径和
[https://leetcode-cn.com/problems/binary-tree-maximum-path-sum](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum) 
###### 原题
 **路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

 **路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" style="width: 322px; height: 182px;" />
```

输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" />
```

输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42

```


 **提示：** 
- 树中节点数目范围是 `[1, 3 * 10^4]` 
-  `-1000 <= Node.val <= 1000` 

**标签**
`树` `深度优先搜索` `动态规划` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=124 lang=python3
#
# [124] 二叉树中的最大路径和
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
# 给定一个非空节点，最终路径经过这个节点有4种情况：
# 1.只有该节点本身（左右子树的路径都是负数）；
# 2.该节点+左子树路径；
# 3.该节点+右子树路径；
# 4.该节点+左子树路径+右子树路径。
# 其中1，2，3都可以作为子树路径和向上延伸，而4则不行。
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.res = float('-inf')
        self.maxGain(root)
        return self.res
    def maxGain(self, node):
        # 用于计算包含当前节点的最大路径和
        if not node:
            return 0
        left = self.maxGain(node.left)
        right = self.maxGain(node.right)
        # 这三种情况是经过node且可以向上传递的值
        tmp = node.val + max(max(left, right), 0)
        self.res = max(self.res, max(tmp, node.val+left+right))
        return tmp
```
>
#### 145.二叉树的后序遍历
[https://leetcode-cn.com/problems/binary-tree-postorder-traversal](https://leetcode-cn.com/problems/binary-tree-postorder-traversal) 
###### 原题
给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg" style="width: 127px; height: 200px;" />
```

输入：root = [1,null,2,3]
输出：[3,2,1]

```
 **示例 2：** 

```

输入：root = []
输出：[]

```
 **示例 3：** 

```

输入：root = [1]
输出：[1]

```


 **提示：** 
- 树中节点的数目在范围 `[0, 100]` 内
-  `-100 <= Node.val <= 100` 


 **进阶：** 递归算法很简单，你可以通过迭代算法完成吗？


**标签**
`栈` `树` `深度优先搜索` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=145 lang=python3
#
# [145] 二叉树的后序遍历
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 96.54 %
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        res = []
        stack = [root]
        while stack:
            node = stack.pop()
            res.append(node.val)
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        return res[::-1]
    # 递归 16.83 %
    # def postorderTraversal(self, root: TreeNode) -> List[int]:
    #     res = []
    #     if not root:
    #         return res
    #     left = self.postorderTraversal(root.left)
    #     if left:
    #         res += left
    #     right = self.postorderTraversal(root.right)
    #     if right:
    #         res += right
    #     res += [root.val]
    #     return res
```
>
#### 865.smallest-subtree-with-all-the-deepest-nodes
[https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes](https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes) 
###### 原题
给定一个根为 `root` 的二叉树，每个节点的深度是 **该节点到根的最短距离** 。

返回包含原始树中所有 **最深节点** 的 *最小子树* 。

如果一个节点在 **整个树** 的任意节点之间具有最大的深度，则该节点是 **最深的** 。

一个节点的 **子树** 是该节点加上它的所有后代的集合。

 

 **示例 1：** 

<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png" style="width: 300px;" />

```

输入：root = [3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释：
我们返回值为 2 的节点，在图中用黄色标记。
在图中用蓝色标记的是树的最深的节点。
注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。

```
 **示例 2：** 

```

输入：root = [1]
输出：[1]
解释：根节点是树中最深的节点。
```
 **示例 3：** 

```

输入：root = [0,1,3,null,2]
输出：[2]
解释：树中最深的节点为 2 ，有效子树为节点 2、1 和 0 的子树，但节点 2 的子树最小。
```


 **提示：** 
- 树中节点的数量在<meta charset="UTF-8" /> `[1, 500]` 范围内。
-  `0 <= Node.val <= 500` 
- 每个节点的值都是 **独一无二** 的。


 **注意：** 本题与力扣 1123 重复：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/" target="_blank">https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves</a>


**标签**
`树` `深度优先搜索` `广度优先搜索` `哈希表` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=865 lang=python3
#
# [865] Smallest Subtree with all the Deepest Nodes
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        left = self.maxDepth(root.left)
        right = self.maxDepth(root.right)
        if left == right:
            return root
        if left > right:
            return self.subtreeWithAllDeepest(root.left)
        return self.subtreeWithAllDeepest(root.right)
    def maxDepth(self, root):
        if not root:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```
>
### 二叉搜索树
#### 98.验证二叉搜索树
[https://leetcode-cn.com/problems/validate-binary-search-tree](https://leetcode-cn.com/problems/validate-binary-search-tree) 
###### 原题
给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

 **有效** 二叉搜索树定义如下：
- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" style="width: 302px; height: 182px;" />
```

输入：root = [2,1,3]
输出：true

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" style="width: 422px; height: 292px;" />
```

输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。

```


 **提示：** 
- 树中节点数目范围在 `[1, 10^4]` 内
-  `-2^31 <= Node.val <= 2^31 - 1` 

**标签**
`树` `深度优先搜索` `二叉搜索树` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=98 lang=python3
#
# [98] 验证二叉搜索树
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 14.58%
    def isValidBST(self, root: TreeNode) -> bool:
        prev = float('-inf')
        stack = [(1, root)]
        while stack:
            p = stack.pop()
            if not p[1]:
                continue
            if p[0] == 0:
                if prev >= p[1].val:
                    return False
                prev = p[1].val
            else:
                stack.append((1, p[1].right))
                stack.append((0, p[1]))
                stack.append((1, p[1].left))
        return True
    # 97.54%
    # def isValidBST(self, root: TreeNode) -> bool:
    #     if not root:
    #         return True
    #     stack = []
    #     p = root
    #     res = []
    #     while p or stack:
    #         if p:
    #             stack.append(p)
    #             p = p.left
    #         else:
    #             popItem = stack.pop()
    #             res.append(popItem.val)
    #             p = popItem.right
    #     return res == sorted(res) and len(res) == len(set(res))
# root = TreeNode(5)
# a = TreeNode(1)
# b = TreeNode(4)
# c = TreeNode(3)
# d = TreeNode(6)
# root.left = a
# root.right = b
# b.left = c
# b.right = d
# root = TreeNode(0)
# a = TreeNode(-1)
# root.left = a
# print(Solution().isValidBST(root))
```
>
#### 108.将有序数组转换为二叉搜索树
[https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree) 
###### 原题
给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

 **高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" style="width: 302px; height: 222px;" />
```

输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg" style="width: 302px; height: 222px;" />

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" style="width: 342px; height: 142px;" />
```

输入：nums = [1,3]
输出：[3,1]
解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。

```


 **提示：** 
-  `1 <= nums.length <= 10^4` 
-  `-10^4 <= nums[i] <= 10^4` 
-  `nums` 按 **严格递增** 顺序排列

**标签**
`树` `二叉搜索树` `数组` `分治` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=108 lang=python3
#
# [108] 将有序数组转换为二叉搜索树
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if not nums:
            return None
        if len(nums) == 1:
            return TreeNode(nums[0])
        mid = len(nums) // 2
        root = TreeNode(nums[mid])
        root.left = self.sortedArrayToBST(nums[:mid])
        root.right = self.sortedArrayToBST(nums[mid+1:])
        return root
```
>
#### 230.二叉搜索树中第k小的元素
[https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst) 
###### 原题
给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第  `k` ** ** 个最小元素（从 1 开始计数）。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" style="width: 212px; height: 301px;" />
```

输入：root = [3,1,4,null,2], k = 1
输出：1

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" style="width: 382px; height: 302px;" />
```

输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3

```




 **提示：** 
- 树中的节点数为 `n` 。
-  `1 <= k <= n <= 10^4` 
-  `0 <= Node.val <= 10^4` 


 **进阶：** 如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 `k` 小的值，你将如何优化算法？


**标签**
`树` `深度优先搜索` `二叉搜索树` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=230 lang=python3
#
# [230] 二叉搜索树中第K小的元素
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -> int:
        stack = []
        p = root
        while p or stack:
            if p:
                stack.append(p)
                p = p.left
            else:
                popItem = stack.pop()
                k -= 1
                if k == 0:
                    return popItem.val
                p = popItem.right
```
>
#### 235.二叉搜索树的最近公共祖先
[https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree) 
###### 原题
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

<a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" target="_blank">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（ **一个节点也可以是它自己的祖先** ）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" style="height: 190px; width: 200px;">

 

 **示例 1:** 

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。

```
 **示例 2:** 

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```


 **说明:** 
- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

**标签**
`树` `深度优先搜索` `二叉搜索树` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=235 lang=python3
#
# [235] 二叉搜索树的最近公共祖先
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if p.val < root.val > q.val:
            return self.lowestCommonAncestor(root.left, p, q)
        if p.val > root.val < q.val:
            return self.lowestCommonAncestor(root.right, p, q)
        return root
```
>
#### 236.二叉树的最近公共祖先
[https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree) 
###### 原题
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

<a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" target="_blank">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（ **一个节点也可以是它自己的祖先** ）。”

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" style="width: 200px; height: 190px;" />
```

输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" style="width: 200px; height: 190px;" />
```

输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。

```
 **示例 3：** 

```

输入：root = [1,2], p = 1, q = 2
输出：1

```


 **提示：** 
- 树中节点数目在范围 `[2, 10^5]` 内。
-  `-10^9 <= Node.val <= 10^9` 
- 所有 `Node.val` `互不相同` 。
-  `p != q` 
-  `p` 和 `q` 均存在于给定的二叉树中。

**标签**
`树` `深度优先搜索` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=236 lang=python3
#
# [236] 二叉树的最近公共祖先
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        # 如果lp和rp都是非空，则返回当前节点（当前节点就是最近祖先）
        # left和right有一个为空，返回非空的那个。
        # 不存在全部非空,因为必有公共祖先
        if left and right:
            return root
        return left if not right else right
    # def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
    #     def recurse(cur_node):
    #         if not cur_node:
    #             return False
    #         left = recurse(cur_node.left)
    #         right = recurse(cur_node.right)
    #         mid = cur_node == p or cur_node == q
    #         if mid + left + right >= 2:
    #             self.ans = cur_node
    #         return mid or left or right
    #     recurse(root)
    #     return self.ans
```
>
### 其他
#### 101.对称二叉树
[https://leetcode-cn.com/problems/symmetric-tree](https://leetcode-cn.com/problems/symmetric-tree) 
###### 原题
给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" style="width: 354px; height: 291px;" />
```

输入：root = [1,2,2,3,4,4,3]
输出：true

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" style="width: 308px; height: 258px;" />
```

输入：root = [1,2,2,null,3,null,3]
输出：false

```


 **提示：** 
- 树中节点数目在范围 `[1, 1000]` 内
-  `-100 <= Node.val <= 100` 


 **进阶：** 你可以运用递归和迭代两种方法解决这个问题吗？


**标签**
`树` `深度优先搜索` `广度优先搜索` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=101 lang=python3
#
# [101] 对称二叉树
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 递归
    def isSymmetric(self, root: TreeNode) -> bool:
        queue = [root, root]
        while queue:
            p1 = queue.pop()
            p2 = queue.pop()
            if not p1 and not p2:
                continue
            if not p1 or not p2:
                return False
            if p1.val != p2.val:
                return False
            queue.append(p1.left)
            queue.append(p2.right)
            queue.append(p1.right)
            queue.append(p2.left)
        return True
    # 非递归 82.32 %
    # def isSymmetric(self, root: TreeNode) -> bool:
    #     return self.isMirror(root, root)
    # def isMirror(self, root1, root2):
    #     if not root1 and not root2:
    #         return True
    #     if not root1 or not root2:
    #         return False
    #     return root1.val == root2.val \
    #         and self.isMirror(root1.left, root2.right) \
    #         and self.isMirror(root1.right, root2.left)
```
>
#### 297.二叉树的序列化与反序列化
[https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree) 
###### 原题
序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

 **提示:** 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href="/faq/#binary-tree">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" style="width: 442px; height: 324px;" />
```

输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]

```
 **示例 2：** 

```

输入：root = []
输出：[]

```
 **示例 3：** 

```

输入：root = [1]
输出：[1]

```
 **示例 4：** 

```

输入：root = [1,2]
输出：[1,2]

```


 **提示：** 
- 树中结点数在范围 `[0, 10^4]` 内
-  `-1000 <= Node.val <= 1000` 

**标签**
`树` `深度优先搜索` `广度优先搜索` `设计` `字符串` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=297 lang=python3
#
# [297] 二叉树的序列化与反序列化
#
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
# 层序遍历
class Codec:
    def serialize(self, root):
        """Encodes a tree to a single string.
        :type root: TreeNode
        :rtype: str
        """
        queue = [root]
        res = []
        while queue:
            p = queue.pop(0)
            if not p:
                res.append('None')
                continue
            else:
                res.append(str(p.val))
            queue.append(p.left)
            queue.append(p.right)
        return ','.join(res)
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        :type data: str
        :rtype: TreeNode
        """
        # 注意构造和序列化时相同的流程
        data = data.split(',')
        if data[0] == 'None':
            return None
        root = TreeNode(int(data[0]))
        queue = [root]
        i = 0
        while queue and i < len(data):
            p = queue.pop(0)
            left, right = None, None
            i += 1
            if i < len(data) and data[i] != 'None':
                left = TreeNode(int(data[i]))
                queue.append(left)
            i += 1
            if i < len(data) and data[i] != 'None':
                right = TreeNode(int(data[i]))
                queue.append(right)
            p.left = left
            p.right = right
        return root
# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.deserialize(codec.serialize(root))
```
>
### 层序遍历
#### 102.二叉树的层次遍历
[https://leetcode-cn.com/problems/binary-tree-level-order-traversal](https://leetcode-cn.com/problems/binary-tree-level-order-traversal) 
###### 原题
给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="width: 277px; height: 302px;" />
```

输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]

```
 **示例 2：** 

```

输入：root = [1]
输出：[[1]]

```
 **示例 3：** 

```

输入：root = []
输出：[]

```


 **提示：** 
- 树中节点数目在范围 `[0, 2000]` 内
-  `-1000 <= Node.val <= 1000` 

**标签**
`树` `广度优先搜索` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=102 lang=python3
#
# [102] 二叉树的层次遍历
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        curLayerNodes = [root]
        res = [[root.val]]
        while curLayerNodes:
            nextLayerNodes = []
            nextLayerValues = []
            for node in curLayerNodes:
                if node.left:
                    nextLayerNodes.append(node.left)
                    nextLayerValues.append(node.left.val)
                if node.right:
                    nextLayerNodes.append(node.right)
                    nextLayerValues.append(node.right.val)
            if nextLayerValues:
                res.append(nextLayerValues)
            curLayerNodes = nextLayerNodes
        return res
```
>
#### 103.二叉树的锯齿形层次遍历
[https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal) 
###### 原题
给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="width: 277px; height: 302px;" />
```

输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]

```
 **示例 2：** 

```

输入：root = [1]
输出：[[1]]

```
 **示例 3：** 

```

输入：root = []
输出：[]

```


 **提示：** 
- 树中节点数目在范围 `[0, 2000]` 内
-  `-100 <= Node.val <= 100` 

**标签**
`树` `广度优先搜索` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=103 lang=python3
#
# [103] 二叉树的锯齿形层次遍历
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        curLayerNodes = [root]
        res = [[root.val]]
        isEven = False
        while curLayerNodes:
            nextLayerNodes = []
            nextLayerValues = []
            isEven = not isEven
            for node in curLayerNodes:
                if node.left:
                    nextLayerNodes.append(node.left)
                    nextLayerValues.append(node.left.val)
                if node.right:
                    nextLayerNodes.append(node.right)
                    nextLayerValues.append(node.right.val)
            if nextLayerValues:
                res.append(nextLayerValues[::-1]) if isEven else res.append(nextLayerValues)
            curLayerNodes = nextLayerNodes
        return res
```
>
#### 107.二叉树的层次遍历-ii
[https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii) 
###### 原题
给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="width: 277px; height: 302px;" />
```

输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]

```
 **示例 2：** 

```

输入：root = [1]
输出：[[1]]

```
 **示例 3：** 

```

输入：root = []
输出：[]

```


 **提示：** 
- 树中节点数目在范围 `[0, 2000]` 内
-  `-1000 <= Node.val <= 1000` 

**标签**
`树` `广度优先搜索` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=107 lang=python3
#
# [107] 二叉树的层次遍历 II
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        curLayerNodes = [root]
        res = [[root.val]]
        while curLayerNodes:
            nextLayerNodes = []
            nextLayerValues = []
            for node in curLayerNodes:
                if node.left:
                    nextLayerNodes.append(node.left)
                    nextLayerValues.append(node.left.val)
                if node.right:
                    nextLayerNodes.append(node.right)
                    nextLayerValues.append(node.right.val)
            if nextLayerValues:
                res.append(nextLayerValues)
            curLayerNodes = nextLayerNodes
        return res[::-1]
```
>
#### 116.填充每个节点的下一个右侧节点指针
[https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node) 
###### 原题
给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL` 。

初始状态下，所有 next 指针都被设置为 `NULL` 。

 

 **示例 1：** 

<img alt="" src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" style="height: 171px; width: 500px;" />

```

输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。

```
<meta charset="UTF-8" />

 **示例 2:** 

```

输入：root = []
输出：[]

```


 **提示：** 
- 树中节点的数量在<meta charset="UTF-8" /> `[0, 2^12 - 1]` 范围内
-  `-1000 <= node.val <= 1000` 


 **进阶：** 
- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

**标签**
`树` `深度优先搜索` `广度优先搜索` `链表` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=116 lang=python3
#
# [116] 填充每个节点的下一个右侧节点指针
#
"""
# Definition for a Node.
class Node:
    def __init__(self, val, left, right, next):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root
        curLayerNodes = [root]
        while curLayerNodes:
            nextLayerNodes = []
            for node in curLayerNodes:
                if node.left:
                    nextLayerNodes.append(node.left)
                if node.right:
                    nextLayerNodes.append(node.right)
            if len(curLayerNodes) > 1:
                for i in range(len(curLayerNodes)-1):
                    curLayerNodes[i].next = curLayerNodes[i+1]
            curLayerNodes = nextLayerNodes
        return root
```
>
#### 199.二叉树的右视图
[https://leetcode-cn.com/problems/binary-tree-right-side-view](https://leetcode-cn.com/problems/binary-tree-right-side-view) 
###### 原题
给定一个二叉树的 **根节点** `root` ，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

 

 **示例 1:** 

<img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" style="width: 270px; " />

```

输入: [1,2,3,null,5,null,4]
输出: [1,3,4]

```
 **示例 2:** 

```

输入: [1,null,3]
输出: [1,3]

```
 **示例 3:** 

```

输入: []
输出: []

```


 **提示:** 
- 二叉树的节点个数的范围是 `[0,100]` 
- <meta charset="UTF-8" /> `-100 <= Node.val <= 100`  

**标签**
`树` `深度优先搜索` `广度优先搜索` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=199 lang=python3
#
# [199] 二叉树的右视图
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        curLayerNodes = [root]
        res = [root.val]
        while curLayerNodes:
            nextLayerNodes = []
            nextLayerValues = []
            for node in curLayerNodes:
                if node.left:
                    nextLayerNodes.append(node.left)
                    nextLayerValues.append(node.left.val)
                if node.right:
                    nextLayerNodes.append(node.right)
                    nextLayerValues.append(node.right.val)
            if nextLayerValues:
                res.append(nextLayerValues[-1])
            curLayerNodes = nextLayerNodes
        return res
```
>
### 前序遍历
#### 105.从前序与中序遍历序列构造二叉树
[https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal) 
###### 原题
给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的 **先序遍历** ， `inorder` 是同一棵树的 **中序遍历** ，请构造二叉树并返回其根节点。

 

 **示例 1:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" style="height: 302px; width: 277px;" />
```

输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]

```
 **示例 2:** 

```

输入: preorder = [-1], inorder = [-1]
输出: [-1]

```


 **提示:** 
-  `1 <= preorder.length <= 3000` 
-  `inorder.length == preorder.length` 
-  `-3000 <= preorder[i], inorder[i] <= 3000` 
-  `preorder` 和 `inorder` 均 **无重复** 元素
-  `inorder` 均出现在 `preorder` 
-  `preorder` **保证** 为二叉树的前序遍历序列
-  `inorder` **保证** 为二叉树的中序遍历序列

**标签**
`树` `数组` `哈希表` `分治` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=105 lang=python3
#
# [105] 从前序与中序遍历序列构造二叉树
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not preorder or not inorder:
            return None
        root = TreeNode(preorder[0])
        mid = inorder.index(preorder[0])
        left = inorder[:mid]
        right = inorder[mid+1:]
        root.left = self.buildTree(preorder[1:1+len(left)], left)
        root.right = self.buildTree(preorder[-len(right):], right)
        return root
```
>
#### 112.路径总和
[https://leetcode-cn.com/problems/path-sum](https://leetcode-cn.com/problems/path-sum) 
###### 原题
给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

 **叶子节点** 是指没有子节点的节点。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" style="width: 500px; height: 356px;" />
```

输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" />
```

输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```
 **示例 3：** 

```

输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。

```


 **提示：** 
- 树中节点的数目在范围 `[0, 5000]` 内
-  `-1000 <= Node.val <= 1000` 
-  `-1000 <= targetSum <= 1000` 

**标签**
`树` `深度优先搜索` `广度优先搜索` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=112 lang=python3
#
# [112] 路径总和
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        stack = [(root, 0)]
        while stack:
            node, v = stack.pop()
            if not node.left and not node.right:
                if v + node.val == sum:
                    return True
            if node.left:
                stack.append((node.left, v+node.val))
            if node.right:
                stack.append((node.right, v+node.val))
        return False
```
>
#### 113.路径总和-ii
[https://leetcode-cn.com/problems/path-sum-ii](https://leetcode-cn.com/problems/path-sum-ii) 
###### 原题
给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

 **叶子节点** 是指没有子节点的节点。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" style="width: 500px; height: 356px;" />
```

输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" style="width: 212px; height: 181px;" />
```

输入：root = [1,2,3], targetSum = 5
输出：[]

```
 **示例 3：** 

```

输入：root = [1,2], targetSum = 0
输出：[]

```


 **提示：** 
- 树中节点总数在范围 `[0, 5000]` 内
-  `-1000 <= Node.val <= 1000` 
-  `-1000 <= targetSum <= 1000` 

**标签**
`树` `深度优先搜索` `回溯` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=113 lang=python3
#
# [113] 路径总和 II
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:
        if not root:
            return []
        res = []
        def dfs(node, v, path):
            if not node:
                return
            if not node.left and not node.right and v + node.val == sum:
                res.append(path+[node.val])
                return
            dfs(node.left, v+node.val, path+[node.val])
            dfs(node.right, v+node.val, path+[node.val])
        dfs(root, 0, [])
        return res
```
>
#### 129.求根到叶子节点数字之和
[https://leetcode-cn.com/problems/sum-root-to-leaf-numbers](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers) 
###### 原题
给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：
- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。
计算从根节点到叶节点生成的 **所有数字之和** 。

 **叶节点** 是指没有子节点的节点。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" style="width: 212px; height: 182px;" />
```

输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" style="width: 292px; height: 302px;" />
```

输入：root = [4,9,0,5,1]
输出：1026
解释：
从根到叶子节点路径 4->9->5 代表数字 495
从根到叶子节点路径 4->9->1 代表数字 491
从根到叶子节点路径 4->0 代表数字 40
因此，数字总和 = 495 + 491 + 40 = 1026

```


 **提示：** 
- 树中节点的数目在范围 `[1, 1000]` 内
-  `0 <= Node.val <= 9` 
- 树的深度不超过 `10` 

**标签**
`树` `深度优先搜索` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=129 lang=python3
#
# [129] 求根到叶子节点数字之和
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        if not root:
            return 0
        res = 0
        stack = [(root, 0)]
        while stack:
            node, v = stack.pop()
            if not node.left and not node.right:
                res += 10*v + node.val
            if node.left:
                stack.append((node.left, 10*v+node.val))
            if node.right:
                stack.append((node.right, 10*v+node.val))
        return res
```
>
#### 144.二叉树的前序遍历
[https://leetcode-cn.com/problems/binary-tree-preorder-traversal](https://leetcode-cn.com/problems/binary-tree-preorder-traversal) 
###### 原题
给你二叉树的根节点 `root` ，返回它节点值的  **前序** * * 遍历。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" style="width: 202px; height: 324px;" />
```

输入：root = [1,null,2,3]
输出：[1,2,3]

```
 **示例 2：** 

```

输入：root = []
输出：[]

```
 **示例 3：** 

```

输入：root = [1]
输出：[1]

```
 **示例 4：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" style="width: 202px; height: 202px;" />
```

输入：root = [1,2]
输出：[1,2]

```
 **示例 5：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" style="width: 202px; height: 202px;" />
```

输入：root = [1,null,2]
输出：[1,2]

```


 **提示：** 
- 树中节点数目在范围 `[0, 100]` 内
-  `-100 <= Node.val <= 100` 


 **进阶：** 递归算法很简单，你可以通过迭代算法完成吗？


**标签**
`栈` `树` `深度优先搜索` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=144 lang=python3
#
# [144] 二叉树的前序遍历
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 非递归 46.14%
    # def preorderTraversal(self, root: TreeNode) -> List[int]:
    #     if not root:
    #         return []
    #     res = []
    #     stack = [root]
    #     while stack:
    #         node = stack.pop()
    #         res.append(node.val)
    #         if node.right:
    #             stack.append(node.right)
    #         if node.left:
    #             stack.append(node.left)
    #     return res
    # 递归 80.44%
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        res = [root.val]
        left = self.preorderTraversal(root.left)
        right = self.preorderTraversal(root.right)
        if left:
            res += left
        if right:
            res += right
        return res
```
>
#### 257.二叉树的所有路径
[https://leetcode-cn.com/problems/binary-tree-paths](https://leetcode-cn.com/problems/binary-tree-paths) 
###### 原题
给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

 **叶子节点** 是指没有子节点的节点。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" style="width: 207px; height: 293px;" />
```

输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]

```
 **示例 2：** 

```

输入：root = [1]
输出：["1"]

```


 **提示：** 
- 树中节点的数目在范围 `[1, 100]` 内
-  `-100 <= Node.val <= 100` 

**标签**
`树` `深度优先搜索` `字符串` `回溯` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=257 lang=python3
#
# [257] 二叉树的所有路径
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        res = []
        if not root:
            return res
        stack = [(root, [])]
        while stack:
            node, path = stack.pop()
            if not node.left and not node.right:
                res.append('->'.join(path+[str(node.val)]))
            if node.right:
                stack.append((node.right, path+[str(node.val)]))
            if node.left:
                stack.append((node.left, path+[str(node.val)]))
        return res
```
>
#### 437.路径总和-iii
[https://leetcode-cn.com/problems/path-sum-iii](https://leetcode-cn.com/problems/path-sum-iii) 
###### 原题
给定一个二叉树的根节点 `root`  ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

 **路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

 

 **示例 1：** 

<img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" style="width: 452px; " />

```

输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。

```
 **示例 2：** 

```

输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3

```


 **提示:** 
- 二叉树的节点个数的范围是 `[0,1000]` 
- <meta charset="UTF-8" /> `-10^9 <= Node.val <= 10^9`  
-  `-1000 <= targetSum <= 1000`  

**标签**
`树` `深度优先搜索` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=437 lang=python3
#
# [437] 路径总和 III
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> int:
        if not root:
            return 0
        self.count = 0
        d = {0 : 1}
        def dfs(node, pathsum, d):
            if node:
                pathsum += node.val
                self.count += d.get(pathsum-sum, 0)
                d[pathsum] = d.get(pathsum, 0) + 1
                dfs(node.left, pathsum, d)
                dfs(node.right, pathsum, d)
                d[pathsum] -= 1
        dfs(root, 0, d)
        return self.count
```
>
#### 617.合并二叉树
[https://leetcode-cn.com/problems/merge-two-binary-trees](https://leetcode-cn.com/problems/merge-two-binary-trees) 
###### 原题
给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则， **不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

 **注意:** 合并过程必须从两个树的根节点开始。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" style="height: 163px; width: 600px;" />
```

输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]

```
 **示例 2：** 

```

输入：root1 = [1], root2 = [1,2]
输出：[2,2]

```


 **提示：** 
- 两棵树中的节点数目在范围 `[0, 2000]` 内
-  `-10^4 <= Node.val <= 10^4` 

**标签**
`树` `深度优先搜索` `广度优先搜索` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=617 lang=python3
#
# [617] 合并二叉树
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:
        if t1 and t2:
            t1.val += t2.val
            t1.left = self.mergeTrees(t1.left, t2.left)
            t1.right = self.mergeTrees(t1.right, t2.right)
            return t1
        return t1 if not t2 else t2
```
>
### 中序遍历
#### 94.二叉树的中序遍历
[https://leetcode-cn.com/problems/binary-tree-inorder-traversal](https://leetcode-cn.com/problems/binary-tree-inorder-traversal) 
###### 原题
给定一个二叉树的根节点 `root` ，返回它的 **中序**  遍历。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" style="width: 202px; height: 324px;" />
```

输入：root = [1,null,2,3]
输出：[1,3,2]

```
 **示例 2：** 

```

输入：root = []
输出：[]

```
 **示例 3：** 

```

输入：root = [1]
输出：[1]

```
 **示例 4：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" style="width: 202px; height: 202px;" />
```

输入：root = [1,2]
输出：[2,1]

```
 **示例 5：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" style="width: 202px; height: 202px;" />
```

输入：root = [1,null,2]
输出：[1,2]

```


 **提示：** 
- 树中节点数目在范围 `[0, 100]` 内
-  `-100 <= Node.val <= 100` 


 **进阶:**  递归算法很简单，你可以通过迭代算法完成吗？


**标签**
`栈` `树` `深度优先搜索` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=94 lang=python3
#
# [94] 二叉树的中序遍历
#
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 非递归 89.23 %
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        stack = []
        p = root
        while p or stack:
            if p:
                stack.append(p)
                p = p.left
            else:
                popItem = stack.pop()
                res.append(popItem.val)
                p = popItem.right
        return res
    # # 递归 89.23 %
    # def inorderTraversal(self, root: TreeNode) -> List[int]:
    #     if not root:
    #         return []
    #     res = []
    #     left = self.inorderTraversal(root.left)
    #     if left:
    #         res += left
    #     res += [root.val]
    #     right = self.inorderTraversal(root.right)
    #     if right:
    #         res += right
    #     return res
```
>
#### 530.二叉搜索树的最小绝对差
[https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst) 
###### 原题
给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" style="width: 292px; height: 301px;" />
```

输入：root = [4,2,6,1,3]
输出：1

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" style="width: 282px; height: 301px;" />
```

输入：root = [1,0,48,null,null,12,49]
输出：1

```


 **提示：** 
- 树中节点的数目范围是 `[2, 10^4]` 
-  `0 <= Node.val <= 10^5` 


 **注意：** 本题与 783 <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同


**标签**
`树` `深度优先搜索` `广度优先搜索` `二叉搜索树` `二叉树` 


##### solution
```python
#
# @lc app=leetcode.cn id=530 lang=python3
#
# [530] 二叉搜索树的最小绝对差
#
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        ans = float('inf')
        lastval = None
        stack = []
        node = root
        while stack or node:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack.pop()
                if lastval is not None:
                    ans = min(ans, abs(lastval - node.val))
                lastval = node.val
                node = node.right
        return ans
# a = TreeNode(0)
# b = TreeNode(2236)
# c = TreeNode(1277)
# d = TreeNode(2776)
# e = TreeNode(519)
# a.right = b
# b.left = c
# b.right = d
# c.left = e
# print(Solution().getMinimumDifference(a))
```
>
## 6图
### 广度优先搜索
#### 126.单词接龙-ii
[https://leetcode-cn.com/problems/word-ladder-ii](https://leetcode-cn.com/problems/word-ladder-ii) 
###### 原题
按字典 `wordList` 完成从单词 `beginWord` 到单词 `endWord` 转化，一个表示此过程的 **转换序列** 是形式上像 `beginWord -> s<sub>1</sub> -> s<sub>2</sub> -> ... -> s<sub>k</sub>` 这样的单词序列，并满足：
- 每对相邻的单词之间仅有单个字母不同。
- 转换过程中的每个单词 `s<sub>i</sub>` （ `1 <= i <= k` ）必须是字典 `wordList` 中的单词。注意， `beginWord` 不必是字典 `wordList` 中的单词。
-  `s<sub>k</sub> == endWord` 
给你两个单词 `beginWord` 和 `endWord` ，以及一个字典 `wordList` 。请你找出并返回所有从 `beginWord` 到 `endWord` 的 **最短转换序列** ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 `[beginWord, s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>]` 的形式返回。

 

 **示例 1：** 

```

输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
输出：[["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]
解释：存在 2 种最短的转换序列：
"hit" -> "hot" -> "dot" -> "dog" -> "cog"
"hit" -> "hot" -> "lot" -> "log" -> "cog"

```
 **示例 2：** 

```

输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
输出：[]
解释：endWord "cog" 不在字典 wordList 中，所以不存在符合要求的转换序列。

```


 **提示：** 
-  `1 <= beginWord.length <= 5` 
-  `endWord.length == beginWord.length` 
-  `1 <= wordList.length <= 5000` 
-  `wordList[i].length == beginWord.length` 
-  `beginWord` 、 `endWord` 和 `wordList[i]` 由小写英文字母组成
-  `beginWord != endWord` 
-  `wordList` 中的所有单词 **互不相同** 

**标签**
`广度优先搜索` `哈希表` `字符串` `回溯` 


##### solution
```python
#
# @lc app=leetcode.cn id=126 lang=python3
#
# [126] 单词接龙 II
# Solution参考 https://leetcode-cn.com/problems/word-ladder-ii/solution/bfs-level-order-traverse-by-matrix95/
# Solution2在此基础上改进
# Solution 30%
# Solution2 73%
# 找出所有的最短序列
# 1 首先BFS+层序遍历，停止条件为当前queue为空或者endWord在当前queue中，
# 这表示到这一层就是最短的转换序列
# 2 在遍历过程中构建字典用于后续回溯，格式为routine[next_word].append(cur_word)
# 3 回溯，注意routine[beginWord] = []，也就是routine[word]=[]时是一条符合条件的路径
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList):
        if endWord not in wordList or not beginWord or not endWord or not wordList:
            return []
        def backtrack(res, routine, path, endWord):
            if not routine[endWord]:
                res.append([endWord] + path)
            else:
                for pre in routine[endWord]:
                    backtrack(res, routine, [endWord] + path, pre)
        L = len(beginWord)
        res = []
        lookup = set([beginWord]) | set(wordList)
        routine = {word:[] for word in lookup}
        cur_queue = set([beginWord])
        while cur_queue and endWord not in cur_queue:
            next_queue = set()
            for word in cur_queue:
                lookup.remove(word)
            for word in cur_queue:
                for i in range(L):
                    for j in range(97,123):
                        next_word = word[:i] + chr(j) + word[i+1:]
                        if next_word in lookup:
                            next_queue.add(next_word)
                            routine[next_word].append(word)
            cur_queue = next_queue
        print(routine)
        if cur_queue:
            backtrack(res, routine, [], endWord)
        return res
class Solution2(object):
    def findLadders(self, beginWord, endWord, wordList):
        """
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: List[List[str]]
        """
        if not beginWord or not endWord or not wordList:
            return 0
        L = len(beginWord)
        def backtrack(res, routine, path, endWord):
            if not routine[endWord]:
                res.append([endWord] + path)
            else:
                for pre in routine[endWord]:
                    backtrack(res, routine, [endWord]+path, pre)
        from collections import defaultdict
        d = defaultdict(list)
        for word in wordList:
            for i in range(L):
                d[word[:i] + '*' + word[i+1:]].append(word)
        cur_queue = set([beginWord])
        lookup = set([beginWord]) | set(wordList)
        routine = {word:[] for word in lookup}
        res = []
        while cur_queue and endWord not in cur_queue:
            next_queue = set()
            for word in cur_queue:
                lookup.remove(word)
            for word in cur_queue:
                for i in range(L):
                    intermediate = word[:i] + '*' + word[i+1:]
                    for next_word in d[intermediate]:
                        if next_word in lookup:
                            next_queue.add(next_word)
                            routine[next_word].append(word)
            cur_queue = next_queue
        print(routine)
        print(cur_queue)
        # 非常关键，因为层序遍历的条件有两个，
        # 停止条件为当前queue为空或者endWord在当前queue中
        # 必须是endWord在当前quque中，即存在合适的转换序列时，才需要进行回溯
        if cur_queue:  # 非常关键，
            backtrack(res, routine, [], endWord)
        return res
beginWord = "hot"
endWord = "dog"
wordList = ["hot","dog"]
print(Solution().findLadders(beginWord, endWord, wordList))
# beginWord = "hit"
# endWord = "cog"
# wordList = ["hot","dot","dog","lot","log","cog"]
# # routine
# #{'lot': ['hot'], 'dog': ['dot'], 'cog': ['dog', 'log'], 'log': ['lot'], 'hot': ['hit'], 'hit': [], 'dot': ['hot']}
# print(Solution().findLadders(beginWord, endWord, wordList))
```
>
#### 127.单词接龙
[https://leetcode-cn.com/problems/word-ladder](https://leetcode-cn.com/problems/word-ladder) 
###### 原题
字典 `wordList` 中从单词 `beginWord` 和 `endWord` 的 **转换序列** 是一个按下述规格形成的序列<meta charset="UTF-8" /> `beginWord -> s<sub>1</sub> -> s<sub>2</sub> -> ... -> s<sub>k</sub>` ：
- 每一对相邻的单词只差一个字母。
- <meta charset="UTF-8" /> 对于 `1 <= i <= k` 时，每个<meta charset="UTF-8" /> `s<sub>i</sub>` 都在<meta charset="UTF-8" /> `wordList` 中。注意， `beginWord` 不需要在<meta charset="UTF-8" /> `wordList` 中。<meta charset="UTF-8" />
-  `s<sub>k</sub> == endWord` 
给你两个单词 `beginWord` 和 `endWord` 和一个字典 `wordList` ，返回 *从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目*** 。如果不存在这样的转换序列，返回 `0` 。


 **示例 1：** 

```

输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
输出：5
解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。

```
 **示例 2：** 

```

输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
输出：0
解释：endWord "cog" 不在字典中，所以无法进行转换。
```


 **提示：** 
-  `1 <= beginWord.length <= 10` 
-  `endWord.length == beginWord.length` 
-  `1 <= wordList.length <= 5000` 
-  `wordList[i].length == beginWord.length` 
-  `beginWord` 、 `endWord` 和 `wordList[i]` 由小写英文字母组成
-  `beginWord != endWord` 
-  `wordList` 中的所有字符串 **互不相同** 

**标签**
`广度优先搜索` `哈希表` `字符串` 


##### solution
```python
#
# @lc app=leetcode.cn id=127 lang=python3
#
# [127] 单词接龙
#
class Solution:
    # 72.09 %
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        from collections import defaultdict
        if endWord not in wordList or not beginWord or not endWord or not wordList:
            return 0
        L = len(beginWord)
        d = defaultdict(list)
        for word in wordList:
            for i in range(L):
                d[word[:i] + '*' + word[i+1:]].append(word)
        queue = [(beginWord, 1)]
        visited = {beginWord:True}  # set([beginWord])
        while queue:
            cur_word, level = queue.pop(0)
            for i in range(L):
                intermediate_word = cur_word[:i] + '*' + cur_word[i+1:]
                for word in d[intermediate_word]:
                    if word == endWord:
                        return level + 1
                    if word not in visited:
                        visited[word] = True
                        queue.append((word, level+1))
                d[intermediate_word] = []
        return 0
    # BFS 找遍distance=0的，再找distance=1
    # 33.41 %
    # def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
    #     distance, cur = 0, [beginWord]
    #     visited, lookup = set([beginWord]), set(wordList)
    #     while cur:
    #         next_queue = []
    #         for word in cur:
    #             if word == endWord:
    #                 return 1 + distance
    #             for i in range(len(word)):
    #                 for j in 'abcdefghijklmnopqrstuvwxyz':
    #                     candidate = word[:i] + j + word[i+1:]
    #                     if candidate not in visited and candidate in lookup:
    #                         visited.add(candidate)
    #                         next_queue.append(candidate)
    #         distance += 1
    #         cur = next_queue
    #     return 0
```
>
### 拓扑排序
#### 207.课程表
[https://leetcode-cn.com/problems/course-schedule](https://leetcode-cn.com/problems/course-schedule) 
###### 原题
你这个学期必须选修 `numCourses` 门课程，记为  `0`  到  `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组  `prerequisites` 给出，其中  `prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]` ，表示如果要学习课程  `a<sub>i</sub>` 则 **必须** 先学习课程  `b<sub>i</sub>` <sub> </sub>。
- 例如，先修课程对  `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。
请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

 

 **示例 1：** 

```

输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```
 **示例 2：** 

```

输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```


 **提示：** 
-  `1 <= numCourses <= 10^5` 
-  `0 <= prerequisites.length <= 5000` 
-  `prerequisites[i].length == 2` 
-  `0 <= a<sub>i</sub>, b<sub>i</sub> < numCourses` 
-  `prerequisites[i]` 中的所有课程对 **互不相同** 

**标签**
`深度优先搜索` `广度优先搜索` `图` `拓扑排序` 


##### solution
```python
#
# @lc app=leetcode.cn id=207 lang=python3
#
# [207] 课程表
# https://leetcode-cn.com/problems/course-schedule/solution/tuo-bu-pai-xu-by-liweiwei1419/
#
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        if len(prerequisites) == 0:
            return True
        in_degrees = [0 for _ in range(numCourses)]
        adj = [set() for _ in range(numCourses)]
        for second, first in prerequisites:
            in_degrees[second] += 1
            adj[first].add(second)
        queue = []
        for i in range(numCourses):
            if in_degrees[i] == 0:
                queue.append(i)
        counter = 0
        while queue:
            counter += 1
            cur = queue.pop(0)
            for node in adj[cur]:
                in_degrees[node] -= 1
                if in_degrees[node] == 0:
                    queue.append(node)
        return counter == numCourses
```
>
### 并查集
#### 547.朋友圈
[https://leetcode-cn.com/problems/number-of-provinces](https://leetcode-cn.com/problems/number-of-provinces) 
###### 原题


有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。

 **省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。

返回矩阵中 **省份** 的数量。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" style="width: 222px; height: 142px;" />
```

输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg" style="width: 222px; height: 142px;" />
```

输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
输出：3

```


 **提示：** 
-  `1 <= n <= 200` 
-  `n == isConnected.length` 
-  `n == isConnected[i].length` 
-  `isConnected[i][j]` 为 `1` 或 `0` 
-  `isConnected[i][i] == 1` 
-  `isConnected[i][j] == isConnected[j][i]` 

**标签**
`深度优先搜索` `广度优先搜索` `并查集` `图` 


##### solution
```python
#
# @lc app=leetcode.cn id=547 lang=python3
#
# [547] 朋友圈
#
# 并查集 47.81%
# class UnionFind:
#     def __init__(self, n):
#         self.father = list(range(n))
#         # rank[i]表示以i为根节点的集合的高度
#         self.rank = [0 for i in range(n)]
#         self.count = n
#     def find(self, x):
#         father = self.father
#         if father[x] != x:
#             # 路径压缩
#             father[x] = self.find(father[x])
#         return father[x]
#     def union(self, x, y):
#         father, rank = self.father, self.rank
#         x, y = map(self.find, [x, y])
#         # 如果x和y根节点相同，那么属于同一个集合
#         if x == y:
#             return False
#         # 高度小的树往高度大的树上合并，
#         # 操作为高度小的树的根节点连到高度大的树的根节点
#         if rank[x] > rank[y]:
#             father[y] = x
#         else:
#             father[x] = y
#             # 高为2的树往高为3的树上合并,高为3；
#             # 高为2的树往高为2的树上合并,高为2+1；
#             if rank[x] == rank[y]:
#                 rank[y] += 1
#         self.count -= 1
#         return True
#     def get_count(self):
#         return self.count
# class Solution:
#     def findCircleNum(self, M: List[List[int]]) -> int:
#         uf = UnionFind(len(M))
#         for i in range(len(M)):
#             for j in range(i+1, len(M[0])):
#                 if M[i][j] == 1:
#                     uf.union(i, j)
#         return uf.get_count()
# dfs 37.05%
class Solution:
    def findCircleNum(self, M: List[List[int]]) -> int:
        count = 0
        visited = [0 for _ in range(len(M))]
        for i in range(len(M)):
            if not visited[i]:
                count += 1
                self.dfs(M, visited, i)
        return count
    def dfs(self, M, visited, i):
        visited[i] = 1
        for j in range(len(M)):
            if M[i][j] and not visited[j]:
                self.dfs(M, visited, j)
```
>
#### 684.冗余连接
[https://leetcode-cn.com/problems/redundant-connection](https://leetcode-cn.com/problems/redundant-connection) 
###### 原题
树可以看成是一个连通且 **无环 ** 的  **无向 ** 图。

给定往一棵  `n` 个节点 (节点值  `1～n` ) 的树中添加一条边后的图。添加的边的两个顶点包含在 `1` 到 `n`  中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges`  ， `edges[i] = [a<sub>i</sub>, b<sub>i</sub>]`  表示图中在 `ai` 和 `bi` 之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组  `edges`  中最后出现的边。

 

 **示例 1：** 

<img alt="" src="https://pic.leetcode-cn.com/1626676174-hOEVUL-image.png" style="width: 152px; " />

```

输入: edges = [[1,2], [1,3], [2,3]]
输出: [2,3]

```
 **示例 2：** 

<img alt="" src="https://pic.leetcode-cn.com/1626676179-kGxcmu-image.png" style="width: 250px; " />

```

输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]

```


 **提示:** 
-  `n == edges.length` 
-  `3 <= n <= 1000` 
-  `edges[i].length == 2` 
-  `1 <= ai < bi <= edges.length` 
-  `ai != bi` 
-  `edges` 中无重复元素
- 给定的图是连通的 

**标签**
`深度优先搜索` `广度优先搜索` `并查集` `图` 


##### solution
```python
#
# @lc app=leetcode.cn id=684 lang=python3
#
# [684] 冗余连接
#
class Solution:
    # 97.7 %
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        parents = list(range(len(edges)+1))
        def get_parent(node):
            if parents[node] == node:
                return node
            else:
                return get_parent(parents[node])
        for e in edges:
            p1 = get_parent(e[0])
            p2 = get_parent(e[1])
            if p1 == p2:
                return e
            parents[p2] = p1
        return []
```
>
### 深度优先搜索
#### 79.单词搜索
[https://leetcode-cn.com/problems/word-search](https://leetcode-cn.com/problems/word-search) 
###### 原题
给定一个  `m x n` 二维字符网格  `board` 和一个字符串单词  `word` 。如果  `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" style="width: 322px; height: 242px;" />
```

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" style="width: 322px; height: 242px;" />
```

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true

```
 **示例 3：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" style="width: 322px; height: 242px;" />
```

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false

```


 **提示：** 
-  `m == board.length` 
-  `n = board[i].length` 
-  `1 <= m, n <= 6` 
-  `1 <= word.length <= 15` 
-  `board` 和 `word` 仅由大小写英文字母组成


 **进阶：** 你可以使用搜索剪枝的技术来优化解决方案，使其在 `board` 更大的情况下可以更快解决问题？


**标签**
`数组` `回溯` `矩阵` 


##### solution
```python
#
# @lc app=leetcode.cn id=79 lang=python3
#
# [79] 单词搜索
#
# 79.92% 35.74%
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        row, col = len(board), len(board[0])
        def dfs(word, i, j):
            if not word:
                return True
            if 0 <= i < row and 0 <= j < col and board[i][j] == word[0]:
                # 注：原来是使用一个visited数组去保存是否访问过的，已改进
                # 仅在寻找单词的下一个字母的时候，将当前位置设置为已访问过
                tmp = board[i][j]
                board[i][j] = 3
                flag = dfs(word[1:], i-1, j) or dfs(word[1:], i+1, j) \
                    or dfs(word[1:], i, j-1) or dfs(word[1:], i, j+1)
                # 在当前位置往外寻找word结束后，将当前位置再设置为未访问过
                # 因为对board的位置进行循环的时候，
                # 到下一个位置仍旧是用上全部的board去匹配word
                board[i][j] = tmp
                return flag
            return False
        for i in range(row):
            for j in range(col):
                if board[i][j] == word[0]:
                    if dfs(word, i, j):
                        return True
        return False
```
>
#### 130.被围绕的区域
[https://leetcode-cn.com/problems/surrounded-regions](https://leetcode-cn.com/problems/surrounded-regions) 
###### 原题
给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` ，找到所有被 `'X'` 围绕的区域，并将这些区域里所有的  `'O'` 用 `'X'` 填充。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" style="width: 550px; height: 237px;" />
```

输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。

```
 **示例 2：** 

```

输入：board = [["X"]]
输出：[["X"]]

```


 **提示：** 
-  `m == board.length` 
-  `n == board[i].length` 
-  `1 <= m, n <= 200` 
-  `board[i][j]` 为 `'X'` 或 `'O'` 

**标签**
`深度优先搜索` `广度优先搜索` `并查集` `数组` `矩阵` 


##### solution
```python
#
# @lc app=leetcode.cn id=130 lang=python3
#
# [130] 被围绕的区域
#
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        if not board:
            return
        row, col = len(board), len(board[0])
        # 每个单元格都是边界的情况
        if row < 3 or col < 3:
            return
        def dfs(i, j):
            if 0 <= i < row and 0 <= j < col and board[i][j] == 'O':
                board[i][j] = '#'
                dfs(i-1, j)
                dfs(i+1, j)
                dfs(i, j-1)
                dfs(i, j+1)
        for i in range(row):
            dfs(i, 0)
            dfs(i, col-1)
        for i in range(col):
            dfs(0, i)
            dfs(row-1, i)
        for i in range(row):
            for j in range(col):
                if board[i][j] == 'O':
                    board[i][j] = 'X'
                if board[i][j] == '#':
                    board[i][j] = 'O'
```
>
#### 200.岛屿的个数
[https://leetcode-cn.com/problems/number-of-islands](https://leetcode-cn.com/problems/number-of-islands) 
###### 原题
给你一个由  `'1'` （陆地）和 `'0'` （水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

 **示例 1：** 

```

输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1

```
 **示例 2：** 

```

输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3

```


 **提示：** 
-  `m == grid.length` 
-  `n == grid[i].length` 
-  `1 <= m, n <= 300` 
-  `grid[i][j]` 的值为 `'0'` 或 `'1'` 

**标签**
`深度优先搜索` `广度优先搜索` `并查集` `数组` `矩阵` 


##### solution
```python
#
# @lc app=leetcode.cn id=200 lang=python3
#
# [200] 岛屿的个数
#
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        count = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    count += 1
                    self.dfs(grid, i, j)
        return count
    def dfs(self, grid, i, j):
        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == '1':
            grid[i][j] = '0'
            self.dfs(grid, i-1, j)
            self.dfs(grid, i, j-1)
            self.dfs(grid, i+1, j)
            self.dfs(grid, i, j+1)
```
>
#### 212.单词搜索-ii
[https://leetcode-cn.com/problems/word-search-ii](https://leetcode-cn.com/problems/word-search-ii) 
###### 原题
给定一个 `m x n` 二维字符网格 `board` **** 和一个单词（字符串）列表 `words` ， *返回所有二维网格上的单词* 。

单词必须按照字母顺序，通过 **相邻的单元格** 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" />
```

输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
输出：["eat","oath"]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" />
```

输入：board = [["a","b"],["c","d"]], words = ["abcb"]
输出：[]

```


 **提示：** 
-  `m == board.length` 
-  `n == board[i].length` 
-  `1 <= m, n <= 12` 
-  `board[i][j]` 是一个小写英文字母
-  `1 <= words.length <= 3 * 10^4` 
-  `1 <= words[i].length <= 10` 
-  `words[i]` 由小写英文字母组成
-  `words` 中的所有字符串互不相同

**标签**
`字典树` `数组` `字符串` `回溯` `矩阵` 


##### solution
```python
#
# @lc app=leetcode.cn id=212 lang=python3
#
# [212] 单词搜索 II
#
# 45.36% 92.96%
class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        root = {}
        for word in words:
            node = root
            for letter in word:
                node = node.setdefault(letter, {})
            node['isWord'] = True
        row = len(board)
        col = len(board[0])
        res = []
        def dfs(i, j, word, node):
            if 0 <= i < row and 0 <= j < col and board[i][j] in node:
                node = node[board[i][j]]
                word += board[i][j]
                if 'isWord' in node:
                    res.append(word)
                tmp = board[i][j]
                board[i][j] = 3
                dfs(i-1, j, word, node)
                dfs(i+1, j, word, node)
                dfs(i, j-1, word, node)
                dfs(i, j+1, word, node)
                board[i][j] = tmp
        for i in range(row):
            for j in range(col):
                if board[i][j] in root:
                    dfs(i, j, "", root)
        return list(set(res))
# 84.7% 33.8%
# class TrieNode:
#     def __init__(self):
#         self.childs = {}
#         self.isWord = False
# class Trie:
#     def __init__(self):
#         self.root = TrieNode()
#     def insert(self, word):
#         node = self.root
#         for letter in word:
#             child = node.childs.get(letter)
#             if not child:
#                 child = TrieNode()
#                 node.childs[letter] = child
#             node = child
#         node.isWord = True
# class Solution:
#     def findWords(self, board, words):
#         row = len(board)
#         col = len(board[0])
#         res = []
#         def dfs(i, j, word, node):
#             if 0 <= i < row and 0 <= j < col and board[i][j] in node.childs:
#                 node = node.childs[board[i][j]]
#                 word += board[i][j]
#                 if node.isWord:
#                     res.append(word)
#                 tmp = board[i][j]
#                 board[i][j] = 3
#                 dfs(i-1, j, word, node)
#                 dfs(i+1, j, word, node)
#                 dfs(i, j-1, word, node)
#                 dfs(i, j+1, word, node)
#                 board[i][j] = tmp
#         head_unique = set()
#         root = Trie()
#         for word in words:
#             root.insert(word)
#             head_unique.add(word[0])
#         for i in range(row):
#             for j in range(col):
#                 if board[i][j] in head_unique:
#                     dfs(i, j, "", root.root)
#         return list(set(res))
# board = [['a', 'a']]
# words = ['aaa']
# print(Solution().findWords(board, words))
```
>
#### 329.矩阵中的最长递增路径
[https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix) 
###### 原题
给定一个  `m x n` 整数矩阵  `matrix` ，找出其中 **最长递增路径** 的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你 **不能** 在 **对角线** 方向上移动或移动到 **边界外** （即不允许环绕）。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg" style="width: 242px; height: 242px;" />
```

输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]
输出：4 
解释：最长递增路径为 [1, 2, 6, 9]。
```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg" style="width: 253px; height: 253px;" />
```

输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]
输出：4 
解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。

```
 **示例 3：** 

```

输入：matrix = [[1]]
输出：1

```


 **提示：** 
-  `m == matrix.length` 
-  `n == matrix[i].length` 
-  `1 <= m, n <= 200` 
-  `0 <= matrix[i][j] <= 2^31 - 1` 

**标签**
`深度优先搜索` `广度优先搜索` `图` `拓扑排序` `记忆化搜索` `动态规划` 


##### solution
```python
#
# @lc app=leetcode.cn id=329 lang=python3
#
# [329] 矩阵中的最长递增路径
#
class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        row = len(matrix)
        col = len(matrix[0])
        def dfs(i, j, visited, cache):
            if (i, j) in visited:
                return visited[(i, j)]
            res = 0
            for di, dj in directions:
                p, q = i + di, j + dj
                if p < 0 or q < 0 or p >= row or q >= col:
                    continue
                if (p, q) not in cache and matrix[p][q] > matrix[i][j]:
                    cache.add((p, q))
                    r = dfs(p, q, visited, cache)
                    res = max(res, r)
                    cache.discard((p, q))
            visited[(i, j)] = 1 + res
            return 1 + res
        ans = 0
        visited = {}
        cache = set()
        for i in range(row):
            for j in range(col):
                cache.add((i, j))
                res = dfs(i, j, visited, cache)
                ans = max(ans, res)
                cache.discard((i, j))
        return ans
```
>
## 7堆
#### 23.合并k个排序链表
[https://leetcode-cn.com/problems/merge-k-sorted-lists](https://leetcode-cn.com/problems/merge-k-sorted-lists) 
##### 原题
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

 

 **示例 1：** 

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6

```
 **示例 2：** 

```
输入：lists = []
输出：[]

```
 **示例 3：** 

```
输入：lists = [[]]
输出：[]

```


 **提示：** 
-  `k == lists.length` 
-  `0 <= k <= 10^4` 
-  `0 <= lists[i].length <= 500` 
-  `-10^4 <= lists[i][j] <= 10^4` 
-  `lists[i]` 按 **升序** 排列
-  `lists[i].length` 的总和不超过 `10^4` 

**标签**
`链表` `分治` `堆（优先队列）` `归并排序` 


##### solution
```python
#
# @lc app=leetcode.cn id=23 lang=python3
#
# [23] 合并K个排序链表
#
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
# 86.99% python
# class Solution:
#     def mergeKLists(self, lists):
#         import heapq
#         heap = []
#         for list_head in lists:
#             if list_head:
#                 heapq.heappush(heap, ((list_head.val, list_head)))
#         p = ListNode(-1)
#         dummy = p
#         while heap:
#             min_node = heapq.heappop(heap)[1]
#             p.next = min_node
#             p = p.next
#             if min_node.next:
#                 heapq.heappush(heap, (min_node.next.val, min_node.next))
#         return dummy.next
# python3 9.89%
class Solution:
    def mergeKLists(self, lists):
        def heapify(unsorted, index, heap_size):
            largest = index
            left_index = 2 * index + 1
            right_index = 2 * index + 2
            if left_index < heap_size and unsorted[left_index][0] < unsorted[largest][0]:
                largest = left_index
            if right_index < heap_size and unsorted[right_index][0] < unsorted[largest][0]:
                largest = right_index
            if largest != index:
                unsorted[largest], unsorted[index] = unsorted[index], unsorted[largest]
                heapify(unsorted, largest, heap_size)
        def heap_sort(unsorted):
            n = len(unsorted)
            for i in range(n // 2 - 1, -1, -1):
                heapify(unsorted, i, n)
            for i in range(n - 1, 0, -1):
                    unsorted[0], unsorted[i] = unsorted[i], unsorted[0]
                    heapify(unsorted, 0, i)
        unsorted = []
        for list_head in lists:
            if list_head:
                unsorted.append((list_head.val, list_head))
        heap_sort(unsorted)
        p = ListNode(-1)
        dummy = p
        while unsorted:
            min_node = unsorted.pop()[1]
            p.next = min_node
            p = p.next
            if min_node.next:
                unsorted.append((min_node.next.val, min_node.next))
                heap_sort(unsorted)
        return dummy.next
```
>
#### 295.数据流的中位数
[https://leetcode-cn.com/problems/find-median-from-data-stream](https://leetcode-cn.com/problems/find-median-from-data-stream) 
##### 原题
中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：
- void addNum(int num) - 从数据流中添加一个整数到数据结构中。
- double findMedian() - 返回目前所有元素的中位数。
 **示例：** 

```
addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2
```
 **进阶:** 
- 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？
- 如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？

**标签**
`设计` `双指针` `数据流` `排序` `堆（优先队列）` 


##### solution
```python
#
# @lc app=leetcode.cn id=295 lang=python3
#
# [295] 数据流的中位数
#
import heapq
class MedianFinder:
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.left = []
        self.right = []
        self.median = None
    def addNum(self, num: int) -> None:
        if self.median is None:
            self.median = num
            return
        left, right = self.left, self.right
        if num <= self.median:
            heapq.heappush(left, -num)
        else:
            heapq.heappush(right, num)
        if len(left) > len(right) + 1:
            top = -heapq.heappop(left)
            heapq.heappush(right, self.median)
            self.median = top
        if len(right) > len(left) + 1:
            top = heapq.heappop(right)
            heapq.heappush(left, -self.median)
            self.median = top
    def findMedian(self) -> float:
        left, right = self.left, self.right
        if len(left) == len(right):
            return 1. * self.median
        elif len(left) > len(right):
            return 1. * (self.median - left[0]) / 2
        else:
            return 1. * (self.median + right[0]) / 2
# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder()
# obj.addNum(num)
# param_2 = obj.findMedian()
```
>
## 9字典树
#### 208.实现-trie-前缀树
[https://leetcode-cn.com/problems/implement-trie-prefix-tree](https://leetcode-cn.com/problems/implement-trie-prefix-tree) 
##### 原题
 **<a href="https://baike.baidu.com/item/字典树/9825209?fr=aladdin" target="_blank">Trie</a>** （发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：
-  `Trie()` 初始化前缀树对象。
-  `void insert(String word)` 向前缀树中插入字符串 `word` 。
-  `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true` （即，在检索之前已经插入）；否则，返回 `false` 。
-  `boolean startsWith(String prefix)` 如果之前已经插入的字符串  `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。


 **示例：** 

```

输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True

```


 **提示：** 
-  `1 <= word.length, prefix.length <= 2000` 
-  `word` 和 `prefix` 仅由小写英文字母组成
-  `insert` 、 `search` 和 `startsWith` 调用次数 **总计** 不超过 `3 * 10^4` 次

**标签**
`设计` `字典树` `哈希表` `字符串` 


##### solution
```python
#
# @lc app=leetcode.cn id=208 lang=python3
#
# [208] 实现 Trie (前缀树)
#
# 在这儿交不了，
# Failed to test the solution. Please open the output channel for details.
# 执行用时 :196 ms, 在所有 Python3 提交中击败了58.77%的用户
# 内存消耗 :29.2 MB, 在所有 Python3 提交中击败了40.86%的用户
class TrieNode:
    def __init__(self):
        self.childs = dict()
        self.isWord = False
class Trie:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = TrieNode()
    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        node = self.root
        for letter in word:
            child = node.childs.get(letter)
            if not child:
                child = TrieNode()
                node.childs[letter] = child
            node = child
        node.isWord = True
    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        node = self.root
        for letter in word:
            child = node.childs.get(letter)
            if not child:
                return False
            node = child
        return node.isWord
    def startsWith(self, prefix: str) -> bool:
        """
        Returns if there is any word in the trie that starts with the given prefix.
        """
        node = self.root
        for letter in prefix:
            child = node.childs.get(letter)
            if not child:
                return False
            node = child
        return True
# Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.startsWith(prefix)
```
>
#### 648.单词替换
[https://leetcode-cn.com/problems/replace-words](https://leetcode-cn.com/problems/replace-words) 
##### 原题
在英语中，我们有一个叫做 `词根` (root) 的概念，可以词根 **后面** 添加其他一些词组成另一个较长的单词——我们称这个词为 `继承词` (successor)。例如，词根 `an` ，跟随着单词 `other` (其他)，可以形成新的单词 `another` (另一个)。

现在，给定一个由许多 **词根** 组成的词典 `dictionary` 和一个用空格分隔单词形成的句子 `sentence` 。你需要将句子中的所有 **继承词** 用 **词根** 替换掉。如果 **继承词** 有许多可以形成它的 **词根** ，则用 **最短** 的词根替换它。

你需要输出替换之后的句子。

 

 **示例 1：** 

```

输入：dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"
输出："the cat was rat by the bat"

```
 **示例 2：** 

```

输入：dictionary = ["a","b","c"], sentence = "aadsfasf absbs bbab cadsfafs"
输出："a a b c"

```


 **提示：** 
-  `1 <= dictionary.length <= 1000` 
-  `1 <= dictionary[i].length <= 100` 
-  `dictionary[i]` 仅由小写字母组成。
-  `1 <= sentence.length <= 10^6` 
-  `sentence` 仅由小写字母和空格组成。
-  `sentence` 中单词的总量在范围 `[1, 1000]` 内。
-  `sentence` 中每个单词的长度在范围 `[1, 1000]` 内。
-  `sentence` 中单词之间由一个空格隔开。
-  `sentence` 没有前导或尾随空格。



**标签**
`字典树` `数组` `哈希表` `字符串` 


##### solution
```python
#
# @lc app=leetcode.cn id=648 lang=python3
#
# [648] 单词替换
#
class Solution:
    def replaceWords(self, dict: List[str], sentence: str) -> str:
        root = {}
        for word in dict:
            node = root
            for letter in word:
                node = node.setdefault(letter, {})
            node['end'] = True
        res = []
        for word in sentence.split():
            node = root
            prefix = ''
            flag = False  # 表示当前单词是否有前缀
            for letter in word:
                prefix += letter
                node = node.setdefault(letter, {})
                if 'end' in node:
                    flag = True
                    res.append(prefix)
                    break
            if not flag:
                res.append(word)
        return ' '.join(res)
```
>
#### 677.键值映射
[https://leetcode-cn.com/problems/map-sum-pairs](https://leetcode-cn.com/problems/map-sum-pairs) 
##### 原题
设计一个 map ，满足以下几点:
- 字符串表示键，整数表示值
- 返回具有前缀等于给定字符串的键的值的总和
实现一个 `MapSum` 类：
-  `MapSum()` 初始化 `MapSum` 对象
-  `void insert(String key, int val)` 插入 `key-val` 键值对，字符串表示键 `key` ，整数表示值 `val` 。如果键 `key` 已经存在，那么原来的键值对 `key-value` 将被替代成新的键值对。
-  `int sum(string prefix)` 返回所有以该前缀 `prefix` 开头的键 `key` 的值的总和。


 **示例 1：** 

```

输入：
["MapSum", "insert", "sum", "insert", "sum"]
[[], ["apple", 3], ["ap"], ["app", 2], ["ap"]]
输出：
[null, null, 3, null, 5]

解释：
MapSum mapSum = new MapSum();
mapSum.insert("apple", 3);  
mapSum.sum("ap");           // 返回 3 (apple = 3)
mapSum.insert("app", 2);    
mapSum.sum("ap");           // 返回 5 (apple + app = 3 + 2 = 5)

```


 **提示：** 
-  `1 <= key.length, prefix.length <= 50` 
-  `key` 和 `prefix` 仅由小写英文字母组成
-  `1 <= val <= 1000` 
- 最多调用 `50` 次 `insert` 和 `sum` 

**标签**
`设计` `字典树` `哈希表` `字符串` 


##### solution
```python
#
# @lc app=leetcode.cn id=677 lang=python3
#
# [677] 键值映射
#
 %#56.72%
# class MapSum:
#     def __init__(self):
#         """
#         Initialize your data structure here.
#         """
#         self.d = {}
#     def insert(self, key: str, val: int) -> None:
#         self.d[key] = val
#     def sum(self, prefix: str) -> int:
#         res = 0
#         for k, v in self.d.items():
#             if k.startswith(prefix):
#                 res += v
#         return res
#
class MapSum:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = {}
    def insert(self, key: str, val: int) -> None:
        node = self.root
        for letter in key:
            # setdefault 如果字典中包含有给定键，
            # 则返回该键对应的值，否则返回为该键设置的值
            node = node.setdefault(letter, {})
        node['end'] = val
    def sum(self, prefix: str) -> int:
        node = self.root
        for letter in prefix:
            node = node.setdefault(letter, {})
        self.res = 0
        def dfs(node):
            for k, v in node.items():
                if k == 'end':
                    self.res += v
                else:
                    dfs(v)
        dfs(node)
        return self.res
# Your MapSum object will be instantiated and called as such:
# obj = MapSum()
# obj.insert(key,val)
# param_2 = obj.sum(prefix)
```
>

