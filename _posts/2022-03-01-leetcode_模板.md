---
layout:     post
title:      leetcode-模板
subtitle:   
date:       2022-03-01
author:     FishRedLeaf
header-img: iu_img/my_iu_13.jpg
catalog: true
tags:
    - DSA与刷题/leetcode


---

模板

# 数据结构

## 链表

反转链表：直接反，反一段，k个一组全反

合并k个排序链表

链表是否成环，环的入口

## 栈和队列

逆波兰表达式



## 单调栈

https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/

## 字符串

strStr



## 二叉树

前序遍历

中序遍历

后序遍历

层序遍历

Z字遍历

## 二叉搜索树

https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/solution/zhong-xu-bian-li-tuan-mie-xi-lie-er-cha-sou-suo-sh/



## 前缀树

### solution1 依赖TrieNode实现，设计更合理

```python
class TrieNode:

    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False


class Trie:

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        node = self.root
        for c in word:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                node.children[idx] = TrieNode()
            node = node.children[idx]
        node.isEnd = True

    def search(self, word: str) -> bool:
        node = self.root
        for c in word:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                return False
            node = node.children[idx]
        return node.isEnd

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for c in prefix:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                return False
            node = node.children[idx]
        return True
```

### solution2 Trie本身实现

```python
class Trie:

    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False

    def insert(self, word: str) -> None:
        node = self
        for c in word:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                node.children[idx] = Trie()
            node = node.children[idx]
        node.isEnd = True

    def search(self, word: str) -> bool:
        node = self
        for c in word:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                return False
            node = node.children[idx]
        return node.isEnd

    def startsWith(self, prefix: str) -> bool:
        node = self
        for c in prefix:
            idx = ord(c) - ord('a')
            if not node.children[idx]:
                return False
            node = node.children[idx]
        return True
```



## 线段树



## 并查集

### union & find

```python
parent = list(range(n))
def find(i):
    if parent[i] != i:
        parent[i] = find(parent[i])
    return parent[i]

def union(i, j):
    parent[find(i)] = find(j)
```



# 算法

## 二分

https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/

##### general

```python
def general(nums, target):
    if not nums:
        return -1
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + ((right - left) >> 1)
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

##### 查找第一个

```python
def left_bound(nums, target):
    if not nums:
        return -1
    left, right = 0, len(nums) - 1
    ans = -1
    while left <= right:
        mid = left + ((right - left) >> 1)
        if nums[mid] == target:
            right = mid - 1
            ans = mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return ans
```

##### 查找最后一个

```python
def right_bound(nums, target):
    if not nums:
        return -1
    left, right = 0, len(nums) - 1
    ans = -1
    while left <= right:
        mid = left + ((right - left) >> 1)
        if nums[mid] == target:
            left = mid + 1
            ans = mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return ans
```



## 滑动窗口



## 排序算法

### 快速排序

```python
def partition(nums, l, r):
    p = random.randint(l, r)
    pv = nums[p]
    nums[p], nums[r] = nums[r], nums[p]
    mid = l
    for i in range(l, r):
        if nums[i] <= pv:
            nums[mid], nums[i] = nums[i], nums[mid]
            mid += 1
    nums[mid], nums[r] = nums[r], nums[mid]
    return mid

def quick_sort(nums, left, right):
    if right <= left:
        return
    mid = partition(nums, left, right)
    quick_sort(nums, left, mid - 1)
    quick_sort(nums, mid + 1, right)
```

#### 链表快排

```python
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None
        
# 大于left->val放到右边，小于left->val放到左边
def partition(left, right):
    pv = left.val
    i, j = left, left.next
    while j != right:
        if j.val < pv:
            i = i.next
            i.val, j.val = j.val, i.val
        j = j.next
    left.val, i.val = i.val, left.val
    return i

def quick_sort(left, right):
    if left != right:
        mid = partition(left, right)
        quick_sort(left, mid)
        quick_sort(mid.next, right)
        
def create(items):
    head = ListNode(items[0])
    p = head
    for i in items[1:]:
        p.next = ListNode(i)
        p = p.next
    return head

def print_nodes(head):
    while head:
        print(head.val, end=' ')
        head = head.next
    
head = create([4,2,5,3,7,9,0,1])
quick_sort(head, None)
print_nodes(head)
```



### 归并排序

```python
def merge_sort(nums):
    if len(nums) <= 1:
        return
    mid = len(nums) // 2
    left = nums[:mid]
    right = nums[mid:]
    merge_sort(left)
    merge_sort(right)

    i, j, k = 0, 0, 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            nums[k] = left[i]
            i += 1
        else:
            nums[k] = right[j]
            j += 1
        k += 1

    while i < len(left):
        nums[k] = left[i]
        i += 1
        k += 1
    while j < len(right):
        nums[k] = right[j]
        j += 1
        k += 1
```



### 堆排序

-   https://www.cnblogs.com/chengxiao/p/6129630.html
-   构造初始大顶堆，从第一个非叶子节点到根节点，将每个节点都调整为左右子节点中最大的
-   每次对未排序的部分构造最大堆，然后交换最大堆的顶点和最后一个数
-   heapify过程
    -   index对应的节点一定比左右节点大，但是需要对调整后的new_index节点进行heapify，使这个节点也满足大顶堆性质
    -   调整大顶堆从下往上，从左往右调整。
    -   例如，4,6,8,5,9->4,9,8,5,6；顶点9本身满足比左右子节点大，但是右节点交换过了，需要对这个交换过的子节点heapify

```python
def heapify(nums, index, heap_size):
    left_index = 2 * index
    right_index = 2 * index + 1
    new_index = index
    if left_index < heap_size and nums[left_index] > nums[new_index]:
        new_index = left_index
    if right_index < heap_size and nums[right_index] > nums[new_index]:
        new_index = right_index
    if new_index != index:
        nums[index], nums[new_index] = nums[new_index], nums[index]
        heapify(nums, new_index, heap_size)
    

def heap_sort(nums):
    n = len(nums)
    for i in range(n // 2 - 1, -1, -1):
        heapify(nums, i, n)
    for i in range(n - 1, -1, -1):
        nums[0], nums[i] = nums[i], nums[0]
        heapify(nums, 0, i)
```



## 拓扑排序



## DFS

https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/

https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-ga-4/

## BFS



## 动态规划

### 背包系列

### 股票买卖

### 其他





## 最短路径算法



## 最小生成树算法





# 专项

## 前缀和专项

https://leetcode-cn.com/circle/discuss/JK7Dn9/

https://leetcode-cn.com/circle/article/EQWhUd/

https://lucifer.ren/blog/2020/09/27/atMostK/





## 矩阵专项



## 整数专项

7.整数反转

8.字符串转换整数

9.回文数

## 实现数据结构专项



## LRU&LFU专项

