---
layout:     post
title:      leetcode-专项突击-二分查找系列
subtitle:   
date:       2022-03-02
author:     FishRedLeaf
header-img: iu_img/my_iu_25.jpg
catalog: true
tags:
    - DSA与刷题/leetcode
---

专项突击——二分查找系列



# 题目

704, 4, 278, 剑指offer51, 300, 33, 81, 35, 34, 153, 154(剑指offer11), 475, 

# 模板

https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/

## 我的模板

### general

```python
def general(nums, target):
    if not nums:
        return -1
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + ((right - left) >> 1)
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

### 查找第一个

```python
def left_bound(nums, target):
    if not nums:
        return -1
    left, right = 0, len(nums) - 1
    ans = -1
    while left <= right:
        mid = left + ((right - left) >> 1)
        if nums[mid] == target:
            right = mid - 1
            ans = mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return ans
```

### 查找最后一个

```python
def right_bound(nums, target):
    if not nums:
        return -1
    left, right = 0, len(nums) - 1
    ans = -1
    while left <= right:
        mid = left + ((right - left) >> 1)
        if nums[mid] == target:
            left = mid + 1
            ans = mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return ans
```

## B站大雪菜的模板

https://www.bilibili.com/video/BV1Ft41157zW?spm_id_from=333.999.0.0

力扣也有人整理了下https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/tu-jie-er-fen-zui-qing-xi-yi-dong-de-jia-ddvc/

### 版本1

当我们将区间`[l, r]`分成`[l, mid]`和`[mid+1, r]`时，其更新操作是`r = mid`或者`l = mid + 1`，计算mid时不需要加1，即`mid = (l + r)/2`。

```python
def binary_search(l, r):
    while l < r:
        mid = l + ((r - l) >> 1)
        if check(mid):
            r = mid
        else:
            l = mid + 1
    return l
```

### 版本2

当我们将区间`[l, r]`分成`[l, mid-1]`和`[mid, r]`时，其更新操作是`r = mid - 1`或者`l = mid`，此时为了防止死循环，计算mid时需要加1，即`mid = (l + r + 1)/2`。

```python
def binary_search(l, r):
    while l < r:
        mid = l + ((1 + r - l) >> 1)
        if check(mid):
            l = mid
        else:
            r = mid - 1
    return l
```



<img src="/Users/bingjian.yan/Desktop/e6c9d24ely1h0umzaj2umj20u00vfq5c.png" alt="image-20220401232634542" style="zoom: 50%;" />



# 4.寻找两个正序数组的中位数

[https://leetcode-cn.com/problems/median-of-two-sorted-arrays](https://leetcode-cn.com/problems/median-of-two-sorted-arrays) 

## 原题

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2` 。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

 

 **示例 1：** 

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2

```

 **示例 2：** 

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5

```




 **提示：** 

-  `nums1.length == m` 
-  `nums2.length == n` 
-  `0 <= m <= 1000` 
-  `0 <= n <= 1000` 
-  `1 <= m + n <= 2000` 
-  `-10^6 <= nums1[i], nums2[i] <= 10^6` 

**标签**
`数组` `二分查找` `分治` 

## solution

-   转成求A和B数组中第k小的数，然后用k/2在A和B中分别找。
-   比如k = 6, 分别看A和B中的第3个数, 已知 A1 < A2 < A3 < A4 < A5... 和 B1 < B2 < B3 < B4 < B5..., 
    -   如果A3 <＝ B3, 那么第6小的数肯定不会是A1, A2, A3, 因为最多有两个数(B1和B2)小于A1, 三个数(B1和B2, A1)小于A2, 四个数(B1和B2, A1和A2)小于A3。
    -   B3至少大于5个数, 所以第6小的数有可能是B1 (A1 < A2 < A3 < A4 < A5 < B1), 有可能是B2 (A1 < A2 < A3 < B1 < A4 < B2), 有可能是B3 (A1 < A2 < A3 < B1 < B2 < B3)。那就可以排除掉A1, A2, A3, 转成求A4, A5, ... B1, B2, B3, ...这些数中第3小的数的问题, k就被减半了。
    -   每次都假设A的元素个数少, pa = min(k/2, lenA)的结果可能导致k == 1或A空, 这两种情况都是终止条件。 
-   整理自http://chaoren.is-programmer.com/posts/42890.html，http://yucoding.blogspot.com/2013/01/leetcode-question-50-median-of-two.html

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        def findMinK(nums1, nums2, k):
            if len(nums1) > len(nums2):
                return findMinK(nums2, nums1, k)
            l1, l2 = len(nums1), len(nums2)
            if l1 == 0:
                return nums2[k-1]
            if k == 1:
                return min(nums1[0], nums2[0])
            pa = min(k // 2, l1)
            pb = k - pa
            return findMinK(nums1[pa:], nums2, k-pa) if nums1[pa-1] <= nums2[pb-1] else findMinK(nums1, nums2[pb:], k-pb)
        
        l1, l2 = len(nums1), len(nums2)
        if (l1 + l2) % 2 == 1:
            return findMinK(nums1, nums2, (l1 + l2) // 2 + 1)
        else:
            return 0.5 * (findMinK(nums1, nums2, (l1 + l2) // 2 + 1) + findMinK(nums1, nums2, (l1 + l2) // 2))
```

>

# 33.搜索旋转排序数组

[https://leetcode-cn.com/problems/search-in-rotated-sorted-array](https://leetcode-cn.com/problems/search-in-rotated-sorted-array) 

## 原题

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前， `nums` 在预先未知的某个下标 `k` （ `0 <= k < nums.length` ）上进行了 **旋转** ，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` （下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为  `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回  `-1`  。

 

 **示例 1：** 

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4

```

 **示例 2：** 

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

 **示例 3：** 

```
输入：nums = [1], target = 0
输出：-1

```


 **提示：** 

-  `1 <= nums.length <= 5000` 
-  `-10^4 <= nums[i] <= 10^4` 
-  `nums` 中的每个值都 **独一无二** 
-  题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
-  `-10^4 <= target <= 10^4` 


 **进阶：** 你可以设计一个时间复杂度为 `O(log n)` 的解决方案吗？

**标签**
`数组` `二分查找` 

## solution

-   数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的
-   以左边有序为例，右边有序同理
    -   如果target在左边，因为左边是有序的，因此可以通过判断target是否落在nums[l]和nums[mid]直接快速确定，那么可以确定新的右边界；
    -   否则target落在无序的右边，可以更新左边界

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        n = len(nums)
        l, r = 0, n - 1
        while l <= r:
            mid = l + ((r - l) >> 1)
            if nums[mid] == target:
                return mid
            elif nums[l] <= nums[mid]:
                if nums[l] <= target < nums[mid]:
                    r = mid - 1
                else:
                    l = mid + 1
            else:
                if nums[mid] < target <= nums[r]:
                    l = mid + 1
                else:
                    r = mid - 1
        return -1
```

>

# 34.在排序数组中查找元素的第一个和最后一个位置

[https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array) 

## 原题

给定一个按照升序排列的整数数组 `nums` ，和一个目标值 `target` 。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target` ，返回  `[-1, -1]` 。

 **进阶：** 

- 你可以设计并实现时间复杂度为  `O(log n)`  的算法解决此问题吗？


 **示例 1：** 

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

 **示例 2：** 

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

 **示例 3：** 

```
输入：nums = [], target = 0
输出：[-1,-1]
```


 **提示：** 

-  `0 <= nums.length <= 10^5` 
-  `-10^9 <= nums[i] <= 10^9` 
-  `nums`  是一个非递减数组
-  `-10^9 <= target <= 10^9` 

**标签**
`数组` `二分查找` 

## solution0 大雪菜模板写法

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if not nums:
            return [-1, -1]
        n = len(nums)
        res = []

        # 找第一个位置，就是在nums中找第一个大于等于target的数
        
        l, r = 0, n - 1
        while l < r:
            mid = l + r >> 1
            if nums[mid] >= target:
                r = mid
            else:
                l = mid + 1
        if r < n and nums[r] == target:
            res.append(r)
        else:
            return [-1, -1]
        
        # 找最后一个位置，就是在nums中找第一个最后一个小于等于target的数
        
        l, r = 0, n - 1
        while l < r:
            mid = l + r + 1 >> 1
            if nums[mid] <= target:
                l = mid
            else:
                r = mid - 1
        if res[0] <= r < n and nums[r] == target:
            res.append(r)
        return res
```



## solution1 寻找第一个大于target-1的数和第一个大于target的数

-   `find_bigger_than_k(nums, k)`用于找到第一个比k大的数
-   由于可能找不到比k大的数，所以ans默认值设置为nums长度，这样`right_idx = len(nums) - 1`，如果发现最后一个数等于target的话，那么说明right_idx就表示最后一个等于target的数的索引

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def find_bigger_than_k(nums, k):
            l, r = 0, len(nums) - 1
            ans = len(nums)
            while l <= r:
                mid = l + ((r - l) >> 1)
                if nums[mid] > k:
                    r = mid - 1
                    ans = mid
                else:
                    l = mid + 1
            return ans
        
        left_idx = find_bigger_than_k(nums, target - 1)
        right_idx = find_bigger_than_k(nums, target) - 1
        if left_idx <= right_idx and right_idx < len(nums) and nums[left_idx] == target and nums[right_idx] == target:
            return [left_idx, right_idx]
        return [-1, -1]
```

## solution2 相等时也收缩

-   查找第一个数：找到target时，继续收缩右边界
-   查找最后一个数：找到target时，继续收缩左边界

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def left_bound(nums, target):
            if not nums:
                return -1
            left, right = 0, len(nums) - 1
            ans = -1
            while left <= right:
                mid = left + ((right - left) >> 1)
                if nums[mid] == target:
                    right = mid - 1
                    ans = mid
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    right = mid - 1
            return ans
        
        def right_bound(nums, target):
            if not nums:
                return -1
            left, right = 0, len(nums) - 1
            ans = -1
            while left <= right:
                mid = left + ((right - left) >> 1)
                if nums[mid] == target:
                    left = mid + 1
                    ans = mid
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    right = mid - 1
            return ans
        
        l, r = left_bound(nums, target), right_bound(nums, target)
        return [l, r]
```



## solution3 判断是否已经是第一个或者最后一个

-   solution2和3本质上是同样的思路

-   `nums[mid] == target`时如果确定搜索区间都搜完了，或者`nums[mid] != nums[mid-1]`，那么可以返回mid

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        res = []
        n = len(nums)
        l, r = 0, n - 1
        while l <= r:
            mid = l + ((r - l) >> 1)
            if nums[mid] == target and (mid == 0 or nums[mid] != nums[mid-1]):
                res.append(mid)
                break
            elif nums[mid] < target:
                l = mid + 1
            else:
                r = mid - 1
        if not res:
            return [-1, -1]
        
        l, r = res[0], n - 1
        while l <= r:
            mid = l + ((r - l) >> 1)
            if nums[mid] == target and (mid == n - 1 or nums[mid] != nums[mid+1]):
                res.append(mid)
                break
            elif nums[mid] > target:
                r = mid - 1
            else:
                l = mid + 1
        return res
```

>

# 35.搜索插入位置

[https://leetcode-cn.com/problems/search-insert-position](https://leetcode-cn.com/problems/search-insert-position) 

## 原题

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

 

 **示例 1:** 

```
输入: nums = [1,3,5,6], target = 5
输出: 2

```

 **示例 2:** 

```
输入: nums = [1,3,5,6], target = 2
输出: 1

```

 **示例 3:** 

```
输入: nums = [1,3,5,6], target = 7
输出: 4

```

 **示例 4:** 

```
输入: nums = [1,3,5,6], target = 0
输出: 0

```

 **示例 5:** 

```
输入: nums = [1], target = 0
输出: 0

```


 **提示:** 

-  `1 <= nums.length <= 10^4` 
-  `-10^4 <= nums[i] <= 10^4` 
-  `nums` 为 **无重复元素** 的 **升序** 排列数组
-  `-10^4 <= target <= 10^4` 

**标签**
`数组` `二分查找` 

## solution1 使用ans存储中间可能的位置

-   `nums[mid] > target`时，此时可能mid就是最后的答案，用`ans`保存下来
-   `nums[mid] < target`时，mid一定不是最后的答案

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        ans = len(nums)
        while l <= r:
            mid = l + ((r - l) >> 1)
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                r = mid - 1
                ans = mid
            else:
                l = mid + 1
        return ans
```



## solution2 分析left最终情况

根据if的判断条件，left左边的值一直保持小于target，right右边的值一直保持大于等于target，而且left最终一定等于right+1，这么一来，循环结束后，在left和right之间画一条竖线，恰好可以把数组分为两部分：left左边的部分和right右边的部分，而且left左边的部分全部小于target，并以right结尾；right右边的部分全部大于等于target，并以left为首。所以最终答案一定在left的位置。

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            mid = l + ((r - l) >> 1)
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                r = mid - 1
            else:
                l = mid + 1
        return l
```



## solution3 大雪菜模板

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums)
        while l < r:
            mid = l + r >> 1
            if nums[mid] >= target:
                r = mid
            else:
                l = mid + 1
        return l
```

>

# 69.x 的平方根 

[https://leetcode-cn.com/problems/sqrtx](https://leetcode-cn.com/problems/sqrtx) 

## 原题

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。** 

 **注意：** 不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

 

 **示例 1：** 

```
输入：x = 4
输出：2

```

 **示例 2：** 

```
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。

```


 **提示：** 

-  `0 <= x <= 2^31 - 1` 

**标签**
`数学` `二分查找` 

## solution

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x == 0:
            return 0
        l, r = 1, x
        while l <= r:
            mid = l + ((r - l) >> 1)
            mid_square = mid * mid
            if mid_square == x:
                return mid
            elif mid_square < x:
                if (mid + 1) * (mid + 1) > x:
                    return mid
                else:
                    l = mid + 1
            else:
                if (mid - 1) * (mid - 1) < x:
                    return mid - 1
                else:
                    r = mid - 1
        return l
```

>

# 74.搜索二维矩阵

[https://leetcode-cn.com/problems/search-a-2d-matrix](https://leetcode-cn.com/problems/search-a-2d-matrix) 

## 原题

编写一个高效的算法来判断  `m x n`  矩阵中，是否存在一个目标值。该矩阵具有如下特性：

- 每行中的整数从左到右按升序排列。
- 每行的第一个整数大于前一行的最后一个整数。


 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" style="width: 322px; height: 242px;" />

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true

```

 **示例 2：** 
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg" style="width: 322px; height: 242px;" />

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false

```


 **提示：** 

-  `m == matrix.length` 
-  `n == matrix[i].length` 
-  `1 <= m, n <= 100` 
-  `-10^4 <= matrix[i][j], target <= 10^4` 

**标签**
`数组` `二分查找` `矩阵` 

##

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        up, down = 0, len(matrix) - 1
        while up <= down:
            mid_row = up + ((down - up) >> 1)
            nums = matrix[mid_row]
            if nums[0] <= target <= nums[-1]:
                left, right = 0, len(matrix[0]) - 1
                while left <= right:
                    mid = left + ((right - left) >> 1)
                    if nums[mid] == target:
                        return True
                    elif nums[mid] > target:
                        right = mid - 1
                    else:
                        left = mid + 1
                return False
            elif nums[0] > target:
                down = mid_row - 1
            else:
                up = mid_row + 1
        return False
```

>

# 81.搜索旋转排序数组 II

[https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii) 

## 原题

已知存在一个按非降序排列的整数数组 `nums` ，数组中的值不必互不相同。

在传递给函数之前， `nums` 在预先未知的某个下标 `k` （ `0 <= k < nums.length` ）上进行了 **旋转** ，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` （下标 **从 0 开始** 计数）。例如， `[0,1,2,4,4,4,5,6,6,7]` 在下标 `5` 处经旋转后可能变为 `[4,5,6,6,7,0,1,2,4,4]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 `nums` 中存在这个目标值 `target` ，则返回 `true` ，否则返回 `false` 。

你必须尽可能减少整个操作步骤。

 

 **示例 1：** 

```
输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true

```

 **示例 2：** 

```
输入：nums = [2,5,6,0,0,1,2], target = 3
输出：false
```


 **提示：** 

-  `1 <= nums.length <= 5000` 
-  `-10^4 <= nums[i] <= 10^4` 
-  题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
-  `-10^4 <= target <= 10^4` 


 **进阶：** 

- 这是 <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/">搜索旋转排序数组</a> 的延伸题目，本题中的 `nums` 可能包含重复元素。
- 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？



**标签**
`数组` `二分查找` 

## solution

-   对于数组中有重复元素的情况，二分查找时可能会有 `nums[l] = nums[mid] = nums[r]`，此时无法判断区间`[l, mid]`和区间`[mid+1, r]`哪个是有序的。
-   例如`nums = [3,1,2,3,3,3,3], target = 2`，首次二分时无法判断区间`[0, 3]`和区间`[4, 6]`哪个是有序的。对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。

```python
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        n = len(nums)
        l, r = 0, n - 1
        while l <= r:
            mid = l + ((r - l) >> 1)
            if nums[mid] == target:
                return True
            if nums[l] == nums[mid] == nums[r]:
                l += 1
                r -= 1
            elif nums[l] <= nums[mid]:
                if nums[l] <= target < nums[mid]:
                    r = mid - 1
                else:
                    l = mid + 1
            else:  # target <= nums[r]
                if nums[mid] < target <= nums[r]:
                    l = mid + 1
                else:
                    r = mid - 1
        return False
```

>

# 153.寻找旋转排序数组中的最小值

[https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array) 

## 原题

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]` 
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]` 
    注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

 

 **示例 1：** 

```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。

```

 **示例 2：** 

```
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。

```

 **示例 3：** 

```
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。

```


 **提示：** 

-  `n == nums.length` 
-  `1 <= n <= 5000` 
-  `-5000 <= nums[i] <= 5000` 
-  `nums` 中的所有整数 **互不相同** 
-  `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转

**标签**
`数组` `二分查找` 

## solution

-   对于`[l, r - 1]`区间的数，要么大于`nums[r]`，要么小于`nums[r]`

    -   如果`nums[mid] > nums[r]`，说明`[l, mid]`是升序的，最小值在`[mid + 1, r]`

        <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0vhnv0o0yj21jk0pd0u5.jpg" alt="fig3" style="zoom:48%;" />

    -   如果`nums[mid] < nums[r]`，说明`[mid, r]`是升序的，最小值在`[l, mid]`

        <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0vhnn7hulj21jk0pdmyj.jpg" alt="fig2" style="zoom:48%;" />

    -   因为`nums`中数互不相同，因此只有上述两种情况

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l < r:
            mid = l + ((r - l) >> 1)
            if nums[mid] > nums[r]:
                l = mid + 1
            else:
                r = mid
        return nums[l]
```

>

>

# 154.寻找旋转排序数组中的最小值 II

[https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii) 

## 原题

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,4,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,4]` 
- 若旋转 `7` 次，则可以得到 `[0,1,4,4,5,6,7]` 
    注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个可能存在 **重复** 元素值的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

 

 **示例 1：** 

```
输入：nums = [1,3,5]
输出：1

```

 **示例 2：** 

```
输入：nums = [2,2,2,0,1]
输出：0

```


 **提示：** 

-  `n == nums.length` 
-  `1 <= n <= 5000` 
-  `-5000 <= nums[i] <= 5000` 
-  `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转


 **进阶：** 

- 这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/">寻找旋转排序数组中的最小值</a> 的延伸题目。
- 允许重复会影响算法的时间复杂度吗？会如何影响，为什么？

**标签**
`数组` `二分查找` 

## solution

对于`[l, r - 1]`区间的数，要么大于`nums[r]`，要么小于`nums[r]`，要么等于`nums[r]`

-   如果`nums[mid] > nums[r]`，说明`[l, mid]`是升序的，最小值在`[mid + 1, r]`
-   如果`nums[mid] < nums[r]`，说明`[mid, r]`是升序的，最小值在`[l, mid]`
-   如果`nums[mid] = nums[r]`，最小值可能在`[l, mid]`或者`[mid, r]`，无论`nums[r]`是不是最小值，都有一个它的替代品`nums[mid]`，因此可以忽略右端点

<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0upn0zr5qj21jk0pdwg0.jpg" alt="fig4" style="zoom:48%;" />

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l < r:
            mid = l + ((r - l) >> 1)
            if nums[mid] > nums[r]:
                l = mid + 1
            elif nums[mid] < nums[r]:
                r = mid
            else:
                r -= 1
        return nums[l]
```

>

# 162.寻找峰值

[https://leetcode-cn.com/problems/find-peak-element](https://leetcode-cn.com/problems/find-peak-element) 

## 原题

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums` ，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。

 

 **示例 1：** 

```
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
```

 **示例 2：** 

```
输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。

```


 **提示：** 

-  `1 <= nums.length <= 1000` 
-  `-2^31 <= nums[i] <= 2^31 - 1` 
-  对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]` 

**标签**
`数组` `二分查找` 

## solution

-   mid和左边的mid-1，右边的mid+1，组成的趋势有四种情况
    -   上升：`nums[mid - 1] < nums[mid] < nums[mid + 1]`，搜索区间更新为`[mid + 1, r]`
    -   下降：`nums[mid - 1] > nums[mid] > nums[mid + 1]`，搜索区间更新为`[l, mid - 1]`
    -   峰：`nums[mid - 1] < nums[mid] > nums[mid + 1]`，找到一个可行解
    -   谷：`nums[mid - 1] > nums[mid] < nums[mid + 1]`，搜索区间可以更新为`[mid + 1, r]`，也可以更新为`[l, mid - 1]`
    -   想找峰值就往相对于当前mid位置高的地方移动

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        def get_val(i):
            if i == -1 or i == n:
                return float('-inf')
            return nums[i]
        
        n = len(nums)
        l, r = 0, n - 1
        while l <= r:
            mid = l + ((r - l) >> 1)
            if get_val(mid - 1) < nums[mid] > get_val(mid + 1):
                return mid
            elif nums[mid] < get_val(mid + 1):
                l = mid + 1
            else:
                r = mid - 1
        return -1
```

>

# 167.两数之和 II - 输入有序数组

[https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted) 

## 原题

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index<sub>1</sub>]` 和 `numbers[index<sub>2</sub>]` ，则 `1 <= index<sub>1</sub> < index<sub>2</sub> <= numbers.length` 。

以长度为 2 的整数数组 `[index<sub>1</sub>, index<sub>2</sub>]` 的形式返回这两个整数的下标 `index<sub>1</sub>` 和 `index<sub>2</sub>` 。

你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。


 **示例 1：** 

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

 **示例 2：** 

```
输入：numbers = [2,3,4], target = 6
输出：[1,3]
解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。
```

 **示例 3：** 

```
输入：numbers = [-1,0], target = -1
输出：[1,2]
解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。

```


 **提示：** 

-  `2 <= numbers.length <= 3 * 10^4` 
-  `-1000 <= numbers[i] <= 1000` 
-  `numbers` 按 **非递减顺序** 排列
-  `-1000 <= target <= 1000` 
-  **仅存在一个有效答案** 

**标签**
`数组` `双指针` `二分查找` 

## solution

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        i, j = 0, len(numbers) - 1
        while i <= j:
            if numbers[i] + numbers[j] == target:
                return [i+1, j+1]
            elif numbers[i] + numbers[j] > target:
                j -= 1
            else:
                i += 1
        return [-1, -1]
```

>

# 209.长度最小的子数组

[https://leetcode-cn.com/problems/minimum-size-subarray-sum](https://leetcode-cn.com/problems/minimum-size-subarray-sum) 

## 原题

给定一个含有  `n` ** ** 个正整数的数组和一个正整数 `target` **。** 

找出该数组中满足其和 **** `≥ target` **** 的长度最小的 **连续子数组**   `[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]` ，并返回其长度 **。** 如果不存在符合条件的子数组，返回 `0` 。

 

 **示例 1：** 

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

```

 **示例 2：** 

```
输入：target = 4, nums = [1,4,4]
输出：1

```

 **示例 3：** 

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0

```


 **提示：** 

-  `1 <= target <= 10^9` 
-  `1 <= nums.length <= 10^5` 
-  `1 <= nums[i] <= 10^5` 


 **进阶：** 

- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。

**标签**
`数组` `二分查找` `前缀和` `滑动窗口` 

## solution1 滑动窗口 O(n)

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        res = float('inf')
        cur_sum, start, end, n = 0, 0, 0, len(nums)
        while end < n:
            cur_sum += nums[end]
            while cur_sum >= target:
                res = min(res, end - start + 1)
                cur_sum -= nums[start]
                start += 1
            end += 1
        return res if res < float('inf') else 0
```

## solution1.x 滑动窗口 不要用window 要用start/end

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        res = float('inf')
        cur_sum, cur_window = 0, []
        i, n = 0, len(nums)
        while i < n:
            while i < n and cur_sum < target:
                cur_sum += nums[i]
                cur_window.append(i)
                i += 1
            if cur_sum < target:
                break
            while cur_window and cur_sum - nums[cur_window[0]] >= target:
                cur_sum -= nums[cur_window[0]]
                cur_window = cur_window[1:]
            res = min(res, len(cur_window))
            if cur_window:
                cur_sum -= nums[cur_window[0]]
                cur_window = cur_window[1:]
        return res if res < float('inf') else 0
```



## solution2 前缀和+二分 O(nlog(n))

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        res = float('inf')
        n = len(nums)
        sums = [0] * (n + 1)
        for i in range(n):
            sums[i + 1] = sums[i] + nums[i]
        for i in range(1, n + 1):
            # 以i为start，在i ~ n中寻找end，在[start, n]之间寻找第一个区间和大于等于target的end
            
            l, r = 0, n
            while l < r:
                mid = l + ((r - l) >> 1)
                if sums[mid] - sums[i-1] < target:
                    l = mid + 1
                else:
                    r = mid
            if sums[l] - sums[i-1] >= target:
                res = min(res, l - (i - 1))
        return res if res < float('inf') else 0
```

>

# 240.搜索二维矩阵 II

[https://leetcode-cn.com/problems/search-a-2d-matrix-ii](https://leetcode-cn.com/problems/search-a-2d-matrix-ii) 

## 原题

编写一个高效的算法来搜索 ` *m* x *n* ` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。


<b>示例 1：</b>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" />

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true

```

<b>示例 2：</b>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg" />

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false

```


 **提示：** 

-  `m == matrix.length` 
-  `n == matrix[i].length` 
-  `1 <= n, m <= 300` 
-  `-10^9 <= matrix[i][j] <= 10^9` 
-  每行的所有元素从左到右升序排列
-  每列的所有元素从上到下升序排列
-  `-10^9 <= target <= 10^9` 

**标签**
`数组` `二分查找` `分治` `矩阵` 

## solution

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m, n = len(matrix), len(matrix[0])
        i, j = m-1, 0
        while i >= 0 and j < n:
            if matrix[i][j] == target:
                return True
            elif matrix[i][j] > target:
                i -= 1
            else:
                j += 1
        return False
```

>

# 274.H 指数

[https://leetcode-cn.com/problems/h-index](https://leetcode-cn.com/problems/h-index) 

## 原题

给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 ** `h` 指数** 。

根据维基百科上 <a href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin" target="_blank">h 指数的定义</a>：h 代表“高引用次数”，一名科研人员的 `h` **指数** 是指他（她）的 （ `n` 篇论文中） **总共** 有 `h` 篇论文分别被引用了 **至少** `h` 次。且其余的 *`n - h`* 篇论文每篇被引用次数 **不超过** *`h`* 次。

如果 `h` 有多种可能的值， ** `h` 指数** 是其中最大的那个。

 

 **示例 1：** 

```
输入：citations = [3,0,6,1,5]
输出：3 
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。
```

 **示例 2：** 

```
输入：citations = [1,3,1]
输出：1

```


 **提示：** 

-  `n == citations.length` 
-  `1 <= n <= 5000` 
-  `0 <= citations[i] <= 1000` 

**标签**
`数组` `计数排序` `排序` 

## solution1 直接使用sort，O(nlogn)

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        citations.sort(reverse=True)
        res = 0
        for i in range(n):
            if citations[i] >= i + 1:
                res = i + 1
            else:
                break
        return res
```



## soluton2 二分，O(nlogn)

-   https://leetcode-cn.com/problems/h-index/solution/gong-shui-san-xie-li-yong-er-duan-xing-z-1jxw/
-   hIndex只可能在`[0, n]`的范围内，其中`n`是发表论文的总篇数，即`len(citations)`
-   问题转为在`[0, n]`的范围内找一个最大的数`i`，且满足有`i`篇论文至少引用了`i`次

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        def check(mid):
            ans = 0
            for c in citations:
                ans += c >= mid
            return ans >= mid

        n = len(citations)
        l, r = 0, n
        while l < r:
            mid = l + r + 1 >> 1
            if check(mid):
                l = mid
            else:
                r = mid - 1
        return l
```



## solution3 计数排序，O(n)

-   `counter`记录当前引用次数的论文有几篇
-   从后向前遍历数组 `counter`，得到大于或等于当前引用次数`i`的总论文数`res`，如果`res >= i`，表示有超过`i`篇论文大于或等于引用次数`i`，直接返回即可。

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        counter = [0] * (n + 1)
        for c in citations:
            if c >= n:
                counter[n] += 1
            else:
                counter[c] += 1
        
        res = 0
        for i in range(n, -1, -1):
            res += counter[i]
            if res >= i:
                return i
        return 0
```

>

# 275.H 指数 II

[https://leetcode-cn.com/problems/h-index-ii](https://leetcode-cn.com/problems/h-index-ii) 

## 原题

给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数， `citations` 已经按照  **升序排列 ** 。计算并返回该研究者的 ** `h` * * 指数** 。

<a href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin" target="_blank">h 指数的定义</a>：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （ `n` 篇论文中） **总共** 有 `h` 篇论文分别被引用了 **至少** `h` 次。且其余的 *`n - h`  * 篇论文每篇被引用次数  **不超过** *`h`* 次。

 **提示：** 如果 `h` 有多种可能的值， ** `h` 指数** 是其中最大的那个。

请你设计并实现对数时间复杂度的算法解决此问题。

 

 **示例 1：** 

```
输入：citations = [0,1,3,5,6]
输出：3 
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。
     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3 。
```

 **示例 2：** 

```
输入：citations = [1,2,100]
输出：2

```


 **提示：** 

-  `n == citations.length` 
-  `1 <= n <= 10^5` 
-  `0 <= citations[i] <= 1000` 
-  `citations` 按 **升序排列** 

**标签**
`数组` `二分查找` 

https://leetcode-cn.com/problems/h-index-ii/solution/by-umbrella-3t-qleu/

## solution1 从大到小

-   反转citations
-   mid及其左边一共有mid+1篇论文
-   引用数是递减的，因此引用数超过citations[mid]的论文一共有mid+1篇
-   如果citations[mid] >= mid+1，那么引用数超过mid+1的论文一共有mid+1篇
    -   此时找到的hIndex为mid+1，我们想找更大的hIndex，即想找更大的`i+1`
    -   应该到`[mid, r]`范围内找这样的`i`，因此设置`l = mid`
-   否则`mid`不是一个可行解，因此设置`r = mid - 1`

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        citations = citations[::-1]
        n = len(citations)
        l, r = 0, n - 1
        while l < r:
            mid = l + r + 1 >> 1
            if citations[mid] >= mid+1:
                l = mid
            else:
                r = mid - 1
        return r+1 if citations[r] >= r+1 else 0
```



## solution2 从小到大

-   mid及其右边一共有n-mid篇论文
-   引用数是递增的，因此引用数超过citations[mid]的论文一共有n-mid篇
-   如果citations[mid] >= n-mid，那么引用数超过n-mid的论文一共有n-mid篇
    -   此时找到的hIndex为n-mid，我们想找更大的hIndex，即想找更大的`n-i`
    -   应该到`[l, mid]`范围内找这样的`i`，因此设置`r = mid`
-   否则`mid`不是一个可行解，因此设置`l = mid + 1`

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        l, r = 0, n - 1
        while l < r:
            mid = l + r >> 1
            if citations[mid] >= n-mid:
                r = mid
            else:
                l = mid + 1
        return n-r if citations[r] >= n-r else 0
```

>

# 278.第一个错误的版本

[https://leetcode-cn.com/problems/first-bad-version](https://leetcode-cn.com/problems/first-bad-version) 

## 原题

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 `n` 个版本 `[1, 2, ..., n]` ，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用  `bool isBadVersion(version)`  接口来判断版本号 `version` 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。


 **示例 1：** 

```
输入：n = 5, bad = 4
输出：4
解释：
调用 isBadVersion(3) -> false 
调用 isBadVersion(5) -> true 
调用 isBadVersion(4) -> true
所以，4 是第一个错误的版本。

```

 **示例 2：** 

```
输入：n = 1, bad = 1
输出：1

```


 **提示：** 

-  `1 <= bad <= n <= 2^31 - 1` 

**标签**
`二分查找` `交互` 

## solution

```python
class Solution:
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """
        l, r = 1, n
        while l <= r:
            mid = l + ((r - l) >> 1)
            if isBadVersion(mid) and (mid == 1 or not isBadVersion(mid-1)):
                return mid
            elif not isBadVersion(mid):
                l = mid + 1
            else:
                r = mid - 1
        return -1
```

>

# 287.寻找重复数

[https://leetcode-cn.com/problems/find-the-duplicate-number](https://leetcode-cn.com/problems/find-the-duplicate-number) 

## 原题

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n` ），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

 

 **示例 1：** 

```
输入：nums = [1,3,4,2,2]
输出：2

```

 **示例 2：** 

```
输入：nums = [3,1,3,4,2]
输出：3

```


 **提示：** 

-  `1 <= n <= 10^5` 
-  `nums.length == n + 1` 
-  `1 <= nums[i] <= n` 
-  `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次** 


<b>进阶：</b>

- 如何证明 `nums` 中至少存在一个重复的数字?
- 你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？

**标签**
`位运算` `数组` `双指针` `二分查找` 

## solution1 二分查找 

时间复杂度`O(nlogn)`空间复杂度`O(1)`

-   https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/

-   本质是使用二分在`[1, n]`中找到一个数
-   如果在`[1, mid]`之间有超过mid个数小于等于mid，则这个重复的数一定在`[1, mid] `；反之，加入有小于mid个数 小于等于mid，说明在`[mid + 1, n]`一定存在超过`n - mid`个数，因此必然有重复的数

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        n = len(nums) - 1
        l, r = 1, n
        while l < r:
            mid = l + ((r - l) >> 1)
            cnt = 0
            for i in nums:
                cnt += i <= mid
            if cnt <= mid:
                l = mid + 1
            else:
                r = mid
        return l
```



## solution2 链表快慢指针找环的入口

-   https://leetcode-cn.com/problems/find-the-duplicate-number/solution/287xun-zhao-zhong-fu-shu-by-kirsche/
-   索引和数之间建立映射，n -> nums[n]，形成链表
-   如果有重复数，那么多个索引会指向同一个数，形成链表中的环，环的入口就是重复的数

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow, fast = 0, 0
        slow, fast = nums[slow], nums[nums[fast]]
        while slow != fast:
            slow = nums[slow]
            fast = nums[nums[fast]]
        cur = 0
        while slow != cur:
            slow = nums[slow]
            cur = nums[cur]
        return slow
```

>

# 300.最长递增子序列

[https://leetcode-cn.com/problems/longest-increasing-subsequence](https://leetcode-cn.com/problems/longest-increasing-subsequence) 

## 原题

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

 **子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如， `[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。


 **示例 1：** 

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

```

 **示例 2：** 

```
输入：nums = [0,1,0,3,2,3]
输出：4

```

 **示例 3：** 

```
输入：nums = [7,7,7,7,7,7,7]
输出：1

```


 **提示：** 

-  `1 <= nums.length <= 2500` 
-  `-10^4 <= nums[i] <= 10^4` 


<b>进阶：</b>

- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

**标签**
`数组` `二分查找` `动态规划` 

## solution1 dp

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1] * n
        for i in range(n):
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

## solution2 贪心+二分

-   考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。
-   具体实现过程，遍历`nums`
    -   `cells`中维护一个严格单调递增的序列
    -   如果当前的`nums[i] > cells[-1]`，说明当前的`nums[i]`比`cells`中的所有数都大，直接加入`cells`
    -   如果当前的`nums[i] <= cells[-1]`，需要在当前的`cells`中找一个数，这个数等于`nums[i]`，或者是第一个比`nums[i]`的数，使用`nums[i]`替换这个数

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        def findFirstBiggerOrEqualNumber(cells, target):
            l, r = 0, len(cells)-1
            while l < r:
                mid = l + ((r - l) >> 1)
                if cells[mid] < target:
                    l = mid + 1
                else:
                    r = mid
            return l

        n = len(nums)
        cells = []
        for i in range(n):
            if not cells or cells[-1] < nums[i]:
                cells.append(nums[i])
            else:
                idx = findFirstBiggerOrEqualNumber(cells, nums[i])
                cells[idx] = nums[i]
        return len(cells)
```

>

# 349.两个数组的交集

[https://leetcode-cn.com/problems/intersection-of-two-arrays](https://leetcode-cn.com/problems/intersection-of-two-arrays) 

## 原题

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

 

 **示例 1：** 

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]

```

 **示例 2：** 

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的

```


 **提示：** 

-  `1 <= nums1.length, nums2.length <= 1000` 
-  `0 <= nums1[i], nums2[i] <= 1000` 

**标签**
`数组` `哈希表` `双指针` `二分查找` `排序` 

## solution1 库函数

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        return list(set(nums1) & set(nums2))
```

## solution2 哈希

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1_set = set(nums1)
        res = []
        for n in nums2:
            if n in nums1_set:
                res.append(n)
                nums1_set.remove(n)
        return res
```

## solution3 排序+二分

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        def find_target(nums, target):
            length = len(nums)
            l, r = 0, length -1
            while l <= r:
                mid = l + ((r - l) >> 1)
                if nums[mid] == target:
                    return mid
                elif nums[mid] < target:
                    l = mid + 1
                else:
                    r = mid - 1
            return -1
        
        nums1.sort()
        nums2.sort()
        res = []
        for i, n in enumerate(nums1):
            if i > 0 and nums1[i] == nums1[i-1]:
                continue
            idx = find_target(nums2, n)
            if idx != -1:
                res.append(n)
        return res
```

## solution4 排序+双指针

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1.sort()
        nums2.sort()
        m, n = len(nums1), len(nums2)
        i, j = 0, 0
        res = []
        while i < m and j < n:
            n1 = nums1[i] if i < m else float('inf')
            n2 = nums2[j] if j < n else float('inf')
            if n1 == n2:
                if not res or res[-1] != nums1[i]:
                    res.append(nums1[i])
                i += 1
                j += 1
            elif n1 > n2:
                j += 1
            else:
                i += 1
        return res
```

>

# 350.两个数组的交集 II

[https://leetcode-cn.com/problems/intersection-of-two-arrays-ii](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii) 

## 原题

给你两个整数数组 `nums1` 和 `nums2` ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

 

 **示例 1：** 

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]

```

 **示例 2:** 

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```


 **提示：** 

-  `1 <= nums1.length, nums2.length <= 1000` 
-  `0 <= nums1[i], nums2[i] <= 1000` 


 ** **进阶** ：** 

- 如果给定的数组已经排好序呢？你将如何优化你的算法？
- 如果 `nums1` 的大小比 `nums2` 小，哪种方法更优？
- 如果 `nums2` 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

**标签**
`数组` `哈希表` `双指针` `二分查找` `排序` 

## solution1 哈希

```python
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1_dict = Counter(nums1)
        res = []
        for n in nums2:
            if n in nums1_dict:
                res.append(n)
                nums1_dict[n] -= 1
                if nums1_dict[n] == 0:
                    del nums1_dict[n]
        return res
```

## solution2 排序+双指针

```python
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1.sort()
        nums2.sort()
        m, n = len(nums1), len(nums2)
        i, j = 0, 0
        res = []
        while i < m and j < n:
            n1 = nums1[i] if i < m else float('inf')
            n2 = nums2[j] if j < n else float('inf')
            if n1 == n2:
                res.append(nums1[i])
                i += 1
                j += 1
            elif n1 > n2:
                j += 1
            else:
                i += 1
        return res
```

## solution3 排序+双指针+二分

```python
过于生硬，不够优雅
```

>   

# 374.猜数字大小

[https://leetcode-cn.com/problems/guess-number-higher-or-lower](https://leetcode-cn.com/problems/guess-number-higher-or-lower) 

## 原题

猜数字游戏的规则如下：

- 每轮游戏，我都会从  **1**  到  ***n*** 随机选择一个数字。 请你猜选出的是哪个数字。
- 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。
    你可以通过调用一个预先定义好的接口 `int guess(int num)` 来获取猜测结果，返回值一共有 3 种可能的情况（ `-1` ， `1`  或 `0` ）：
- -1：我选出的数字比你猜的数字小 `pick < num` 
- 1：我选出的数字比你猜的数字大 `pick > num` 
- 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！ `pick == num` 
    返回我选出的数字。

 

 **示例 1：** 

```
输入：n = 10, pick = 6
输出：6

```

 **示例 2：** 

```
输入：n = 1, pick = 1
输出：1

```

 **示例 3：** 

```
输入：n = 2, pick = 1
输出：1

```

 **示例 4：** 

```
输入：n = 2, pick = 2
输出：2

```


 **提示：** 

-  `1 <= n <= 2^31 - 1` 
-  `1 <= pick <= n` 

**标签**
`二分查找` `交互` 


##

```python
class Solution:
    def guessNumber(self, n: int) -> int:
        l, r = 1, n
        while l <= r:
            mid = l + ((r - l) >> 1)
            cur = guess(mid)
            if cur == 0:
                return mid
            elif cur == 1:
                l = mid + 1
            else:
                r = mid - 1
        return l
```

>

# 400.第 N 位数字

[https://leetcode-cn.com/problems/nth-digit](https://leetcode-cn.com/problems/nth-digit) 

## 原题

给你一个整数 `n` ，请你在无限的整数序列 `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]` 中找出并返回第 `n` 位上的数字。

 

 **示例 1：** 

```
输入：n = 3
输出：3

```

 **示例 2：** 

```
输入：n = 11
输出：0
解释：第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是 0 ，它是 10 的一部分。

```


 **提示：** 

-  `1 <= n <= 2^31 - 1` 

**标签**
`数学` `二分查找` 

## solution

https://leetcode-cn.com/problems/nth-digit/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-w5wl/

-   首先确定第n个数是几位数中的
    -   len位数的数字范围为[10<sup>len-1</sup>, 10<sup>len</sup>-1]，长度为len * 9 * 10 <sup>len-1</sup>
    -   不断减小n，且增加len，直到n <= len * 9 * 10 <sup>len-1</sup>
-   接着确定n是len位数中的第几个
    -   第1个数到第len个数都在len位数中的第一个，都等于10 <sup>len-1</sup> + 0
    -   第len个数到第2*len个数都在len位数中的第二个，都等于10 <sup>len-1</sup> + 1
-   最后确定n是len位数num中的第几位
    -   在len位数中的第n个数是 len位数num中的 第idx位
        -   如果n % len_ == 0，那么就是最后一位
        -   否则是 n % len_ - 1位
    -   可以合并为n % len_ - 1，因为如果n % len_ == 0， 那么取str(num)[-1]，即最后一位

```python
class Solution:
    def findNthDigit(self, n: int) -> int:
        len_, base = 1, 1
        while n > len_ * 9 * base:
            n -= len_ * 9 * base
            len_ += 1
            base *= 10
        num = base + (n - 1) // len_
        idx = n % len_ - 1 if n % len_ != 0 else len_ - 1
        return int(str(num)[idx])
      
        # return int(str(num)[n % len_ - 1])
        
```

>

# 410.分割数组的最大值

[https://leetcode-cn.com/problems/split-array-largest-sum](https://leetcode-cn.com/problems/split-array-largest-sum) 

## 原题

给定一个非负整数数组 `nums` 和一个整数 `m` ，你需要将这个数组分成 `m` 个非空的连续子数组。

设计一个算法使得这 `m` 个子数组各自和的最大值最小。

 

 **示例 1：** 

```
输入：nums = [7,2,5,10,8], m = 2
输出：18
解释：
一共有四种方法将 nums 分割为 2 个子数组。 
其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。
```

 **示例 2：** 

```
输入：nums = [1,2,3,4,5], m = 2
输出：9

```

 **示例 3：** 

```
输入：nums = [1,4,4], m = 3
输出：4

```


 **提示：** 

-  `1 <= nums.length <= 1000` 
-  `0 <= nums[i] <= 10^6` 
-  `1 <= m <= min(50, nums.length)` 

**标签**
`贪心` `数组` `二分查找` `动态规划` 


##

```python

```

>

# 436.寻找右区间

[https://leetcode-cn.com/problems/find-right-interval](https://leetcode-cn.com/problems/find-right-interval) 

## 原题

给你一个区间数组 `intervals` ，其中 `intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]` ，且每个 `start<sub>i</sub>` 都 **不同** 。

区间 `i` 的 **右侧区间** 可以记作区间 `j` ，并满足 `start<sub>j</sub>` `>= end<sub>i</sub>` ，且 `start<sub>j</sub>` **最小化** 。

返回一个由每个区间 `i` 的 **右侧区间** 的最小起始位置组成的数组。如果某个区间 `i` 不存在对应的 **右侧区间** ，则下标 `i` 处的值设为 `-1` 。


 **示例 1：** 

```
输入：intervals = [[1,2]]
输出：[-1]
解释：集合中只有一个区间，所以输出-1。

```

 **示例 2：** 

```
输入：intervals = [[3,4],[2,3],[1,2]]
输出：[-1,0,1]
解释：对于 [3,4] ，没有满足条件的“右侧”区间。
对于 [2,3] ，区间[3,4]具有最小的“右”起点;
对于 [1,2] ，区间[2,3]具有最小的“右”起点。

```

 **示例 3：** 

```
输入：intervals = [[1,4],[2,3],[3,4]]
输出：[-1,2,-1]
解释：对于区间 [1,4] 和 [3,4] ，没有满足条件的“右侧”区间。
对于 [2,3] ，区间 [3,4] 有最小的“右”起点。

```


 **提示：** 

-  `1 <= intervals.length <= 2 * 10^4` 
-  `intervals[i].length == 2` 
-  `-10^6 <= start<sub>i</sub> <= end<sub>i</sub> <= 10^6` 
-  每个间隔的起点都 **不相同** 

**标签**
`数组` `二分查找` `排序` 

## solution

-    `intervals`对左端点排序得到`sorted_intervals`
-   在`sorted_intervals`所有区间左端点中找到满足条件的最小值
    -   如果左端点小于right，那么应该在`[mid + 1, r]`之间找
    -   否则在`[l, mid]`之间找

```python
class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:
        intervals = [tuple(interval) for interval in intervals]

        d = {}
        for i, interval in enumerate(intervals):
            d[interval] = i
        
        sorted_intervals = sorted(intervals, key=lambda x: x[0])

        res = []
        for left, right in intervals:
            l, r = 0, len(sorted_intervals) - 1
            while l < r:
                mid = l + r >> 1
                if sorted_intervals[mid][0] < right:
                    l = mid + 1
                else:
                    r = mid
            if sorted_intervals[r][0] >= right:
                res.append(d[sorted_intervals[r]])
            else:
                res.append(-1)
        return res
```

>

# 475.供暖器

[https://leetcode-cn.com/problems/heaters](https://leetcode-cn.com/problems/heaters) 

## 原题

冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。

在加热器的加热半径范围内的每个房屋都可以获得供暖。

现在，给出位于一条水平线上的房屋  `houses` 和供暖器  `heaters` 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。

 **说明** ：所有供暖器都遵循你的半径标准，加热的半径也一样。

 

 **示例 1:** 

```
输入: houses = [1,2,3], heaters = [2]
输出: 1
解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。

```

 **示例 2:** 

```
输入: houses = [1,2,3,4], heaters = [1,4]
输出: 1
解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。

```

 **示例 3：** 

```
输入：houses = [1,5], heaters = [2]
输出：3

```


 **提示：** 

-  `1 <= houses.length, heaters.length <= 3 * 10^4` 
-  `1 <= houses[i], heaters[i] <= 10^9` 

**标签**
`数组` `双指针` `二分查找` `排序` 

## solution 为每个house找到离它最近的热水器

-   为每个house找到离它最近的热水器
    -   找到左边第一个热水器
    -   找到右边第一个热水器
    -   二者取min
-   结果是所有house最近热水器距离的最大值

```python
class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        def find_min_bigger_equal(heaters, house):
            l, r = 0, len(heaters) - 1
            while l < r:
                mid = l + r >> 1
                if heaters[mid] >= house:
                    r = mid
                else:
                    l = mid + 1
            return r if heaters[r] >= house else -1
        
        def find_max_smaller_equal(heaters, house):
            l, r = 0, len(heaters) - 1
            while l < r:
                mid = l + r + 1 >> 1
                if heaters[mid] <= house:
                    l = mid
                else:
                    r = mid - 1
            return r if heaters[r] <= house else -1

        heaters.sort()
        min_radius = float('-inf')
        for house in houses:
            right = find_min_bigger_equal(heaters, house)
            left = find_max_smaller_equal(heaters, house)
            if left == -1:
                min_radius = max(min_radius, heaters[right] - house)
            elif right == -1:
                min_radius = max(min_radius, house - heaters[left])
            else:
                min_radius = max(min_radius, min(house - heaters[left], heaters[right] - house))
        return min_radius
```

>

# 528.按权重随机选择

[https://leetcode-cn.com/problems/random-pick-with-weight](https://leetcode-cn.com/problems/random-pick-with-weight) 

## 原题

给你一个 **下标从 0 开始** 的正整数数组 `w` ，其中 `w[i]` 代表第 `i` 个下标的权重。

请你实现一个函数 `pickIndex` ，它可以 **随机地** 从范围 `[0, w.length - 1]` 内（含 `0` 和 `w.length - 1` ）选出并返回一个下标。选取下标 `i` 的 **概率** 为 `w[i] / sum(w)` 。

- 例如，对于 `w = [1, 3]` ，挑选下标 `0` 的概率为 `1 / (1 + 3) = 0.25` （即，25%），而选取下标 `1` 的概率为 `3 / (1 + 3) = 0.75` （即， `75%` ）。


 **示例 1：** 

```
输入：
["Solution","pickIndex"]
[[[1]],[]]
输出：
[null,0]
解释：
Solution solution = new Solution([1]);
solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。
```

 **示例 2：** 

```
输入：
["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
[[[1,3]],[],[],[],[],[]]
输出：
[null,1,1,1,1,0]
解释：
Solution solution = new Solution([1, 3]);
solution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。
solution.pickIndex(); // 返回 1
solution.pickIndex(); // 返回 1
solution.pickIndex(); // 返回 1
solution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。

由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:
[null,1,1,1,1,0]
[null,1,1,1,1,1]
[null,1,1,1,0,0]
[null,1,1,1,0,1]
[null,1,0,1,0,0]
......
诸若此类。

```


 **提示：** 

-  `1 <= w.length <= 10^4` 
-  `1 <= w[i] <= 10^5` 
-  `pickIndex` 将被调用不超过 `10^4` 次

**标签**
`数学` `二分查找` `前缀和` `随机化` 


##

```python

```

>

# 540.有序数组中的单一元素

[https://leetcode-cn.com/problems/single-element-in-a-sorted-array](https://leetcode-cn.com/problems/single-element-in-a-sorted-array) 

## 原题

给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

你设计的解决方案必须满足 `O(log n)` 时间复杂度和 `O(1)` 空间复杂度。

 

 **示例 1:** 

```
输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2

```

 **示例 2:** 

```
输入: nums =  [3,3,7,7,10,11,11]
输出: 10

```


<meta charset="UTF-8" />

 **提示:** 

-  `1 <= nums.length <= 10^5` 
-  `0 <= nums[i] <= 10^5` 

**标签**
`数组` `二分查找` 


##

```python

```

>

# 611.有效三角形的个数

[https://leetcode-cn.com/problems/valid-triangle-number](https://leetcode-cn.com/problems/valid-triangle-number) 

## 原题

给定一个包含非负整数的数组 `nums` ，返回其中可以组成三角形三条边的三元组个数。

 

 **示例 1:** 

```
输入: nums = [2,2,3,4]
输出: 3
解释:有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3

```

 **示例 2:** 

```
输入: nums = [4,2,3,4]
输出: 4
```


 **提示:** 

-  `1 <= nums.length <= 1000` 
-  `0 <= nums[i] <= 1000` 

**标签**
`贪心` `数组` `双指针` `二分查找` `排序` 


##

```python

```

>

# 658.找到 K 个最接近的元素

[https://leetcode-cn.com/problems/find-k-closest-elements](https://leetcode-cn.com/problems/find-k-closest-elements) 

## 原题

给定一个 **排序好** 的数组 `arr` ，两个整数 `k` 和 `x` ，从数组中找到最靠近 `x` （两数之差最小）的 `k` 个数。返回的结果必须要是按升序排好的。

整数 `a` 比整数 `b` 更接近 `x` 需要满足：

-  `|a - x| < |b - x|` 或者
-  `|a - x| == |b - x|` 且 `a < b` 


 **示例 1：** 

```
输入：arr = [1,2,3,4,5], k = 4, x = 3
输出：[1,2,3,4]

```

 **示例 2：** 

```
输入：arr = [1,2,3,4,5], k = 4, x = -1
输出：[1,2,3,4]

```


 **提示：** 

-  `1 <= k <= arr.length` 
-  `1 <= arr.length <= 10^4` <meta charset="UTF-8" />
-  `arr` 按 **升序** 排列
-  `-10^4 <= arr[i], x <= 10^4` 

**标签**
`数组` `双指针` `二分查找` `排序` `堆（优先队列）` 


##

```python

```

>

# 704.二分查找

[https://leetcode-cn.com/problems/binary-search](https://leetcode-cn.com/problems/binary-search) 

## 原题

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target` ，如果目标值存在返回下标，否则返回 `-1` 。

<br>
 **示例 1:** 

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

```

 **示例 2:** 

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1

```


 **提示：** 

- 你可以假设 `nums` 中的所有元素是不重复的。
- `n` 将在 `[1, 10000]` 之间。
- `nums` 的每个元素都将在 `[-9999, 9999]` 之间。

**标签**
`数组` `二分查找` 


##

```python

```

>

# 718.最长重复子数组

[https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray) 

## 原题

给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。

 

 **示例 1：** 

```
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。

```

 **示例 2：** 

```
输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
输出：5

```


 **提示：** 

-  `1 <= nums1.length, nums2.length <= 1000` 
-  `0 <= nums1[i], nums2[i] <= 100` 

**标签**
`数组` `二分查找` `动态规划` `滑动窗口` `哈希函数` `滚动哈希` 


##

```python

```

>

# 719.找出第 k 小的距离对

[https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance) 

## 原题

给定一个整数数组，返回所有数对之间的第 k 个最小 **距离** 。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。

 **示例 1:** 

```
输入：
nums = [1,3,1]
k = 1
输出：0 
解释：
所有数对如下：
(1,3) -> 2
(1,1) -> 0
(3,1) -> 2
因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。

```

 **提示:** 

-  `2 <= len(nums) <= 10000` .
-  `0 <= nums[i] < 1000000` .
-  `1 <= k <= len(nums) * (len(nums) - 1) / 2` .

**标签**
`数组` `双指针` `二分查找` `排序` 

## solution

```python
class Solution:
    def smallestDistancePair(self, nums: List[int], k: int) -> int:
        def possible(mid):
            cnt = 0
            left = 0
            for right, num in enumerate(nums):
                while num - nums[left] > mid:
                    left += 1
                cnt += right - left
            return cnt >= k

        n = len(nums)
        nums.sort()
        l, r = 0, nums[-1] - nums[0]
        # 在最小距离和最大距离之间猜测一个距离D，距离小于等于D的距离数目 大于等于 k
        
        while l < r:
            mid = l + r >> 1
            if possible(mid):
                r = mid
            else:
                l = mid + 1
        return r
```

>

# 852.山脉数组的峰顶索引

[https://leetcode-cn.com/problems/peak-index-in-a-mountain-array](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array) 

## 原题

符合下列属性的数组 `arr` 称为 **山脉数组** ：

-  `arr.length >= 3` 

- 存在 `i` （ `0 < i < arr.length - 1` ）使得：

-  `arr[0] < arr[1] < ... arr[i-1] < arr[i]` 

-  `arr[i] > arr[i+1] > ... > arr[arr.length - 1]` 

    

给你由整数组成的山脉数组 `arr` ，返回任何满足 `arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1]` 的下标 `i` 。

 

 **示例 1：** 

```
输入：arr = [0,1,0]
输出：1

```

 **示例 2：** 

```
输入：arr = [0,2,1,0]
输出：1

```

 **示例 3：** 

```
输入：arr = [0,10,5,2]
输出：1

```

 **示例 4：** 

```
输入：arr = [3,4,5,1]
输出：2

```

 **示例 5：** 

```
输入：arr = [24,69,100,99,79,78,67,36,26,19]
输出：2

```


 **提示：** 

-  `3 <= arr.length <= 10^4` 
-  `0 <= arr[i] <= 10^6` 
-  题目数据保证 `arr` 是一个山脉数组


 **进阶：** 很容易想到时间复杂度 `O(n)` 的解决方案，你可以设计一个 `O(log(n))` 的解决方案吗？


**标签**
`数组` `二分查找` 


##

```python

```

>

# 875.爱吃香蕉的珂珂

[https://leetcode-cn.com/problems/koko-eating-bananas](https://leetcode-cn.com/problems/koko-eating-bananas) 

## 原题

珂珂喜欢吃香蕉。这里有 `N` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉。警卫已经离开了，将在 `H` 小时后回来。

珂珂可以决定她吃香蕉的速度 `K` （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 `K` 根。如果这堆香蕉少于 `K` 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  

珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

返回她可以在 `H` 小时内吃掉所有香蕉的最小速度 `K` （ `K` 为整数）。


 **示例 1：** 

```
输入: piles = [3,6,7,11], H = 8
输出: 4

```

 **示例 2：** 

```
输入: piles = [30,11,23,4,20], H = 5
输出: 30

```

 **示例 3：** 

```
输入: piles = [30,11,23,4,20], H = 6
输出: 23

```


 **提示：** 

-  `1 <= piles.length <= 10^4` 
-  `piles.length <= H <= 10^9` 
-  `1 <= piles[i] <= 10^9` 

**标签**
`数组` `二分查找` 


##

```python

```

>

# 887.鸡蛋掉落

[https://leetcode-cn.com/problems/super-egg-drop](https://leetcode-cn.com/problems/super-egg-drop) 

## 原题

给你 `k` 枚相同的鸡蛋，并可以使用一栋从第 `1` 层到第 `n` 层共有 `n` 层楼的建筑。

已知存在楼层 `f` ，满足  `0 <= f <= n` ，任何从 **高于** `f` 的楼层落下的鸡蛋都会碎，从 `f` 楼层或比它低的楼层落下的鸡蛋都不会破。

每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 `x` 扔下（满足  `1 <= x <= n` ）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 **重复使用** 这枚鸡蛋。

请你计算并返回要确定 `f` **确切的值** 的 **最小操作次数** 是多少？


 **示例 1：** 

```
输入：k = 1, n = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 
如果它没碎，那么肯定能得出 f = 2 。 
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 

```

 **示例 2：** 

```
输入：k = 2, n = 6
输出：3

```

 **示例 3：** 

```
输入：k = 3, n = 14
输出：4

```


 **提示：** 

-  `1 <= k <= 100` 
-  `1 <= n <= 10^4` 

**标签**
`数学` `二分查找` `动态规划` 


##

```python

```

>

# 1011.在 D 天内送达包裹的能力

[https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days) 

## 原题

传送带上的包裹必须在 `days` 天内从一个港口运送到另一个港口。

传送带上的第 `i` 个包裹的重量为 `weights[i]` 。每一天，我们都会按给出重量（ `weights` ）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。

返回能在 `days` 天内将传送带上的所有包裹送达的船的最低运载能力。

 

 **示例 1：** 

```
输入：weights = [1,2,3,4,5,6,7,8,9,10], days = 5
输出：15
解释：
船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
第 1 天：1, 2, 3, 4, 5
第 2 天：6, 7
第 3 天：8
第 4 天：9
第 5 天：10

请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 

```

 **示例 2：** 

```
输入：weights = [3,2,2,4,1,4], days = 3
输出：6
解释：
船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：
第 1 天：3, 2
第 2 天：2, 4
第 3 天：1, 4

```

 **示例 3：** 

```
输入：weights = [1,2,3,1,1], D = 4
输出：3
解释：
第 1 天：1
第 2 天：2
第 3 天：3
第 4 天：1, 1

```


 **提示：** 

-  `1 <= days <= weights.length <= 5 * 10^4` 
-  `1 <= weights[i] <= 500` 

**标签**
`贪心` `数组` `二分查找` 


##

```python

```

>

# 1044.最长重复子串

[https://leetcode-cn.com/problems/longest-duplicate-substring](https://leetcode-cn.com/problems/longest-duplicate-substring) 

## 原题

给你一个字符串 `s` ，考虑其所有 *重复子串* ：即 `s` 的（连续）子串，在 `s` 中出现 2 次或更多次。这些出现之间可能存在重叠。

返回 **任意一个** 可能具有最长长度的重复子串。如果 `s` 不含重复子串，那么答案为 `""` 。

 

 **示例 1：** 

```
输入：s = "banana"
输出："ana"

```

 **示例 2：** 

```
输入：s = "abcd"
输出：""

```


 **提示：** 

-  `2 <= s.length <= 3 * 10^4` 
-  `s` 由小写英文字母组成

**标签**
`字符串` `二分查找` `后缀数组` `滑动窗口` `哈希函数` `滚动哈希` 


##

```python

```

>

# 1095.山脉数组中查找目标值

[https://leetcode-cn.com/problems/find-in-mountain-array](https://leetcode-cn.com/problems/find-in-mountain-array) 

## 原题

（这是一个 **交互式问题** ）

给你一个 **山脉数组** `mountainArr` ，请你返回能够使得 `mountainArr.get(index)` **等于** `target` **最小** 的下标 `index` 值。

如果不存在这样的下标 `index` ，就请返回 `-1` 。

 

何为山脉数组？如果数组 `A` 是一个山脉数组的话，那它满足如下条件：

 **首先** ， `A.length >= 3` 

 **其次** ，在 `0 < i < A.length - 1` 条件下，存在 `i` 使得：

-  `A[0] < A[1] < ... A[i-1] < A[i]` 
-  `A[i] > A[i+1] > ... > A[A.length - 1]` 


你将 **不能直接访问该山脉数组** ，必须通过 `MountainArray` 接口来获取数据：

-  `MountainArray.get(k)` - 会返回数组中索引为 `k` 的元素（下标从 0 开始）
-  `MountainArray.length()` - 会返回该数组的长度


 **注意：** 

对 `MountainArray.get` 发起超过 `100` 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。

为了帮助大家更好地理解交互式问题，我们准备了一个样例 “ **答案** ”：<a href="https://leetcode-cn.com/playground/RKhe3ave" target="_blank">https://leetcode-cn.com/playground/RKhe3ave</a>，请注意这 **不是一个正确答案** 。


 **示例 1：** 

```
输入：array = [1,2,3,4,5,3,1], target = 3
输出：2
解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。
```

 **示例 2：** 

```
输入：array = [0,1,2,4,2,1], target = 3
输出：-1
解释：3 在数组中没有出现，返回 -1。

```


 **提示：** 

-  `3 <= mountain_arr.length() <= 10000` 
-  `0 <= target <= 10^9` 
-  `0 <= mountain_arr.get(index) <= 10^9` 

**标签**
`数组` `二分查找` `交互` 


##

```python

```

>

# 1237.找出给定方程的正整数解

[https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation](https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation) 

## 原题

给你一个函数   `f(x, y)`  和一个目标结果  `z` ，函数公式未知，请你计算方程  `f(x,y) == z`  所有可能的正整数 **数对**   `x` 和 `y` 。满足条件的结果数对可以按任意顺序返回。

尽管函数的具体式子未知，但它是单调递增函数，也就是说：

-  `f(x, y) < f(x + 1, y)` 
-  `f(x, y) < f(x, y + 1)` 
    函数接口定义如下：

```
interface CustomFunction {
public:
  // Returns some positive integer f(x, y) for two positive integers x and y based on a formula.
  int f(int x, int y);
};
```

你的解决方案将按如下规则进行评判：

- 判题程序有一个由 `CustomFunction` 的 `9` 种实现组成的列表，以及一种为特定的 `z` 生成所有有效数对的答案的方法。
- 判题程序接受两个输入： `function_id` （决定使用哪种实现测试你的代码）以及目标结果 `z` 。
- 判题程序将会调用你实现的 `findSolution` 并将你的结果与答案进行比较。
- 如果你的结果与答案相符，那么解决方案将被视作正确答案，即 `Accepted` 。


 **示例 1：** 

```
输入：function_id = 1, z = 5
输出：[[1,4],[2,3],[3,2],[4,1]]
解释：function_id = 1 暗含的函数式子为 f(x, y) = x + y
以下 x 和 y 满足 f(x, y) 等于 5：
x=1, y=4 -> f(1, 4) = 1 + 4 = 5
x=2, y=3 -> f(2, 3) = 2 + 3 = 5
x=3, y=2 -> f(3, 2) = 3 + 2 = 5
x=4, y=1 -> f(4, 1) = 4 + 1 = 5

```

 **示例 2：** 

```
输入：function_id = 2, z = 5
输出：[[1,5],[5,1]]
解释：function_id = 2 暗含的函数式子为 f(x, y) = x * y
以下 x 和 y 满足 f(x, y) 等于 5：
x=1, y=5 -> f(1, 5) = 1 * 5 = 5
x=5, y=1 -> f(5, 1) = 5 * 1 = 5
```


 **提示：** 

-  `1 <= function_id <= 9` 
-  `1 <= z <= 100` 
-  题目保证  `f(x, y) == z`  的解处于  `1 <= x, y <= 1000`  的范围内。
-  在 `1 <= x, y <= 1000`  的前提下，题目保证  `f(x, y)`  是一个 32 位有符号整数。

**标签**
`数学` `双指针` `二分查找` `交互` 


##

```python

```

>

# 1283.使结果不超过阈值的最小除数

[https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold](https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold) 

## 原题

给你一个整数数组 `nums` 和一个正整数 `threshold` ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。

请你找出能够使上述结果小于等于阈值 `threshold` 的除数中 **最小** 的那个。

每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。

题目保证一定有解。

 

 **示例 1：** 

```
输入：nums = [1,2,5,9], threshold = 6
输出：5
解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。
如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。

```

 **示例 2：** 

```
输入：nums = [2,3,5,7,11], threshold = 11
输出：3

```

 **示例 3：** 

```
输入：nums = [19], threshold = 5
输出：4

```


 **提示：** 

-  `1 <= nums.length <= 5 * 10^4` 
-  `1 <= nums[i] <= 10^6` 
-  `nums.length <= threshold <= 10^6` 

**标签**
`数组` `二分查找` 


##

```python

```

>

# 1292.元素和小于等于阈值的正方形的最大边长

[https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold](https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold) 

## 原题

给你一个大小为  `m x n`  的矩阵  `mat`  和一个整数阈值  `threshold` 。

请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 **0 ** 。<br />


 **示例 1：** 

<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/15/e1.png" style="height: 186px; width: 335px;" />

```
输入：mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4
输出：2
解释：总和小于或等于 4 的正方形的最大边长为 2，如图所示。

```

 **示例 2：** 

```
输入：mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1
输出：0

```

 **示例 3：** 

```
输入：mat = [[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,0,0,0]], threshold = 6
输出：3

```

 **示例 4：** 

```
输入：mat = [[18,70],[61,1],[25,85],[14,40],[11,96],[97,96],[63,45]], threshold = 40184
输出：2

```


 **提示：** 

-  `1 <= m, n <= 300` 
-  `m == mat.length` 
-  `n == mat[i].length` 
-  `0 <= mat[i][j] <= 10000` 
-  `0 <= threshold <= 10^5` 

**标签**
`数组` `二分查找` `矩阵` `前缀和` 


##

```python

```

>

# 1300.转变数组后最接近目标值的数组和

[https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target](https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target) 

## 原题

给你一个整数数组 `arr` 和一个目标值 `target` ，请你返回一个整数 `value` ，使得将数组中所有大于 `value` 的值变成 `value` 后，数组的和最接近 `target` （最接近表示两者之差的绝对值最小）。

如果有多种使得和最接近 `target` 的方案，请你返回这些整数中的最小值。

请注意，答案不一定是 `arr` 中的数字。

 

 **示例 1：** 

```
输入：arr = [4,9,3], target = 10
输出：3
解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。

```

 **示例 2：** 

```
输入：arr = [2,3,5], target = 10
输出：5

```

 **示例 3：** 

```
输入：arr = [60864,25176,27249,21296,20204], target = 56803
输出：11361

```


 **提示：** 

-  `1 <= arr.length <= 10^4` 
-  `1 <= arr[i], target <= 10^5` 

**标签**
`数组` `二分查找` `排序` 


##

```python

```

>

# 1482.制作 m 束花所需的最少天数

[https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets](https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets) 

## 原题

给你一个整数数组 `bloomDay` ，以及两个整数 `m` 和 `k` 。

现需要制作 `m` 束花。制作花束时，需要使用花园中 **相邻的 `k` 朵花** 。

花园中有 `n` 朵花，第 `i` 朵花会在 `bloomDay[i]` 时盛开， **恰好** 可以用于 **一束** 花中。

请你返回从花园中摘 `m` 束花需要等待的最少的天数。如果不能摘到 `m` 束花则返回 **-1** 。

 

 **示例 1：** 

```
输入：bloomDay = [1,10,3,10,2], m = 3, k = 1
输出：3
解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。
现在需要制作 3 束花，每束只需要 1 朵。
1 天后：[x, _, _, _, _]   // 只能制作 1 束花
2 天后：[x, _, _, _, x]   // 只能制作 2 束花
3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3

```

 **示例 2：** 

```
输入：bloomDay = [1,10,3,10,2], m = 3, k = 2
输出：-1
解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。

```

 **示例 3：** 

```
输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
输出：12
解释：要制作 2 束花，每束需要 3 朵。
花园在 7 天后和 12 天后的情况如下：
7 天后：[x, x, x, x, _, x, x]
可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。
12 天后：[x, x, x, x, x, x, x]
显然，我们可以用不同的方式制作两束花。

```

 **示例 4：** 

```
输入：bloomDay = [1000000000,1000000000], m = 1, k = 1
输出：1000000000
解释：需要等 1000000000 天才能采到花来制作花束

```

 **示例 5：** 

```
输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2
输出：9

```


 **提示：** 

-  `bloomDay.length == n` 
-  `1 <= n <= 10^5` 
-  `1 <= bloomDay[i] <= 10^9` 
-  `1 <= m <= 10^6` 
-  `1 <= k <= n` 

**标签**
`数组` `二分查找` 


##

```python

```

>

# 1552.两球之间的磁力

[https://leetcode-cn.com/problems/magnetic-force-between-two-balls](https://leetcode-cn.com/problems/magnetic-force-between-two-balls) 

## 原题

在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 `n` 个空的篮子，第 `i` 个篮子的位置在 `position[i]` ，Morty 想把 `m` 个球放到这些篮子里，使得任意两球间 **最小磁力** 最大。

已知两个球如果分别位于 `x` 和 `y` ，那么它们之间的磁力为 `|x - y|` 。

给你一个整数数组 `position` 和一个整数 `m` ，请你返回最大化的最小磁力。

 

 **示例 1：** 

<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/16/q3v1.jpg" style="height: 195px; width: 562px;">

```
输入：position = [1,2,3,4,7], m = 3
输出：3
解释：将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。

```

 **示例 2：** 

```
输入：position = [5,4,3,2,1,1000000000], m = 2
输出：999999999
解释：我们使用位于 1 和 1000000000 的篮子时最小磁力最大。

```


 **提示：** 

-  `n == position.length` 
-  `2 <= n <= 10^5` 
-  `1 <= position[i] <= 10^9` 
-  所有 `position` 中的整数 **互不相同** 。
-  `2 <= m <= position.length` 

**标签**
`数组` `二分查找` `排序` 


##

```python

```

>

# 2187 完成旅途的最少时间

https://leetcode-cn.com/problems/minimum-time-to-complete-trips/


给你一个数组 `time` ，其中 `time[i]` 表示第 `i` 辆公交车完成 **一趟****旅途** 所需要花费的时间。

每辆公交车可以 **连续** 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 **立马开始** 下一趟旅途。每辆公交车 **独立** 运行，也就是说可以同时有多辆公交车在运行且互不影响。

给你一个整数 `totalTrips` ，表示所有公交车 **总共** 需要完成的旅途数目。请你返回完成 **至少** `totalTrips` 趟旅途需要花费的 **最少** 时间。

**示例 1：**

```
输入：time = [1,2,3], totalTrips = 5
输出：3
解释：
- 时刻 t = 1 ，每辆公交车完成的旅途数分别为 [1,0,0] 。
  已完成的总旅途数为 1 + 0 + 0 = 1 。
- 时刻 t = 2 ，每辆公交车完成的旅途数分别为 [2,1,0] 。
  已完成的总旅途数为 2 + 1 + 0 = 3 。
- 时刻 t = 3 ，每辆公交车完成的旅途数分别为 [3,1,1] 。
  已完成的总旅途数为 3 + 1 + 1 = 5 。
所以总共完成至少 5 趟旅途的最少时间为 3 。
```

**示例 2：**

```
输入：time = [2], totalTrips = 1
输出：2
解释：
只有一辆公交车，它将在时刻 t = 2 完成第一趟旅途。
所以完成 1 趟旅途的最少时间为 2 。
```

**提示：**

*   `1 <= time.length <= 10<sup>5</sup>`
*   `1 <= time[i], totalTrips <= 10<sup>7</sup>`


#### Solution

```python

```

>

# [剑指 Offer 51\. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)


在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

**示例 1:**

```
输入: [7,5,6,4]
输出: 5
```

**限制：**

`0 <= 数组长度 <= 50000`


#### Solution

```python

```



