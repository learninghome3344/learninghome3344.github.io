---
layout:     post
title:      leetcode-专项突击
subtitle:   
date:       2022-03-19
author:     FishRedLeaf
header-img: iu_img/my_iu_11.jpg
catalog: true
tags:
    - DSA与刷题/leetcode

---

专项突击

# 数据结构

## 链表

反转链表：直接反，反一段，k个一组全反

合并k个排序链表

链表是否成环，环的入口



## 栈和队列

逆波兰表达式



## 单调栈

https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/

## 字符串

strStr



## 二叉树

前序遍历

中序遍历

后序遍历

层序遍历

Z字遍历

## 二叉搜索树

https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/solution/zhong-xu-bian-li-tuan-mie-xi-lie-er-cha-sou-suo-sh/

#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

#### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

#### [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

实现一个二叉搜索树迭代器类 `BSTIterator` ，表示一个按中序遍历二叉搜索树（BST）的迭代器：

-  `BSTIterator(TreeNode root)` 初始化 `BSTIterator` 类的一个对象。BST 的根节点 `root` 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。
-  `boolean hasNext()` 如果向指针右侧遍历存在数字，则返回 `true` ；否则返回 `false` 。
-  `int next()` 将指针向右移动，然后返回指针处的数字。
    注意，指针初始化为一个不存在于 BST 中的数字，所以对 `next()` 的首次调用将返回 BST 中的最小元素。
    你可以假设  `next()`  调用总是有效的，也就是说，当调用 `next()`  时，BST 的中序遍历中至少存在一个下一个数字。

 

 **示例：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0lewr4myyj205904yglg.jpg" style="width: 189px; height: 178px;" />

```
输入
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
输出
[null, 3, 7, true, 9, true, 15, true, 20, false]

解释
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // 返回 3
bSTIterator.next();    // 返回 7
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 9
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 15
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 20
bSTIterator.hasNext(); // 返回 False

```


 **提示：** 

- 树中节点的数目在范围 `[1, 10^5]` 内
- `0 <= Node.val <= 10^6` 
- 最多调用 `10^5` 次 `hasNext` 和 `next` 操作


 **进阶：** 

- 你可以设计一个满足下述条件的解决方案吗？ `next()` 和 `hasNext()` 操作均摊时间复杂度为 `O(1)` ，并使用 `O(h)` 内存。其中 `h` 是树的高度。

**标签**
`栈` `树` `设计` `二叉搜索树` `二叉树` `迭代器` 

```python
class BSTIterator:

    def __init__(self, root: TreeNode):
        self.cur = root
        self.stack = []

    def next(self) -> int:
        cur = self.cur
        while cur:
            self.stack.append(cur)
            cur = cur.left
        cur = self.stack.pop()
        val = cur.val
        self.cur = cur.right
        return val

    def hasNext(self) -> bool:
        return self.cur is not None or len(self.stack) > 0
```



#### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

#### [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

#### [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 <a href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796" target="_blank">众数</a>（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

假定 BST 满足如下定义：

- 结点左子树中所含节点的值 **小于等于** 当前节点的值
- 结点右子树中所含节点的值 **大于等于** 当前节点的值
- 左子树和右子树都是二叉搜索树

 **示例 1：** 
<img alt="" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0ldx453d7j203y066jr8.jpg" style="width: 142px; height: 222px;" />

```
输入：root = [1,null,2,2]
输出：[2]

```

 **示例 2：** 

```
输入：root = [0]
输出：[0]

```


 **提示：** 

- 树中节点的数目在范围 `[1, 10^4]` 内
- `-10^5 <= Node.val <= 10^5` 


 **进阶：** 你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

**标签**
`树` `深度优先搜索` `二叉搜索树` `二叉树` 

```python
class Solution:
    def findMode(self, root: TreeNode) -> List[int]:
        p, stack = root, []
        pre, pre_cnt = None, 0
        res, res_cnt = [], 0
        while p or stack:
            if p:
                stack.append(p)
                p = p.left
            else:
                p = stack.pop()
                if pre is None:
                    pre, pre_cnt = p.val, 1
                elif pre == p.val:
                    pre_cnt += 1
                else:
                    if pre_cnt > res_cnt:
                        res, res_cnt = [pre], pre_cnt
                    elif pre_cnt == res_cnt:
                        res.append(pre)
                    pre, pre_cnt = p.val, 1
                p = p.right
        if pre_cnt > res_cnt:
            res, res_cnt = [pre], pre_cnt
        elif pre_cnt == res_cnt:
            res.append(pre)
        return res
```





#### [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

#### [653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

#### [938. 二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)

#### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)


给定一棵二叉搜索树，请找出其中第 `k` 大的节点的值。

**示例 1:**

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

**示例 2:**

```
输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4
```

**限制：**

*   1 ≤ k ≤ 二叉搜索树元素个数

通过改变中序遍历的顺序：根左右 ——> 根右左

```python
class Solution:
    def kthLargest(self, root: TreeNode, k: int) -> int:
        p, stack = root, []
        cnt = 0
        while p or stack:
            if p:
                stack.append(p)
                p = p.right
            else:
                p = stack.pop()
                cnt += 1
                if cnt == k:
                    return p.val
                p = p.left
```

#### [剑指 Offer II 053. 二叉搜索树中的中序后继](https://leetcode-cn.com/problems/P5rCT8/)



## 前缀树



## 并查集



# 算法

## 二分

https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/

## 滑动窗口



## 排序算法

快速排序

归并排序

堆排序

## 拓扑排序



## DFS

https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/

https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-ga-4/

## BFS



## 动态规划

### 背包系列

### 股票买卖

### 其他





## 最短路径算法



# 专项

## 前缀和专项

https://leetcode-cn.com/circle/discuss/JK7Dn9/

https://leetcode-cn.com/circle/article/EQWhUd/





## 矩阵专项



## 整数专项

7.整数反转

8.字符串转换整数

9.回文数

## 实现数据结构专项



## LRU&LFU专项

